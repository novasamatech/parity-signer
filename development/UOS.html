<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Universal offline signature - Polkadot-Vault</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> About Polkadot Vault</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../about/FAQ.html"><strong aria-hidden="true">1.1.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="../about/Security-And-Privacy.html"><strong aria-hidden="true">1.2.</strong> Security-And-Privacy</a></li><li class="chapter-item expanded "><a href="../tutorials/Hierarchical-Deterministic-Key-Derivation.html"><strong aria-hidden="true">1.3.</strong> Hierarchical-Deterministic-Key-Derivation</a></li><li class="chapter-item expanded "><a href="../about/Changelog.html"><strong aria-hidden="true">1.4.</strong> Changelog</a></li></ol></li><li class="chapter-item expanded "><a href="../tutorials/SUMMARY.html"><strong aria-hidden="true">2.</strong> User Guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tutorials/Start.html"><strong aria-hidden="true">2.1.</strong> Start</a></li><li class="chapter-item expanded "><a href="../tutorials/Upgrading.html"><strong aria-hidden="true">2.2.</strong> Upgrading</a></li><li class="chapter-item expanded "><a href="../tutorials/Add-New-Network.html"><strong aria-hidden="true">2.3.</strong> Add New Network</a></li><li class="chapter-item expanded "><a href="../tutorials/Kusama-tutorial.html"><strong aria-hidden="true">2.4.</strong> Kusama-tutorial</a></li><li class="chapter-item expanded "><a href="../tutorials/Recover-Account-Polkadotjs.html"><strong aria-hidden="true">2.5.</strong> Recover-Account-Polkadotjs</a></li></ol></li><li class="chapter-item expanded "><a href="../development/Development.html"><strong aria-hidden="true">3.</strong> Development</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../development/Build.html"><strong aria-hidden="true">3.1.</strong> Build</a></li><li class="chapter-item expanded "><a href="../development/Vault-Structure.html"><strong aria-hidden="true">3.2.</strong> Vault structure</a></li><li class="chapter-item expanded "><a href="../development/Troubleshooting.html"><strong aria-hidden="true">3.3.</strong> Troubleshooting</a></li><li class="chapter-item expanded "><a href="../development/Rustdocs.html"><strong aria-hidden="true">3.4.</strong> Rust docs</a></li><li class="chapter-item expanded "><a href="../development/UOS.html" class="active"><strong aria-hidden="true">3.5.</strong> Universal offline signature</a></li><li class="chapter-item expanded "><a href="../development/Ecosystem.html"><strong aria-hidden="true">3.6.</strong> Vault ecosystem</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Polkadot-Vault</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="scope"><a class="header" href="#scope">Scope</a></h1>
<p>This document provides an interpretation of the UOS format used by Polkadot Vault. The upstream version of the published format has diverged significantly from the actual implementation, so this document represents the current state of the UOS format that is compatible with Polkadot Vault. It only applies to networks compatible with Polkadot Vault, i.e. Substrate-based networks. The document also describes special payloads used to maintain a Polkadot Vault instance.</p>
<p>Therefore, this document effectively describes the input and output format for QR codes used by Polkadot Vault.</p>
<h1 id="terminology"><a class="header" href="#terminology">Terminology</a></h1>
<p>The Vault receives information over an air-gap as QR codes. These codes are read as <code>u8</code> vectors and must always be parsed by the Vault before use.</p>
<p>QR codes can contain information that a user wants to sign with one of the Vault keys, or they may contain update information to ensure smooth operation of the Vault without the need for a reset or connection to the network.</p>
<h2 id="qr-code-content-types"><a class="header" href="#qr-code-content-types">QR code content types</a></h2>
<ol>
<li>Transaction/extrinsic - a single transaction that is to be signed</li>
<li>Bulk transactions - a set of transactions that are to be signed in a single
session</li>
<li>Message - a message that is to be signed with a key</li>
<li>Chain metadata: up-to-date metadata allows the Vault to read transactions content</li>
<li>Chain specs: adds new network to the Vault</li>
<li>Metadata types: is used to update older versions runtime metadata (<code>V13</code> and below)</li>
<li>Key derivations: is used to import and export Vault key paths</li>
</ol>
<h1 id="qr-code-structure"><a class="header" href="#qr-code-structure">QR code structure</a></h1>
<p>QR code envelope has the following structure:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">QR code prefix</th><th style="text-align: left">content</th><th style="text-align: left">ending spacer</th><th style="text-align: left">padding</th></tr></thead><tbody>
<tr><td style="text-align: left">4 bits</td><td style="text-align: left">byte-aligned content</td><td style="text-align: left">4 bits</td><td style="text-align: left">remainder</td></tr>
</tbody></table>
</div>
<p>QR code prefix always starts with <code>0x4</code> symbol indicating &quot;raw&quot; encoding.</p>
<p>Subsequent 2 bytes encode content length. Using this number, QR code parser can
instantly extract content and disregard the rest of QR code.</p>
<p>Actual content is shifted by half-byte, otherwise it is a normal byte sequence.</p>
<h2 id="multiframe-qr"><a class="header" href="#multiframe-qr">Multiframe QR</a></h2>
<p>The information transferred through QR channel into Vault is always enveloped
in multiframe packages (although minimal number of multiframe packages is 1).
There are two standards for the multiframe: <code>RaptorQ</code> erasure coding and legacy
non-erasure multiframe. The type of envelope is determined by the first bit of
the QR code data: <code>0</code> indicates legacy multiframe, <code>1</code> indicates <code>RaptorQ</code></p>
<h5 id="raptorq-multipart-payload"><a class="header" href="#raptorq-multipart-payload"><em>RaptorQ multipart payload</em></a></h5>
<p><a href="https://en.wikipedia.org/wiki/Raptor_code#RaptorQ_code">RaptorQ</a> (<code>RFC6330</code>) is
a variable rate (fountain) erasure code protocol with <a href="https://github.com/cberner/raptorq">reference implementation
in Rust</a></p>
<p>Wrapping content in <code>RaptorQ</code> protocol allows for arbitrary amounts of data to be
transferred reliably within reasonable time. It is recommended to wrap all
payloads into this type of envelope.</p>
<p>Each QR code in <code>RaptorQ</code> encoded multipart payload contains following parts:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">bytes <code>[0..4]</code></th><th style="text-align: left">bytes <code>[4..]</code></th></tr></thead><tbody>
<tr><td style="text-align: left"><code>0x80000000</code> || <code>payload_size</code></td><td style="text-align: left"><code>RaptorQ serialized packet</code></td></tr>
</tbody></table>
</div>
<ul>
<li><code>payload_size</code> <strong>MUST</strong> contain payload size in bytes, represented as
big-endian 32-bit unsigned integer.</li>
<li><code>payload_size</code> <strong>MUST NOT</strong> exceed <code>7FFFFFFF</code></li>
<li><code>payload_size</code> <strong>MUST</strong> be identical in all codes encoding the payload</li>
<li><code>payload_size</code> and <code>RaptorQ serialized packet</code> <strong>MUST</strong> be stored by the Cold
Vault, in no particular order, until their amount is sufficient to decode
the payload.</li>
<li>Hot Wallet <strong>MUST</strong> continuously loop through all the frames showing each
frame for at least 1/30 seconds (recommended frame rate: 4 FPS).</li>
<li>Cold Vault <strong>MUST</strong> be able to start scanning the Multipart Payload <em>at any
frame</em>.</li>
<li>Cold Vault <strong>MUST NOT</strong> expect the frames to come in any particular order.</li>
<li>Cold Vault <strong>SHOULD</strong> show a progress indicator of how many frames it has
successfully scanned out of the estimated minimum required amount.</li>
<li>Hot Wallet <strong>SHOULD</strong> generate sufficient number of recovery frames
(recommended overhead: 100%; minimal reasonable overhead: square root of
number of packets).</li>
<li>Payloads fitting in 1 frame <strong>SHOULD</strong> be shown without recovery frames as
static image.</li>
</ul>
<p>Once sufficient number of frames is collected, they could be processed into
single payload and treated as data vector (&quot;QR code content&quot;).</p>
<h5 id="legacy-multipart-payload"><a class="header" href="#legacy-multipart-payload"><em>Legacy Multipart Payload</em></a></h5>
<p>In real implementation, the Polkadot Vault ecosystem generalized all payloads as
multipart messages. </p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">bytes position</th><th style="text-align: left"><code>[0]</code></th><th style="text-align: left"><code>[1..3]</code></th><th style="text-align: left"><code>[3..5]</code></th><th style="text-align: left"><code>[5..]</code></th></tr></thead><tbody>
<tr><td style="text-align: left">content</td><td style="text-align: left"><code>00</code></td><td style="text-align: left"><code>frame_count</code></td><td style="text-align: left"><code>frame_index</code></td><td style="text-align: left"><code>data</code></td></tr>
</tbody></table>
</div>
<ul>
<li><code>frame</code> <strong>MUST</strong> the number of current frame, '0000' represented as
big-endian 16-bit unsigned integer.</li>
<li><code>frame_count</code> <strong>MUST</strong> the total number of frames, represented as big-endian
16-bit unsigned integer.</li>
<li><code>part_data</code> <strong>MUST</strong> be stored by the Cold Vault, ordered by <code>frame</code> number,
until all frames are scanned.</li>
<li>Hot Wallet <strong>MUST</strong> continuously loop through all the frames showing each
frame for about 2 seconds.</li>
<li>Cold Vault <strong>MUST</strong> be able to start scanning the Multipart Payload <em>at any
frame</em>.</li>
<li>Cold Vault <strong>MUST NOT</strong> expect the frames to come in any particular order.</li>
<li>Cold Vault <strong>SHOULD</strong> show a progress indicator of how many frames it has
successfully scanned out of the total count.</li>
</ul>
<p>Once all frames are combined, the <code>part_data</code> must be concatenated into a
single binary blob and treated as data vector (&quot;QR code content&quot;).</p>
<h2 id="informative-content-of-qr-code"><a class="header" href="#informative-content-of-qr-code">Informative content of QR code</a></h2>
<p>Every QR code content starts with a prelude <code>[0x53, 0x&lt;encryption code&gt;, 0x&lt;payload code&gt;]</code>.</p>
<p><code>0x53</code> is always expected and indicates Substrate-related content.</p>
<p><code>&lt;encryption code&gt;</code> for signables indicates encryption algorithm that will be
used to generate the signature:</p>
<table>
    <tr>
        <td><code>0x00</code></td>
        <td>Ed25519</td>
    </tr>
    <tr>
        <td><code>0x01</code></td>
        <td>Sr25519</td>
    </tr>
    <tr>
        <td><code>0x02</code></td>
        <td>Ecdsa</td>
    </tr>
</table>
<p><code>&lt;encryption code&gt;</code> for updates indicates encryption algorithm that was used to
sign the update:</p>
<table>
    <tr>
        <td><code>0x00</code></td>
        <td>Ed25519</td>
    </tr>
    <tr>
        <td><code>0x01</code></td>
        <td>Sr25519</td>
    </tr>
    <tr>
        <td><code>0x02</code></td>
        <td>Ecdsa</td>
    </tr>
    <tr>
        <td><code>0xff</code></td>
        <td>unsigned</td>
    </tr>
</table>
<p>Derivations import and testing are always unsigned, with <code>&lt;encryption code&gt;</code>
always <code>0xff</code>.</p>
<p>Vault supports following <code>&lt;payload code&gt;</code> variants:</p>
<table>
    <tr>
        <td><code>0x00</code></td>
        <td>legacy mortal transaction</td>
    </tr>
    <tr>
        <td><code>0x02</code></td>
        <td>transaction (both mortal and immortal)</td>
    </tr>
    <tr>
        <td><code>0x03</code></td>
        <td>message</td>
    </tr>
    <tr>
        <td><code>0x04</code></td>
        <td>bulk transactions</td>
    </tr>
    <tr>
        <td><code>0x80</code></td>
        <td>load metadata update</td>
    </tr>
    <tr>
        <td><code>0x81</code></td>
        <td>load types update</td>
    </tr>
    <tr>
        <td><code>0xc1</code></td>
        <td>add specs update</td>
    </tr>
    <tr>
        <td><code>0xde</code></td>
        <td>derivations import</td>
    </tr>
</table>
<p>Note: old UOS specified <code>0x00</code> as mortal transaction and <code>0x02</code> as immortal one,
but currently both mortal and immortal transactions from polkadot-js are <code>0x02</code>.</p>
<h2 id="shared-qr-code-processing-sequence"><a class="header" href="#shared-qr-code-processing-sequence">Shared QR code processing sequence:</a></h2>
<ol>
<li>Read QR code, try interpreting it, and get the hexadecimal string from into
Rust (hexadecimal string is getting changed to raw bytes soon).
If QR code is not processable, nothing happens and the scanner keeps trying to
catch a processable one.</li>
<li>Analyze prelude: is it Substrate? is it a known payload type? If not, Vault
always produces an error and suggests to scan supported payload.</li>
</ol>
<p>Further processing is done based on the payload type.</p>
<h2 id="transaction"><a class="header" href="#transaction">Transaction</a></h2>
<p>Transaction has the following structure:</p>
<table>
    <tr>
        <td>prelude</td><td>public key</td><td>SCALE-encoded call data</td><td>SCALE-encoded extensions</td><td>network genesis hash</td>
    </tr>
</table>
<p>Public key is the key that can sign the transaction. Its length depends on the
<code>&lt;encryption code&gt;</code> declared in transaction prelude:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Encryption</th><th style="text-align: left">Public key length, bytes</th></tr></thead><tbody>
<tr><td style="text-align: left">Ed25519</td><td style="text-align: left">32</td></tr>
<tr><td style="text-align: left">Sr25519</td><td style="text-align: left">32</td></tr>
<tr><td style="text-align: left">Ecdsa</td><td style="text-align: left">33</td></tr>
</tbody></table>
</div>
<p>Call data is <code>Vec&lt;u8&gt;</code> representation of transaction content. Call data must be
parsed by Vault prior to signature generation and becomes a part of signed
blob. Within transaction, the call data is SCALE-encoded, i.e. effectively is
prefixed with compact of its length in bytes.</p>
<p>Extensions contain data additional to the call data, and also are part of a
signed blob. Typical extensions are Era, Nonce, metadata version, etc.
Extensions content and order, in principle, can vary between the networks and
metadata versions.</p>
<p>Network genesis hash determines the network in which the transaction is created.
At the moment genesis hash is fixed-length 32 bytes.</p>
<p>Thus, the transaction structure could also be represented as:</p>
<table>
    <tr>
        <td>prelude</td><td>public key</td><td>compact of call data length</td><td><b>call data</b></td><td><b>SCALE-encoded extensions</b></td><td>network genesis hash</td>
    </tr>
</table>
<p>Bold-marked transaction pieces are used in the blob for which the signature is
produced. If the blob is short, 257 bytes or below, the signature is produced
for it as is. For blobs longer than 257 bytes, 32 byte hash (<code>blake2_256</code>) is
signed instead. This is inherited from earlier Vault versions, and is currently
compatible with polkadot-js.</p>
<h3 id="transaction-parsing-sequence"><a class="header" href="#transaction-parsing-sequence">Transaction parsing sequence</a></h3>
<ol>
<li>
<p>Cut the QR data and get:</p>
<ul>
<li>encryption (single <code>u8</code> from prelude)</li>
<li>transaction author public key, its length matching the encryption (32 or
33 <code>u8</code> immediately after the prelude)</li>
<li>network genesis hash (32 <code>u8</code> at the end)</li>
<li>SCALE-encoded call data and SCALE-encoded extensions as a combined blob
(everything that remains in between the transaction author public kay and
the network genesis hash)</li>
</ul>
<p>If the data length is insufficient, Vault produces an error and suggests to
load non-damaged transaction.</p>
</li>
<li>
<p>Search the Vault database for the network specs (from the network genesis
hash and encryption).</p>
<p>If the network specs are not found, Vault shows:</p>
<ul>
<li>public key and encryption of the transaction author key</li>
<li>error message, that suggests to add network with found genesis hash</li>
</ul>
</li>
<li>
<p>Search the Vault database for the address key (from the transaction author
public key and encryption). Vault will try to interpret and display the
transaction in any case. Signing will be possible only if the parsing is
successful and the address key is known to Vault and is extended to the network
in question.</p>
<ul>
<li>
<p>Address key not found. Signing not possible. Output shows:</p>
<ul>
<li>public key and encryption of the transaction author key</li>
<li>call and extensions parsing result</li>
<li>warning message, that suggests to add the address into Vault</li>
</ul>
</li>
<li>
<p>Address key is found, but it is not extended to the network used. Signing
not possible. Output shows:</p>
<ul>
<li>detailed author key information (base58 representation, identicon,
address details such as address being passworded etc)</li>
<li>call and extensions parsing result</li>
<li>warning message, that suggests extending the address into the network
used</li>
</ul>
</li>
<li>
<p>Address key is found and is extended to the network used. Vault will
proceed to try and interpret the call and extensions. Detailed author
information will be shown regardless of the parsing outcome.
The signing will be allowed only if the parsing is successful.</p>
</li>
</ul>
</li>
<li>
<p>Separate the call and extensions. Call is prefixed by its length compact,
the compact is cut off, the part with length that was indicated in the compact
goes into call data, the part that remains goes into extensions data.</p>
<p>If no compact is found or the length is insufficient, Vault produces an
error that call and extensions could not be separated.</p>
</li>
<li>
<p>Get the metadata set from the Vault database, by the network name from the
network specs. Metadata is used to interpret extensions and then the call
itself.</p>
<p>If there are no metadata entries for the network at all, Vault produces an
error and asks to load the metadata.</p>
<p><code>RuntimeMetadata</code> versions supported by Vault are <code>V12</code>, <code>V13</code>, and <code>V14</code>.
The crucial feature of the <code>V14</code> is that the metadata contains the description
of the types used in the call and extensions production. <code>V12</code> and <code>V13</code> are
legacy versions and provide only text identifiers for the types, and in order to
use them, the supplemental types information is needed.</p>
</li>
<li>
<p>Process the extensions.</p>
<p>Vault already knows in which network the transaction was made, but does not
yet know the metadata version. Metadata version must be one of the signable
extensions. At the same time, the extensions and their order are recorded in the
network metadata. Thus, all metadata entries from the set are checked, from
newest to oldest, in an attempt to find metadata that both decodes the
extensions and has a version that matches the metadata version decoded from the
extensions.</p>
<p>If processing extensions with a single metadata entry results in an error,
the next metadata entry is tried. The errors would be displayed to user only if
all attempts with existing metadata have failed.</p>
<p>Typically, the extensions are quite stable in between the metadata versions
and in between the networks, however, they can be and sometimes are different.</p>
<p>In legacy metadata (<code>RuntimeMetadata</code> version being <code>V12</code> and <code>V13</code>)
extensions have identifiers only, and in Vault the extensions for <code>V12</code> and
<code>V13</code> are hardcoded as:</p>
<ul>
<li><code>Era</code> era</li>
<li><code>Compact(u64)</code> nonce</li>
<li><code>Compact(u128)</code> tip</li>
<li><code>u32</code> metadata version</li>
<li><code>u32</code> tx version</li>
<li><code>H256</code> genesis hash</li>
<li><code>H256</code> block hash</li>
</ul>
<p>If the extensions could not be decoded as the standard set or not all
extensions blob is used, the Vault rejects this metadata version and adds error
into the error set.</p>
<p>Metadata <code>V14</code> has extensions with both identifiers and properly described
types, and Vault decodes extensions as they are recorded in the metadata. For
this,
<a href="https://docs.rs/frame-metadata/latest/frame_metadata/v14/struct.ExtrinsicMetadata.html"><code>ExtrinsicMetadata</code></a>
part of the metadata
<a href="https://docs.rs/frame-metadata/latest/frame_metadata/v14/struct.RuntimeMetadataV14.html"><code>RuntimeMetadataV14</code></a>
is used. Vector <code>signed_extensions</code> in <code>ExtrinsicMetadata</code> is scanned twice,
first for types in <code>ty</code> of the
<a href="https://docs.rs/frame-metadata/latest/frame_metadata/v14/struct.SignedExtensionMetadata.html"><code>SignedExtensionMetadata</code></a>
and then for types in <code>additional_signed</code> of the <code>SignedExtensionMetadata</code>. The
types, when resolved through the types database from the metadata, allow to cut
correct length blobs from the whole SCALE-encoded extensions blob and decode
them properly.</p>
<p>If any of these small decodings fails, the metadata version gets rejected by
the Vault and an error is added to the error set. Same happens if after all
extensions are scanned, some part of extensions blob remains unused.</p>
<p>There are some special extensions that must be treated separately. The
<code>identifier</code> in <code>SignedExtensionMetadata</code> and <code>ident</code> segment of the type
<a href="https://docs.rs/scale-info/latest/scale_info/struct.Path.html"><code>Path</code></a>
are used to trigger types interpretation as specially treated extensions. Each
<code>identifier</code> is encountered twice, once for <code>ty</code> scan, and once for
<code>additional_signed</code> scan. In some cases only one of those types has non-empty
content, in some cases it is both. To distinguish the two, the type-associated
path is used, which points to where the type is defined in Substrate code.
Type-associated path has priority over the identifier.</p>
<p>Path triggers:</p>
<p>| Path | Type is interpreted as |
| :- | :- |
| <code>Era</code> | <code>Era</code> |
| <code>CheckNonce</code> | <code>Nonce</code> |
| <code>ChargeTransactionPayment</code> | tip, gets displayed as balance with decimals and unit corresponding to the network specs |</p>
<p>Identifier triggers, are used if the path trigger was not activated:</p>
<p>| Identifier | Type, if not empty and if there is no path trigger, is interpreted as | Note |
| :- | :- | :- |
| <code>CheckSpecVersion</code> | metadata version | gets checked with the metatada version from the metadata |
| <code>CheckTxVersion</code> | tx version | |
| <code>CheckGenesis</code> | network genesis hash | must match the genesis hash that was cut from the tail of the transaction |
| <code>CheckMortality</code> | block hash | must match the genesis hash if the transaction is immortal; <code>Era</code> has same identifier, but is distinguished by the path |
| <code>CheckNonce</code> | nonce | |
| <code>ChargeTransactionPayment</code> | tip, gets displayed as balance with decimals and unit corresponding to the network specs |</p>
<p>If the extension is not a special case, it is displayed as normal parser
output and does not participate in deciding if the transaction could be signed.</p>
<p>After all extensions are processed, the decoding must yield following
extensions:</p>
<ul>
<li>exactly one <code>Era</code></li>
<li>exactly one <code>Nonce</code> &lt;- this is not so currently, fix it</li>
<li>exactly one <code>BlockHash</code></li>
<li>exactly one <code>GenesisHash</code> &lt;- this is not so currently, fix it</li>
<li>exactly one metadata version</li>
</ul>
<p>If the extension set is different, this results in Vault error for this
particular metadata version, this error goes into error set.</p>
<p>The extensions in the metadata are checked on the metadata loading step,
long before any transactions are even produced. Metadata with incomplete
extensions causes a warning on <code>load_metadata</code> update generation step, and
another one when an update with such metadata gets loaded into Vault.
Nevertheless, such metadata loading into Vault is allowed, as there could be
other uses for metadata except signable transaction signing. Probably.</p>
<p>If the metadata version in extensions does not match the metadata version
of the metadata used, this results in Vault error for this particular metadata
version, this error goes into error set.</p>
<p>If the extensions are completely decoded, with correct set of the special
extensions and the metadata version from the extensions match the metadata
version of the metadata used, the extensions are considered correctly parsed,
and Vault can proceed to the call decoding.</p>
<p>If all metadata entries from the Vault database were tested and no suitable
solution is found, Vault produces an error stating that all attempts to decode
extensions have failed. This could be used by variety of reasons (see above),
but so far the most common one observed was users having the metadata in Vault
not up-to-date with the metadata on chain. Thus, the error must have a
recommendation to update the metadata first.</p>
</li>
<li>
<p>Process the call data.</p>
<p>After the metadata with correct version is established, it is used to parse
the call data itself. Each call begins with <code>u8</code> pallet index, this is the
decoding entry point.</p>
<p>For <code>V14</code> metadata the correct pallet is found in the set of available ones
in <code>pallets</code> field of
<a href="https://docs.rs/frame-metadata/latest/frame_metadata/v14/struct.RuntimeMetadataV14.html"><code>RuntimeMetadataV14</code></a>,
by <code>index</code> field in corresponding
<a href="https://docs.rs/frame-metadata/latest/frame_metadata/v14/struct.PalletMetadata.html"><code>PalletMetadata</code></a>.
The <code>calls</code> field of this <code>PalletMetadata</code>, if it is <code>Some(_)</code>, contains
<a href="https://docs.rs/frame-metadata/latest/frame_metadata/v14/struct.PalletCallMetadata.html"><code>PalletCallMetadata</code></a>
that provides the available calls enum described in <code>types</code> registry of the
<code>RuntimeMetadataV14</code>. For each type in the registry, including this calls enum,
encoded data size is determined, and the decoding is done according to the type.</p>
<p>For <code>V12</code> and <code>V13</code> metadata the correct pallet is also found by scanning
the available pallets and searching for correct pallet index. Then the call is
found using the call index (second <code>u8</code> of the call data). Each call has
associated set of argument names and argument types, however, the argument type
is just a text identifier. The type definitions are not in the metadata and
transactions decoding requires supplemental types information. By default, the
Vault contains types information that was constructed for Westend when Westend
was still using <code>V13</code> metadata and it was so far reasonably sufficient for
simple transactions parsing. If the Vault does not find the type information in
the database <strong>and</strong> has to decode the transaction using <code>V12</code> or <code>V13</code>
metadata, error is produced, indicating that there are no types. Elsewise, for
each encountered argument type the encoded data size is determined, and the
decoding is done according to the argument type.</p>
<p>There are types requiring special display:</p>
<ul>
<li>calls (for cases when a call contains other calls)</li>
<li>numbers that are processed as the balances</li>
</ul>
<p>Calls in <code>V14</code> parsing are distinguished by <code>Call</code> in <code>ident</code> segment of the
type <a href="https://docs.rs/scale-info/latest/scale_info/struct.Path.html"><code>Path</code></a>.
Calls in <code>V12</code> and <code>V13</code> metadata are distinguished by any element of the set
of calls type identifiers in string argument type.</p>
<p>At the moment the numbers that should be displayed as balance in
transactions with <code>V14</code> metadata are determined by the type name <code>type_name</code> of
the corresponding
<a href="https://docs.rs/scale-info/latest/scale_info/struct.Field.html"><code>Field</code></a>
being:</p>
<ul>
<li><code>Balance</code></li>
<li><code>T::Balance</code></li>
<li><code>BalanceOf&lt;T&gt;</code></li>
<li><code>ExtendedBalance</code></li>
<li><code>BalanceOf&lt;T, I&gt;</code></li>
<li><code>DepositBalance</code></li>
<li><code>PalletBalanceOf&lt;T&gt;</code></li>
</ul>
<p>Similar identifiers are used in <code>V12</code> and <code>V13</code>, the checked value is the
string argument type itself.</p>
<p>There could be other instances when the number should be displayed as
balance. However, sometimes the balance is <strong>not</strong> the balance in the units
in the network specs, for example in the <code>assets</code> pallet. See issue
<a href="https://github.com/paritytech/parity-signer/issues/1050">#1050</a> and comments
there for details.</p>
<p>If no errors were encountered while parsing and all call data was used in
the process, the transaction is considered parsed and is displayed to the user,
either ready for signing (if all other checks have passed) or as read-only.</p>
</li>
<li>
<p>If the user chooses to sign the transaction, the Vault produces QR code with
signature, that should be read back into the hot side. As soon as the signature
QR code is generated, the Vault considers the transaction signed.</p>
<p>All signed transactions are entered in the history log, and could be seen
and decoded again from the history log. Transactions not signed by the user do
not go in the history log.</p>
<p>If the key used for the transaction is passworded, user has three attempts
to enter the password correctly. Each incorrect password entry is reflected in
the history.</p>
<p>In the time interval between Vault displaying the parsed transaction and
the user approving it, the transaction details needed to generate the signature
and history log details are temporarily stored in the database. The temporary
storage gets cleared each time before and after use. Vault extracts the stored
transaction data only if the database checksum stored in navigator state is
same as the current checksum of the database. If the password is entered
incorrectly, the database is updated with &quot;wrong password&quot; history entry, and
the checksum in the state gets updated accordingly. Eventually, all transaction
info can and will be moved into state itself and temporary storage will not be
used.</p>
</li>
</ol>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>Alice makes transfer to Bob in Westend network.</p>
<p>Transaction:</p>
<p><code>530102d43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27da40403008eaf04151687736326c9fea17e25fc5287613693c912909cb226aa4794f26a480700e8764817b501b8003223000005000000e143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e538a7d7a0ac17eb6dd004578cb8e238c384a10f57c999a3fa1200409cd9b3f33e143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e</code></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Part</th><th style="text-align: left">Meaning</th><th style="text-align: left">Byte position</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>53</code></td><td style="text-align: left">Substrate-related content</td><td style="text-align: left">0</td></tr>
<tr><td style="text-align: left"><code>01</code></td><td style="text-align: left">Sr25519 encryption algorithm</td><td style="text-align: left">1</td></tr>
<tr><td style="text-align: left"><code>02</code></td><td style="text-align: left">Transaction</td><td style="text-align: left">2</td></tr>
<tr><td style="text-align: left"><code>d435..a27d</code><sup class="footnote-reference"><a href="#1">1</a></sup></td><td style="text-align: left">Alice public key</td><td style="text-align: left">3..=34</td></tr>
<tr><td style="text-align: left"><code>a404..4817</code><sup class="footnote-reference"><a href="#2">2</a></sup></td><td style="text-align: left">SCALE-encoded call data</td><td style="text-align: left">35..=76</td></tr>
<tr><td style="text-align: left"><code>a4</code></td><td style="text-align: left">Compact call data length, 41</td><td style="text-align: left">35</td></tr>
<tr><td style="text-align: left"><code>0403..4817</code><sup class="footnote-reference"><a href="#3">3</a></sup></td><td style="text-align: left">Call data</td><td style="text-align: left">36..=76</td></tr>
<tr><td style="text-align: left"><code>04</code></td><td style="text-align: left">Pallet index 4 in metadata, entry point for decoding</td><td style="text-align: left">36</td></tr>
<tr><td style="text-align: left"><code>b501..3f33</code><sup class="footnote-reference"><a href="#4">4</a></sup></td><td style="text-align: left">Extensions</td><td style="text-align: left">77..=153</td></tr>
<tr><td style="text-align: left"><code>e143..423e</code><sup class="footnote-reference"><a href="#5">5</a></sup></td><td style="text-align: left">Westend genesis hash</td><td style="text-align: left">154..=185</td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><code>d43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d</code></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><code>a40403008eaf04151687736326c9fea17e25fc5287613693c912909cb226aa4794f26a480700e8764817</code></p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p><code>0403008eaf04151687736326c9fea17e25fc5287613693c912909cb226aa4794f26a480700e8764817</code></p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p><code>b501b8003223000005000000e143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e538a7d7a0ac17eb6dd004578cb8e238c384a10f57c999a3fa1200409cd9b3f33</code></p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p><code>e143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e</code></p>
</div>
<h4 id="call-content-is-parsed-using-westend-metadata-in-this-particular-case-westend9010"><a class="header" href="#call-content-is-parsed-using-westend-metadata-in-this-particular-case-westend9010">Call content is parsed using Westend metadata, in this particular case westend9010</a></h4>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Call part</th><th style="text-align: left">Meaning</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>04</code></td><td style="text-align: left">Pallet index 4 (<code>Balances</code>) in metadata, entry point for decoding</td></tr>
<tr><td style="text-align: left"><code>03</code></td><td style="text-align: left">Method index 3 in pallet 4 (<code>transfer_keep_alive</code>), search in metadata what the method contains. Here it is <code>MultiAddress</code> for transfer destination and <code>Compact(u128)</code> balance.</td></tr>
<tr><td style="text-align: left"><code>00</code></td><td style="text-align: left">Enum variant in <code>MultiAddress</code>, <code>AccountId</code></td></tr>
<tr><td style="text-align: left"><code>8eaf..6a48</code><sup class="footnote-reference"><a href="#6">6</a></sup></td><td style="text-align: left">Associated <code>AccountId</code> data, Bob public key</td></tr>
<tr><td style="text-align: left"><code>0700e8764817</code></td><td style="text-align: left"><code>Compact(u128)</code> balance. Amount paid: 100000000000 or, with Westend decimals and unit, 100.000000000 mWND.</td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">6</sup>
<p><code>8eaf04151687736326c9fea17e25fc5287613693c912909cb226aa4794f26a48</code></p>
</div>
<h4 id="extensions-content"><a class="header" href="#extensions-content">Extensions content</a></h4>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Extensions part</th><th style="text-align: left">Meaning</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>b501</code></td><td style="text-align: left">Era: phase 27, period 64</td></tr>
<tr><td style="text-align: left"><code>b8</code></td><td style="text-align: left">Nonce: 46</td></tr>
<tr><td style="text-align: left"><code>00</code></td><td style="text-align: left">Tip: 0 pWND</td></tr>
<tr><td style="text-align: left"><code>32230000</code></td><td style="text-align: left">Metadata version: 9010</td></tr>
<tr><td style="text-align: left"><code>05000000</code></td><td style="text-align: left">Tx version: 5</td></tr>
<tr><td style="text-align: left"><code>e143..423e</code><sup class="footnote-reference"><a href="#7">7</a></sup></td><td style="text-align: left">Westend genesis hash</td></tr>
<tr><td style="text-align: left"><code>538a..3f33</code><sup class="footnote-reference"><a href="#8">8</a></sup></td><td style="text-align: left">Block hash</td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="7"><sup class="footnote-definition-label">7</sup>
<p><code>e143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e</code></p>
</div>
<div class="footnote-definition" id="8"><sup class="footnote-definition-label">8</sup>
<p><code>538a7d7a0ac17eb6dd004578cb8e238c384a10f57c999a3fa1200409cd9b3f33</code></p>
</div>
<h2 id="message"><a class="header" href="#message">Message</a></h2>
<p>Message has the following structure:</p>
<table>
    <tr>
        <td>prelude</td>
        <td>public key</td>
        <td><code>[u8]</code> slice</td>
        <td>network genesis hash</td>
    </tr>
</table>
<p><code>[u8]</code> slice is represented as String if all bytes are valid UTF-8. If not all
bytes are valid UTF-8, the Vault produces an error.</p>
<p>It is critical that the message payloads are always clearly distinguishable from
the transaction payloads, i.e. it is never possible to trick user to sign
transaction posing as a message.</p>
<p>Current proposal is to enable message signing only with Sr25519 encryption
algorithm, with designated signing context, different from the signing context
used for transactions signing.</p>
<h2 id="bulk-transactions"><a class="header" href="#bulk-transactions">Bulk transactions</a></h2>
<p>Bulk transactions is a SCALE-encoded <code>TransactionBulk</code> structure that consists of concatenated <code>Vec&lt;u8&gt;</code> transactions.</p>
<p>Bulking is a way to sign multiple translations at once and reduce the number of QR codes to scan.</p>
<p>Bulk transactions are processed in exactly the same way as single transactions.</p>
<h2 id="update"><a class="header" href="#update">Update</a></h2>
<p>Update has following general structure:</p>
<table>
    <tr>
        <td>prelude</td><td>verifier public key (if signed)</td><td>update payload</td><td>signature (if signed)</td><td>reserved tail</td>
    </tr>
</table>
<p>Note that the <code>verifier public key</code> and <code>signature</code> parts appear only in signed
uploads. Preludes <code>[0x53, 0xff, 0x&lt;payload code&gt;]</code> are followed by the update
payload.</p>
<p>Every time user receives an unsigned update, the Vault displays a warning that
the update is not verified. Generally, the use of unsigned updates is
discouraged.</p>
<p>For update signing it is recommended to use a dedicated key, not used for
transactions. This way, if the signed data was not really the update data, but
something else posing as the update data, the signature produced could not do
any damage.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Encryption</th><th style="text-align: left">Public key length, bytes</th><th style="text-align: left">Signature length, bytes</th></tr></thead><tbody>
<tr><td style="text-align: left">Ed25519</td><td style="text-align: left">32</td><td style="text-align: left">64</td></tr>
<tr><td style="text-align: left">Sr25519</td><td style="text-align: left">32</td><td style="text-align: left">64</td></tr>
<tr><td style="text-align: left">Ecdsa</td><td style="text-align: left">33</td><td style="text-align: left">65</td></tr>
<tr><td style="text-align: left">no encryption</td><td style="text-align: left">0</td><td style="text-align: left">0</td></tr>
</tbody></table>
</div>
<p><code>reserved tail</code> currently is not used and is expected to be empty. It could be
used later if the multisignatures are introduced for the updates. Expecting
<code>reserved tail</code> in update processing is done to keep code continuity in case
multisignatures introduction ever happens.</p>
<p>Because of the <code>reserved tail</code>, the <code>update payload</code> length has to be always
exactly declared, so that the <code>update payload</code> part could be cut correctly from
the update.</p>
<p>Detailed description of the update payloads and form in which they are used in
update itself and for generating update signature, could be found in Rust module
<code>definitions::qr_transfers</code>.</p>
<h3 id="add_specs-update-payload-payload-code-c1"><a class="header" href="#add_specs-update-payload-payload-code-c1"><code>add_specs</code> update payload, payload code <code>c1</code></a></h3>
<p>Introduces a new network to Vault, i.e. adds network specs to the Vault
database.</p>
<p>Update payload is <code>ContentAddSpecs</code> in <code>to_transfer()</code> form, i.e. <strong>double</strong>
SCALE-encoded <code>NetworkSpecsToSend</code> (second SCALE is to have the exact payload
length).</p>
<p>Payload signature is generated for SCALE-encoded <code>NetworkSpecsToSend</code>.</p>
<p>Network specs are stored in dedicated <code>SPECSTREE</code> tree of the Vault database.
Network specs identifier is <code>NetworkSpecsKey</code>, a key built from encryption used
by the network and the network genesis hash. There could be networks with
multiple encryption algorithms supported, thus the encryption is part of the
key.</p>
<p>Some elements of the network specs could be slightly different for networks with
the same genesis hash and different encryptions. There are:</p>
<ul>
<li>
<p>Invariant specs, identical between all different encryptions:</p>
<ul>
<li>name (network name as it appears in metadata)</li>
<li>base58 prefix</li>
</ul>
<p>The reason is that the network name is and the base58 prefix can be a part
of the network metadata, and the network metadata is not encryption-specific.</p>
</li>
<li>
<p>Specs static for given encryption, that should not change over time once set:</p>
<ul>
<li>decimals</li>
<li>unit</li>
</ul>
<p>To replace these, the user would need to remove the network and add it
again, i.e. it won't be possible to do by accident.</p>
</li>
<li>
<p>Flexible display-related and convenience specs, that can change and could be
changed by simply loading new ones over the old ones:</p>
<ul>
<li>color and secondary color (both currently not used, but historically are
there and may return at some point)</li>
<li>logo</li>
<li>path (default derivation path for network, <code>//&lt;network_name&gt;</code>)</li>
<li>title (network title as it gets displayed in the Vault)</li>
</ul>
</li>
</ul>
<h3 id="load_metadata-update-payload-payload-code-80"><a class="header" href="#load_metadata-update-payload-payload-code-80"><code>load_metadata</code> update payload, payload code <code>80</code></a></h3>
<p>Loads metadata for a network already known to Vault, i.e. for a network with
network specs in the Vault database.</p>
<p>Update payload is <code>ContentLoadMeta</code> in <code>to_transfer()</code> form, and consists of
concatenated SCALE-encoded metadata <code>Vec&lt;u8&gt;</code> and network genesis hash (H256,
always 32 bytes).</p>
<p>Same blob is used to generate the signature.</p>
<p>Network metadata is stored in dedicated <code>METATREE</code> tree of the Vault database.
Network metadata identifier in is <code>MetaKey</code>, a key built from the network name
and network metadata version.</p>
<h3 id="metadata-suitable-for-vault"><a class="header" href="#metadata-suitable-for-vault">Metadata suitable for Vault</a></h3>
<p>Network metadata that can get into Vault and can be used by Vault only if it
complies with following requirements:</p>
<ul>
<li>metadata vector starts with <code>b&quot;meta&quot;</code> prelude</li>
<li>part of the metadata vector after <code>b&quot;meta&quot;</code> prelude is decodable as <a href="https://docs.rs/frame-metadata/latest/frame_metadata/enum.RuntimeMetadata.html"><code>RuntimeMetadata</code></a></li>
<li><code>RuntimeMetadata</code> version of the metadata is <code>V12</code>, <code>V13</code> or <code>V14</code></li>
<li>Metadata has <code>System</code> pallet</li>
<li>There is <code>Version</code> constant in <code>System</code> pallet</li>
<li><code>Version</code> is decodable as <a href="https://paritytech.github.io/substrate/master/sp_version/struct.RuntimeVersion.html"><code>RuntimeVersion</code></a></li>
<li>If the metadata contains base58 prefix, it must be decodable as <code>u16</code> or <code>u8</code></li>
</ul>
<p>Additionally, if the metadata <code>V14</code> is received, its associated extensions will
be scanned and user will be warned if the extensions are incompatible with
transactions signing.</p>
<p>Also in case of the metadata <code>V14</code> the type of the encoded data stored in the
<code>Version</code> constant is also stored in the metadata types registry and in
principle could be different from <code>RuntimeVersion</code> above. At the moment, the
type of the <code>Version</code> is hardcoded, and any other types would not be processed
and would get rejected with an error.</p>
<h3 id="load_types-update-payload-payload-code-81"><a class="header" href="#load_types-update-payload-payload-code-81"><code>load_types</code> update payload, payload code <code>81</code></a></h3>
<p>Load types information.</p>
<p>Type information is needed to decode transactions made in networks with metadata
RuntimeMetadata version <code>V12</code> or <code>V13</code>.</p>
<p>Most of the networks are already using RuntimeMetadata version V14, which has
types information incorporated in the metadata itself.</p>
<p>The <code>load_types</code> update is expected to become obsolete soon.</p>
<p>Update payload is <code>ContentLoadTypes</code> in <code>to_transfer()</code>, i.e. <strong>double</strong>
SCALE-encoded <code>Vec&lt;TypeEntry&gt;</code> (second SCALE is to have the exact payload
length).</p>
<p>Payload signature is generated for SCALE-encoded <code>Vec&lt;TypeEntry&gt;</code>.</p>
<p>Types information is stored in <code>SETTREE</code> tree of the Vault database, under key
<code>TYPES</code>.</p>
<h3 id="verifiers"><a class="header" href="#verifiers">Verifiers</a></h3>
<p>Vault can accept both verified and non-verified updates, however, information
once verified can not be replaced or updated by a weaker verifier without full
Vault reset.</p>
<p>A verifier could be <code>Some(_)</code> with corresponding public key inside or <code>None</code>.
All verifiers for the data follow trust on first use principle.</p>
<p>Vault uses:</p>
<ul>
<li>a single general verifier</li>
<li>a network verifier for each of the networks introduced to the Vault</li>
</ul>
<p>General verifier information is stored in <code>SETTREE</code> tree of the Vault database,
under key <code>GENERALVERIFIER</code>. General verifier is always set to a value, be it
<code>Some(_)</code> or <code>None</code>. Removing the general verifier means setting it to <code>None</code>.
If no general verifier entry is found in the database, the database is
considered corrupted and the Vault must be reset.</p>
<p>Network verifier information is stored in dedicated <code>VERIFIERS</code> tree of the
Vault database. Network verifier identifier is <code>VerifierKey</code>, a key built from
the network genesis hash. Same network verifier is used for network specs with
any encryption algorithm and for network metadata. Network verifier could be
valid or invalid. Valid network verifier could be general or custom. Verifiers
installed as a result of an update are always valid. Invalid network verifier
blocks the use of the network unless the Vault is reset, it appears if user
marks custom verifier as no longer trusted.</p>
<p>Updating verifier could cause some data verified by the old verifier to be
removed, to avoid confusion regarding which verifier has signed the data
currently stored in the database. The data removed is called &quot;hold&quot;, and user
receives a warning if accepting new update would cause hold data to be removed.</p>
<h4 id="general-verifier"><a class="header" href="#general-verifier">General verifier</a></h4>
<p>General verifier is the strongest and the most reliable verifier known to the
Vault. General verifier could sign all kinds of updates. By default the Vault
uses Parity-associated key as general verifier, but users can remove it and set
their own. There could be only one general verifier at any time.</p>
<p>General verifier could be removed only by complete wipe of the Vault, through
<code>Remove general certificate</code> button in the Settings. This will reset the Vault
database to the default content and set the general verifier as <code>None</code>, that
will be updated to the first verifier encountered by the Vault.</p>
<p>Expected usage for this is that the user removes old general verifier and
immediately afterwards loads an update from the preferred source, thus setting
the general verifier to the user-preferred value.</p>
<p>General verifier can be updated from <code>None</code> to <code>Some(_)</code> by accepting a verified
update. This would result in removing &quot;general hold&quot;, i.e.:</p>
<ul>
<li>all network data (network specs and metadata) for the networks for which the
verifier is set to the general one</li>
<li>types information</li>
</ul>
<p>General verifier could not be changed from <code>Some(_)</code> to another, different
<code>Some(_)</code> by simply accepting updates.</p>
<p>Note that if the general verifier is <code>None</code>, none of the custom verifiers could
be <code>Some(_)</code>. Similarly, if the verifier is recorded as custom in the database,
its value can not be the same as the value of the general verifier. If found,
those situations indicate the database corruption.</p>
<h4 id="custom-verifiers"><a class="header" href="#custom-verifiers">Custom verifiers</a></h4>
<p>Custom verifiers could be used for network information that was verified, but
not with the general verifier. There could be as many as needed custom verifiers
at any time. Custom verifier is considered weaker than the general verifier.</p>
<p>Custom verifier set to <code>None</code> could be updated to:</p>
<ul>
<li>Another custom verifier set to <code>Some(_)</code></li>
<li>General verifier</li>
</ul>
<p>Custom verifier set to <code>Some(_)</code> could be updated to general verifier.</p>
<p>These verifier updates can be done by accepting an update signed by a new
verifier.</p>
<p>Any of the custom network verifier updates would result in removing &quot;hold&quot;, i.e.
all network specs entries (for all encryption algorithms on file) and all
network metadata entries.</p>
<h3 id="common-update-processing-sequence"><a class="header" href="#common-update-processing-sequence">Common update processing sequence:</a></h3>
<ol>
<li>
<p>Cut the QR data and get:</p>
<ul>
<li>encryption used by verifier (single <code>u8</code> from prelude)</li>
<li>(only if the update is signed, i.e. the encryption is <strong>not</strong> <code>0xff</code>)
update verifier public key, its length matching the encryption (32 or
33 <code>u8</code> immediately after the prelude)</li>
<li>concatenated update payload, verifier signature (only if the update is
signed) and reserved tail.</li>
</ul>
<p>If the data length is insufficient, Vault produces an error and suggests to
load non-damaged update.</p>
</li>
<li>
<p>Using the payload type from the prelude, determine the update payload length
and cut payload from the concatenated verifier signature and reserved tail.</p>
<p>If the data length is insufficient, Vault produces an error and suggests to
load non-damaged update.</p>
</li>
<li>
<p>(only if the update is signed, i.e. the encryption is <strong>not</strong> <code>0xff</code>)
Cut verifier signature, its length matching the encryption (64 or 65 <code>u8</code>
immediately after the update payload). Remaining data is reserved tail,
currently it is not used.</p>
<p>If the data length is insufficient, Vault produces an error and suggests to
load non-damaged update.</p>
</li>
<li>
<p>Verify the signature for the payload. If this fails, Vault produces an error
indicating that the update has invalid signature.</p>
</li>
</ol>
<h3 id="add_specs-processing-sequence"><a class="header" href="#add_specs-processing-sequence"><code>add_specs</code> processing sequence</a></h3>
<ol>
<li>
<p>Update payload is transformed into <code>ContentAddSpecs</code> and the incoming
<code>NetworkSpecsToSend</code> are retrieved, or the Vault produces an error indicating
that the <code>add_specs</code> payload is damaged.</p>
</li>
<li>
<p>Vault checks that there is no change in invariant specs occurring.</p>
<p>If there are entries in the <code>SPECSTREE</code> of the Vault database with same
genesis hash as in newly received specs (the encryption not necessarily
matches), the Vault checks that the name and base58 prefix in the received
specs are same as in the specs already in the Vault database.</p>
</li>
<li>
<p>Vault checks the verifier entry for the received genesis hash.</p>
<p>If there are no entries, i.e. the network is altogether new to the Vault,
the specs could be added into the database. During the same database transaction
the network verifier is set up:</p>
<p>| <code>add_specs</code> update verification | General verifier in Vault database | Action |
| :- | :- | :- |
| unverified, <code>0xff</code> update encryption code | <code>None</code> or <code>Some(_)</code> | (1) set network verifier to custom, <code>None</code> (regardless of the general verifier); (2) add specs |
| verified by <code>a</code> | <code>None</code> | (1) set network verifier to general; (2) set general verifier to <code>Some(a)</code>, process the general hold; (3) add specs |
| verified by <code>a</code> | <code>Some(b)</code> | (1) set network verifier to custom, <code>Some(a)</code>; (2) add specs |
| verified by <code>a</code> | <code>Some(a)</code> | (1) set network verifier to general; (2) add specs |</p>
<p>If there are entries, i.e. the network was known to the Vault at some
point after the last Vault reset, the network verifier in the database and the
verifier of the update are compared. The specs could be added in the database if</p>
<ol>
<li>there are no verifier mismatches encountered (i.e. verifier same or
stronger)</li>
<li>received data causes no change in specs static for encryption</li>
<li>the specs are not yet in the database in exactly same form</li>
</ol>
<p>Note that if the exactly same specs as already in the database are received
with <strong>updated</strong> verifier and the user accepts the update, the verifier will get
updated and the specs will stay in the database.</p>
<p>| <code>add_specs</code> update verification | Network verifier in Vault database | General verifier in Vault database | Action |
| :- | :- | :- | :- |
| unverified, <code>0xff</code> update encryption code | custom, <code>None</code> | <code>None</code> | accept specs if good |
| unverified, <code>0xff</code> update encryption code | custom, <code>None</code> | <code>Some(a)</code> | accept specs if good |
| unverified, <code>0xff</code> update encryption code | general | <code>None</code> | accept specs if good |
| unverified, <code>0xff</code> update encryption code | general | <code>Some(a)</code> | error: update should have been signed by <code>a</code> |
| verified by <code>a</code> | custom, <code>None</code> | <code>None</code> | (1) change network verifier to general, process the network hold; (2) set general verifier to <code>Some(a)</code>, process the general hold; (3) accept specs if good |
| verified by <code>a</code> | custom, <code>None</code> | <code>Some(a)</code> | (1) change network verifier to general, process the network hold; (2) accept specs if good |
| verified by <code>a</code> | custom, <code>None</code> | <code>Some(b)</code> | (1) change network verifier to custom, <code>Some(a)</code>, process the network hold; (2) accept specs if good |
| verified by <code>a</code> | custom, <code>Some(a)</code> | <code>Some(b)</code> | accept specs if good |
| verified by <code>a</code> | custom, <code>Some(b)</code> | <code>Some(a)</code> | (1) change network verifier to general, process the network hold; (2) accept specs if good |
| verified by <code>a</code> | custom, <code>Some(b)</code> | <code>Some(c)</code> | error: update should have been signed by <code>b</code> or <code>c</code> |</p>
<p>Before the <code>NetworkSpecsToSend</code> are added in the <code>SPECSTREE</code>, they get
transformed into <code>NetworkSpecs</code>, and have the <code>order</code> field (display order in
Vault network lists) added. Each new network specs entry gets added in the end
of the list.</p>
</li>
</ol>
<h3 id="load_meta-processing-sequence"><a class="header" href="#load_meta-processing-sequence"><code>load_meta</code> processing sequence</a></h3>
<ol>
<li>
<p>Update payload is transformed into <code>ContentLoadMeta</code>, from which the metadata
and the genesis hash are retrieved, or the Vault produces an error indicating
that the <code>load_metadata</code> payload is damaged.</p>
</li>
<li>
<p>Vault checks that the received metadata fulfills all Vault metadata
requirements outlined <a href="#metadata-suitable-for-signer">above</a>. Otherwise an
error is produced indicating that the received metadata is invalid.</p>
<p>Incoming <code>MetaValues</code> are produced, that contain network name, network
metadata version and optional base58 prefix (if it is recorded in the metadata).</p>
</li>
<li>
<p>Network genesis hash is used to generate <code>VerifierKey</code> and check if the
network has an established network verifier in the Vault database. If there
is no network verifier associated with genesis hash, an error is produced,
indicating that the network metadata could be loaded only for networks
introduced to Vault.</p>
</li>
<li>
<p><code>SPECSTREE</code> tree of the Vault database is scanned in search of entries with
genesis hash matching the one received in payload.</p>
<p>Vault accepts <code>load_metadata</code> updates only for the networks that have at
least one network specs entry in the database.</p>
<p>Note that if the verifier in step (3) above is found, it not necessarily
means that the specs are found (for example, if a network verified by general
verifier was removed by user).</p>
<p>If the specs are found, the Vault checks that the network name and, if
present, base58 prefix from the received metadata match the ones in network
specs from the database. If the values do not match, the Vault produces an
error.</p>
</li>
<li>
<p>Vault compares the verifier of the received update and the verifier for the
network from the database. The update verifier must be exactly the same as the
verifier already in the database. If there is mismatch, Vault produces an
error, indication that the <code>load_metadata</code> update for the network must be signed
by the specified verifier (general or custom) or unsigned.</p>
</li>
<li>
<p>If the update has passed all checks above, the Vault searches for the
metadata entry in the <code>METATREE</code> of the Vault database, using network name and
version from update to produce <code>MetaKey</code>.</p>
<p>If the key is not found in the database, the metadata could be added.</p>
<p>If the key is found in the database and metadata is <strong>exactly the same</strong>,
the Vault produces an error indicating that the metadata is already in the
database. This is expected to be quite common outcome.</p>
<p>If the key is found in the database and the metadata is <strong>different</strong>, the
Vault produces an error. Metadata must be not acceptable. This situation can
occur if there was a silent metadata update or if the metadata is corrupted.</p>
</li>
</ol>
<h3 id="load_types-processing-sequence"><a class="header" href="#load_types-processing-sequence"><code>load_types</code> processing sequence</a></h3>
<ol>
<li>
<p>Update payload is transformed into <code>ContentLoadTypes</code>, from which the types
description vector <code>Vec&lt;TypeEntry&gt;</code> is retrieved, or the Vault produces an
error indicating that the <code>load_types</code> payload is damaged.</p>
</li>
<li>
<p><code>load_types</code> updates must be signed by the general verifier.</p>
<p>| <code>load_types</code> update verification | General verifier in Vault database | Action |
| :- | :- | :- |
| unverified, <code>0xff</code> update encryption code | <code>None</code> | load types if the types are not yet in the database |
| verified by <code>a</code> | <code>None</code> | (1) set general verifier to <code>Some(a)</code>, process the general hold; (2) load types, warn if the types are the same as before |
| verified by <code>a</code> | <code>Some(b)</code> | reject types, error indicates that <code>load_types</code> requires general verifier signature |
| verified by <code>a</code> | <code>Some(a)</code> | load types if the types are not yet in the database |</p>
<p>If the <code>load_types</code> verifier is same as the general verifier in the database
and the types are same as the types in the database, the Vault produces an
error indicating that the types are already known.</p>
<p>Each time the types are loaded, the Vault produces a warning. <code>load_types</code>
is rare and quite unexpected operation.</p>
</li>
</ol>
<h2 id="derivations-import-payload-code-de"><a class="header" href="#derivations-import-payload-code-de">Derivations import, payload code <code>de</code></a></h2>
<p>Derivations import has the following structure:</p>
<table>
    <tr>
        <td>prelude</td><td>derivations import payload</td>
    </tr>
</table>
<p>Derivations import payload is a SCALE-encoded <code>ExportAddrs</code> structure.</p>
<p>It does <em>not</em> contain any private keys or seed phrases.</p>
<p><code>ExportAddrs</code> structure holds the following information about each key:</p>
<ul>
<li>name and public key of the seed the derived key belongs to</li>
<li><code>ss58</code> address of the derived key (<code>h160</code> for ethereum based chains)</li>
<li>derivation path</li>
<li>encryption type</li>
<li>genesis hash of the network the key is used in</li>
</ul>
<p>When processing derivations import, all data after prelude is transformed into
<code>ExportAddrs</code>. Network genesis hash, encryption and derivations set are
derived from it, or the Vault produces a warning indicating that the derivation
import payload is corrupted.</p>
<p>Vault checks that the network for which the derivations are imported has
network specs in the Vault database. If not, a warning is produced.</p>
<p>Vault checks that the derivation set contains only valid derivations. If any
derivation is unsuitable, a warning is produced indicating this.</p>
<p>If the user accepts the derivations import, Vault generates a key for each valid
derivation.</p>
<p>If one of the derived keys already exists, it gets ignored, i.e. no error is
produced.</p>
<p>If there are two derivations with identical path within the payload, only one
derived key is created.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../development/Rustdocs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../development/Ecosystem.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../development/Rustdocs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../development/Ecosystem.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>


    </div>
    </body>
</html>
