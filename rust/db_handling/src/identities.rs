//! Creating, collecting, and removing addresses in cold database
//!
//! In Signer and Signer-related ecosystem the address is a key pair within a
//! certain network. Signer Rust database stores only **non-secret** data
//! associated with each address generated by user.
//!
//! Required data to generate address:
//!
//! - seed phrase (secret words set, must be always zeroized after use and is
//! never stored in Rust database)
//! - derivation path (`/soft//hard///password`); password part, i.e. whatever
//! follows `///` is not stored in Rust database and must be zeroized after use
//! - [`NetworkSpecsKey`](definitions::keyring::NetworkSpecsKey)
//!
//! The combination of seed phrase and derivation path allows to generate key
//! pair using the encryption algorithm supported by the network, for which the
//! address is generated.
//!
//! Signer stores only the public key, it is used together with encryption
//! algorithm [`Encryption`](definitions::crypto::Encryption) to generate
//! [`AddressKey`](definitions::keyring::AddressKey).
//!
//! Same `AddressKey` could correspond to more than one network if the addresses
//! were produced for same seed phrase and derivation path, and networks use
//! same encryption algorithm. The networks specs keys of associated networks
//! are stored in `network_id` field of `AddressDetails`.
//!
//! Signer interface shows those addresses as separate entities.
//!
//! Non-secret data associated with `AddressKey` is stored in
//! [`ADDRTREE`](constants::ADDRTREE) tree of the cold database as SCALE-encoded
//! [`AddressDetails`](definitions::users::AddressDetails).
#[cfg(feature = "signer")]
use bip39::{Language, Mnemonic, MnemonicType};
use lazy_static::lazy_static;
#[cfg(feature = "signer")]
use parity_scale_codec::Encode;
use regex::Regex;
#[cfg(feature = "signer")]
use sled::Batch;
#[cfg(any(feature = "active", feature = "signer"))]
use sp_core::{ecdsa, ed25519, sr25519, Pair};
#[cfg(any(feature = "active", feature = "signer"))]
use sp_runtime::MultiSigner;
#[cfg(any(feature = "active", feature = "signer"))]
use zeroize::Zeroize;

#[cfg(any(feature = "active", feature = "signer"))]
use constants::ADDRTREE;
#[cfg(feature = "active")]
use constants::ALICE_SEED_PHRASE;
#[cfg(feature = "signer")]
use constants::TRANSACTION;

#[cfg(any(feature = "active", feature = "signer"))]
use definitions::{
    crypto::Encryption,
    error::{AddressGenerationCommon, ErrorSource},
    helpers::multisigner_to_public,
    history::{Event, IdentityHistory},
    keyring::{AddressKey, NetworkSpecsKey},
    network_specs::NetworkSpecs,
    users::AddressDetails,
};
#[cfg(feature = "signer")]
use definitions::{
    error::{AddressGeneration, SpecsKeySource},
    error_signer::{
        ErrorSigner, ExtraAddressGenerationSigner, InputSigner, InterfaceSigner, Signer,
    },
};
#[cfg(feature = "active")]
use definitions::{
    error_active::{Active, ErrorActive, InputActive},
    qr_transfers::ContentDerivations,
};

#[cfg(any(feature = "active", feature = "signer"))]
use crate::{
    db_transactions::TrDbCold,
    helpers::{get_all_networks, make_batch_clear_tree, open_db, open_tree, upd_id_batch},
    manage_history::events_to_batch,
};
#[cfg(feature = "signer")]
use crate::{
    db_transactions::TrDbColdDerivations,
    helpers::{get_address_details, get_network_specs},
    interface_signer::addresses_set_seed_name_network,
};

lazy_static! {
// stolen from sp_core
// removed seed phrase part
// last '+' used to be '*', but empty password is an error
    static ref REG_PATH: Regex = Regex::new(r"^(?P<path>(//?[^/]+)*)(///(?P<password>.+))?$").expect("known value");
}

/// Get all existing addresses from the database.
#[cfg(feature = "signer")]
pub(crate) fn get_all_addresses(
    database_name: &str,
) -> Result<Vec<(MultiSigner, AddressDetails)>, ErrorSigner> {
    let database = open_db::<Signer>(database_name)?;
    let identities = open_tree::<Signer>(&database, ADDRTREE)?;
    let mut out: Vec<(MultiSigner, AddressDetails)> = Vec::new();
    for (address_key_vec, address_entry) in identities.iter().flatten() {
        let address_key = AddressKey::from_ivec(&address_key_vec);
        let (multisigner, address_details) =
            AddressDetails::process_entry_with_key_checked::<Signer>(&address_key, address_entry)?;
        out.push((multisigner, address_details));
    }
    Ok(out)
}

/// Get all existing addresses for a given seed name from the database.
#[cfg(feature = "signer")]
pub fn get_addresses_by_seed_name(
    database_name: &str,
    seed_name: &str,
) -> Result<Vec<(MultiSigner, AddressDetails)>, ErrorSigner> {
    Ok(get_all_addresses(database_name)?
        .into_iter()
        .filter(|(_, address_details)| address_details.seed_name == seed_name)
        .collect())
}

/// Generate random phrase with given number of words.
///
/// The output is a **secret seed phrase**.
///
/// Its zeroization and safe handling are delegated to hardware.
#[cfg(feature = "signer")]
pub fn generate_random_phrase(words_number: u32) -> Result<String, ErrorSigner> {
    let mnemonic_type = match MnemonicType::for_word_count(words_number as usize) {
        Ok(a) => a,
        Err(e) => {
            return Err(ErrorSigner::AddressGeneration(AddressGeneration::Extra(
                ExtraAddressGenerationSigner::RandomPhraseGeneration(e),
            )))
        }
    };
    let mnemonic = Mnemonic::new(mnemonic_type, Language::English);
    Ok(mnemonic.into_phrase())
}

/// Data associated with address generation
#[cfg(any(feature = "active", feature = "signer"))]
pub(crate) struct PrepData {
    /// information to be added into [`Batch`](sled::Batch) for [`ADDRTREE`]
    /// update
    pub(crate) address_prep: Vec<(AddressKey, AddressDetails)>,

    /// [`Event`] set, to be added into history log
    pub(crate) history_prep: Vec<Event>,
}

/// Prepare data for address generation using seed phrase, derivation path, and
/// network specs.
///
/// Function generates addresses individually, and checks the database to
/// avoid collisions and duplicates. However, sometimes within a single database
/// transaction multiple addresses are generated, and each new address must be
/// checked with already semi-prepared new addresses set, to avoid collisions,
/// duplicates and overwriting.
///
/// Therefore, function inputs a set of `(AddressKey, AddressDetails)` values
/// already processed in preparation for the current database transaction and if
/// corresponding `AddressKey` is already there, adds new `NetworkSpecsKey` into
/// `AddressDetails` field `network_id` instead of creating a new entry.
///
/// The output [`PrepData`] contains:
///
/// - `address_prep` set of `(AddressKey, AddressDetails)` values that
/// eventually will be transformed into [`Batch`](sled::Batch) to update the
/// `ADDRTREE` of the cold database
/// - output `Event` set that will be eventually added into `HISTORY` as a part
/// of single `Entry`(definitions::history::Entry)
///
/// Function creates only **one** address, and output `PrepData` **updates**
/// address preparation set received as input.
///
/// Function gets used both on Active side (when generating test cold database
/// with well-known addresses) and on Signer side (when real addresses are
/// actually created by the user).
///
/// Secrets passed into this function are:
///
/// - seed phrase
/// - path, possibly with secret password part (`///<...>`).
///
/// Both are input as `&str`. Seed phrase is combined with derivation path into
/// a string, a reference to which is sent into inner logic of
/// [`sp_core::crypto`]. Combined secret string is then zeroized here regardless
/// of the address generation success.
#[cfg(any(feature = "active", feature = "signer"))]
pub(crate) fn create_address<T: ErrorSource>(
    database_name: &str,
    input_batch_prep: &[(AddressKey, AddressDetails)],
    path: &str,
    network_specs: &NetworkSpecs,
    seed_name: &str,
    seed_phrase: &str,
) -> Result<PrepData, T::Error> {
    let mut address_prep = input_batch_prep.to_vec();
    let network_specs_key =
        NetworkSpecsKey::from_parts(&network_specs.genesis_hash, &network_specs.encryption);

    // create fixed-length string to avoid reallocations
    let mut full_address = String::with_capacity(seed_phrase.len() + path.len());
    full_address.push_str(seed_phrase);
    full_address.push_str(path);

    let multisigner = match network_specs.encryption {
        Encryption::Ed25519 => match ed25519::Pair::from_string(&full_address, None) {
            Ok(a) => {
                full_address.zeroize();
                MultiSigner::Ed25519(a.public())
            }
            Err(e) => {
                full_address.zeroize();
                return Err(<T>::address_generation_common(
                    AddressGenerationCommon::SecretString(e),
                ));
            }
        },
        Encryption::Sr25519 => match sr25519::Pair::from_string(&full_address, None) {
            Ok(a) => {
                full_address.zeroize();
                MultiSigner::Sr25519(a.public())
            }
            Err(e) => {
                full_address.zeroize();
                return Err(<T>::address_generation_common(
                    AddressGenerationCommon::SecretString(e),
                ));
            }
        },
        Encryption::Ecdsa => match ecdsa::Pair::from_string(&full_address, None) {
            Ok(a) => {
                full_address.zeroize();
                MultiSigner::Ecdsa(a.public())
            }
            Err(e) => {
                full_address.zeroize();
                return Err(<T>::address_generation_common(
                    AddressGenerationCommon::SecretString(e),
                ));
            }
        },
    };

    let public_key = multisigner_to_public(&multisigner);
    let address_key = AddressKey::from_multisigner(&multisigner);

    // derivation path is cut here, only cropped part (without password) gets
    // stored
    // TODO regex elements may keep the line with password somewhere, how to
    // zeroize then? checked regex crate and it appears that only references are
    // moved around; need to double-check later;
    let (cropped_path, has_pwd) = match REG_PATH.captures(path) {
        Some(caps) => match caps.name("path") {
            Some(a) => (a.as_str(), caps.name("password").is_some()),
            None => ("", caps.name("password").is_some()),
        },
        None => ("", false),
    };

    // prepare history log here
    let identity_history = IdentityHistory::get(
        seed_name,
        &network_specs.encryption,
        &public_key,
        cropped_path,
        &network_specs.genesis_hash,
    );
    let history_prep = vec![Event::IdentityAdded(identity_history)];

    // check if the same address key already participates in current database
    // transaction

    // number in `(AddressKey, AddressDetails)` set with same `AddressKey`, if
    // found
    let mut number_in_current = None;

    for (i, (x_address_key, x_address_details)) in address_prep.iter().enumerate() {
        // `AddressKey` found in transaction preparation
        if x_address_key == &address_key {
            let in_this_network = x_address_details.network_id.contains(&network_specs_key);

            // Even though the public key and `Encryption` are same (resulting
            // in the same `AddressKey`), the path in corresponding
            // `AddressDetails` already in transaction preparation is different
            // from the cropped path used in current address generation.
            // If not checked, may result in uncertainty, as two entries with
            // identical `AddressKey` would be in the set, and during database
            // updating would be effectively overwritten, with only one,
            // undefined, staying in the database.
            if x_address_details.path != cropped_path {
                return Err(<T>::address_generation_common(
                    AddressGenerationCommon::KeyCollisionBatch {
                        seed_name_existing: x_address_details.seed_name.to_string(),
                        seed_name_new: seed_name.to_string(),
                        cropped_path_existing: x_address_details.path.to_string(),
                        cropped_path_new: cropped_path.to_string(),
                        in_this_network,
                    },
                ));
            }
            if !in_this_network {
                number_in_current = Some(i);
                break;
            }
        }
    }
    match number_in_current {
        // `AddressKey` already participates in transaction, just add
        // `NetworkSpecsKey` into corresponding `AddressDetails` `network_id`
        // set
        Some(i) => {
            let mut mod_entry = address_prep.remove(i);
            mod_entry.1.network_id.push(network_specs_key);
            address_prep.push(mod_entry);
            Ok(PrepData {
                address_prep,
                history_prep,
            })
        }

        // `AddressKey` is not yet in the transaction
        None => {
            // check if the `AddressKey` is already in the database
            let database = open_db::<T>(database_name)?;
            let identities = open_tree::<T>(&database, ADDRTREE)?;
            match identities.get(address_key.key()) {
                // `AddressKey` is in the database
                Ok(Some(address_entry)) => {
                    let mut address_details = AddressDetails::from_entry_with_key_checked::<T>(
                        &address_key,
                        address_entry,
                    )?;

                    // Even though the public key and `Encryption` are same
                    // (resulting in the same `AddressKey`), the path in
                    // corresponding `AddressDetails` in the database is
                    // different from the cropped path currently used.
                    // <seed phrase 1> + <derivation path 1> resulted in same
                    // public key as <seed phrase 2> + <derivation path 2>.
                    // For different seed phrases it is possible, but quite
                    // unlikely situation.
                    // For different *spellings* of derivation path, e.g. "//01"
                    // and "//1" it is more likely to happen.
                    // In any case, this is collision error and address is not
                    // created.
                    // TODO more descriptive error may be better
                    if address_details.path != cropped_path {
                        return Err(<T>::address_generation_common(
                            AddressGenerationCommon::KeyCollision {
                                seed_name: address_details.seed_name,
                            },
                        ));
                    }

                    // Check if the address already exists for the network.
                    // UI should not allow user get here unless the derivation
                    // is passworded and already exists.
                    // Proposed derivation is checked dynamically before
                    // address generation could be even called.
                    if !address_details.network_id.contains(&network_specs_key) {
                        address_details.network_id.push(network_specs_key);
                        address_prep.push((address_key, address_details));
                        Ok(PrepData {
                            address_prep,
                            history_prep,
                        })
                    } else {
                        Err(<T>::address_generation_common(
                            AddressGenerationCommon::DerivationExists(
                                multisigner,
                                address_details,
                                network_specs_key,
                            ),
                        ))
                    }
                }

                // `AddressKey` is not in the database either.
                // Make altogether new entry.
                Ok(None) => {
                    let address_details = AddressDetails {
                        seed_name: seed_name.to_string(),
                        path: cropped_path.to_string(),
                        has_pwd,
                        network_id: vec![network_specs_key],
                        encryption: network_specs.encryption.to_owned(),
                    };
                    address_prep.push((address_key, address_details));
                    Ok(PrepData {
                        address_prep,
                        history_prep,
                    })
                }

                // database error
                Err(e) => Err(<T>::db_internal(e)),
            }
        }
    }
}

/// Prepare data for default addresses generation for a seed.
///
/// Each network has a default derivation path, recorded in [`NetworkSpecs`]
/// field `path_id`, normally `path_id` is `//<network_name>`.
///
/// This function prepares the generation of addresses with default derivation
/// paths for each of the available networks. Additionally, if the
/// `make_seed_keys` flag is set to `true` the function also prepares seed key
/// generation.
///
/// The output [`PrepData`] contains:
///
/// - `address_prep` set of `(AddressKey, AddressDetails)` values that
/// eventually will be transformed into [`Batch`](sled::Batch) to update the
/// `ADDRTREE` of the cold database
/// - output `Event` set that will be eventually added into `HISTORY` as a part
/// of single `Entry`(definitions::history::Entry)
///
/// All output `PrepData` elements are generated within this function.
/// It does not input addresses previously processed for the same transaction
/// and therefore does not check for collisions, so this function always goes
/// first, when there are no address additions planned yet.
///
/// This function inputs secret seed phrase as `&str`. It is passed as `&str`
/// into `create_address` and used there.
#[cfg(any(feature = "active", feature = "signer"))]
fn populate_addresses<T: ErrorSource>(
    database_name: &str,
    seed_name: &str,
    seed_phrase: &str,
    make_seed_keys: bool,
) -> Result<PrepData, T::Error> {
    // Set of `(AddressKey, AddressDetails)` to be added into the database.
    // Set is updated and is used on each iteration of `create_address` to check
    // for collisions.
    let mut address_prep: Vec<(AddressKey, AddressDetails)> = Vec::new();

    // Set of associated `Event::IdentityAdded(_)` entries.
    // Gets updated after each successful `create_address` run.
    let mut history_prep: Vec<Event> = Vec::new();

    // Collect all networks known to Signer.
    // Note: networks with all `Encryption` variants are used here if they are
    // in the Signer database.
    let specs_set = get_all_networks::<T>(database_name)?;

    for network_specs in specs_set.iter() {
        // Make seed keys if requested.
        // Seed keys **must** be possible to generate,
        // if a seed key has a collision with some other key, it is an error
        if make_seed_keys {
            let prep_data = create_address::<T>(
                database_name,
                &address_prep,
                "",
                network_specs,
                seed_name,
                seed_phrase,
            )?;
            address_prep = prep_data.address_prep;
            history_prep.extend_from_slice(&prep_data.history_prep);
        }

        // make keys with default derivation if possible;
        // key with default derivation may collide with some other key,
        // this should not prevent generating a seed;
        if let Ok(prep_data) = create_address::<T>(
            database_name,
            &address_prep,
            &network_specs.path_id,
            network_specs,
            seed_name,
            seed_phrase,
        ) {
            address_prep = prep_data.address_prep;
            history_prep.extend_from_slice(&prep_data.history_prep);
        }
    }
    Ok(PrepData {
        address_prep,
        history_prep,
    })
}

/// Accept seed into Signer: add default addresses for a seed in the Signer
/// database.
///
/// Each network has a default derivation path, recorded in [`NetworkSpecs`]
/// field `path_id`, normally `path_id` is `//<network_name>`.
///
/// This function adds addresses with default derivation paths into the Signer
/// database. If the `make_seed_keys` flag is set to `true`, seed keys are also
/// added. History log is accordingly updated.
///
/// This function inputs secret seed phrase as `&str`. It is passed as `&str`
/// into `populate_addresses` and used there.
#[cfg(feature = "signer")]
pub fn try_create_seed(
    seed_name: &str,
    seed_phrase: &str,
    make_seed_keys: bool,
    database_name: &str,
) -> Result<(), ErrorSigner> {
    let mut events: Vec<Event> = vec![Event::SeedCreated(seed_name.to_string())];
    let prep_data =
        populate_addresses::<Signer>(database_name, seed_name, seed_phrase, make_seed_keys)?;
    events.extend_from_slice(&prep_data.history_prep);
    TrDbCold::new()
        .set_addresses(upd_id_batch(Batch::default(), prep_data.address_prep)) // add addresses just made in populate_addresses
        .set_history(events_to_batch::<Signer>(database_name, events)?) // add corresponding history
        .apply::<Signer>(database_name)
}

/// Remove address from the Signer database.
///
/// Address is determined by [`MultiSigner`] and [`NetworkSpecsKey`] of the
/// network.
///
/// Function removes network [`NetworkSpecsKey`] from `network_id` set in
/// [`AddressDetails`] associated with provided [`MultiSigner`]. If no networks
/// associated with [`AddressKey`] remain, i.e. `network_id` set becomes empty,
/// whole entry is removed.
#[cfg(feature = "signer")]
pub fn remove_key(
    database_name: &str,
    multisigner: &MultiSigner,
    network_specs_key: &NetworkSpecsKey,
) -> Result<(), ErrorSigner> {
    remove_keys_set(database_name, &[multisigner.to_owned()], network_specs_key)
}

/// Remove a set of addresses within a single network from the Signer database.
///
/// Address is determined by [`MultiSigner`] and [`NetworkSpecsKey`] of the
/// network. Function inputs network `NetworkSpecsKey` and a set of
/// `MultiSigner` values for which the address within a network must be deleted.
///
/// `NetworkSpecsKey` of the network is removed from `network_id` set in
/// [`AddressDetails`] associated with each of the provided `MultiSigner`
/// values. If no networks associated with [`AddressKey`] remain, i.e.
/// `network_id` set becomes empty, whole associated entry is removed.
#[cfg(feature = "signer")]
pub fn remove_keys_set(
    database_name: &str,
    multiselect: &[MultiSigner],
    network_specs_key: &NetworkSpecsKey,
) -> Result<(), ErrorSigner> {
    let mut id_batch = Batch::default();
    let mut events: Vec<Event> = Vec::new();
    let network_specs = get_network_specs(database_name, network_specs_key)?;
    for multisigner in multiselect.iter() {
        let public_key = multisigner_to_public(multisigner);
        let address_key = AddressKey::from_multisigner(multisigner);
        let mut address_details = get_address_details(database_name, &address_key)?;
        let identity_history = IdentityHistory::get(
            &address_details.seed_name,
            &network_specs.encryption,
            &public_key,
            &address_details.path,
            &network_specs.genesis_hash,
        );
        events.push(Event::IdentityRemoved(identity_history));
        address_details.network_id = address_details
            .network_id
            .into_iter()
            .filter(|id| id != network_specs_key)
            .collect();
        if address_details.network_id.is_empty() {
            id_batch.remove(address_key.key())
        } else {
            id_batch.insert(address_key.key(), address_details.encode())
        }
    }
    TrDbCold::new()
        .set_addresses(id_batch) // modify existing address entries
        .set_history(events_to_batch::<Signer>(database_name, events)?) // add corresponding history
        .apply::<Signer>(database_name)
}

/// Add a set of new derived addresses: N+1, N+2, etc into Signer database.
///
/// The number of the added addresses is set by `increment` input.
///
/// Input [`MultiSigner`] and [`NetworkSpecsKey`] determine the address, and the
/// associated [`AddressDetails`] are found in the database. The derivations are
/// based on the `path` from the `AddressDetails`.
///
/// If the database has addressed in given network with path that could be
/// interpreted as `<path>//<number>`, the first derivation of the increment set
/// is `<path>//<number>+1`. If no such addresses are existing in the database,
/// the first derivation of the increment set is `<path>//0`.
///
/// Further derivations of the increment set have number part increased by 1
/// until all requested derivations are generated.
///
/// Note: this is intended only for addresses not protected by the password
/// (i.e. having derivation path **without** `///<password>` part). If the
/// increment set is created on a passworded address, only public derivation
/// path part will be used for increment set generation.
///
/// This function inputs secret seed phrase as `&str`. It is passed as `&str`
/// into `create_address` and used there.
///
/// ## Example
///
/// User creates increment set of 3 on derivation `//user`. Resulting
/// derivations are:
///
/// - `//user`
/// - `//user//0`
/// - `//user//1`
/// - `//user//2`
///
/// User creates increment set of 2 on `//user` again, resulting derivations
/// are:
///
/// - `//user`
/// - `//user//0`
/// - `//user//1`
/// - `//user//2`
/// - `//user//3`
/// - `//user//4`
///
/// If the increment set of 2 is created on `//user//0`, resulting derivations
/// would be:
///
/// - `//user`
/// - `//user//0`
/// - `//user//0//0`
/// - `//user//0//1`
/// - `//user//1`
/// - `//user//2`
/// - `//user//3`
/// - `//user//4`
#[cfg(feature = "signer")]
pub fn create_increment_set(
    increment: u32,
    multisigner: &MultiSigner,
    network_specs_key: &NetworkSpecsKey,
    seed_phrase: &str,
    database_name: &str,
) -> Result<(), ErrorSigner> {
    let address_details =
        get_address_details(database_name, &AddressKey::from_multisigner(multisigner))?;
    let existing_identities = addresses_set_seed_name_network(
        database_name,
        &address_details.seed_name,
        network_specs_key,
    )?;
    let mut last_index = 0;
    for (_, details) in existing_identities.iter() {
        if let Some(("", suffix)) = details.path.split_once(&address_details.path) {
            if let Some(could_be_number) = suffix.get(2..) {
                if let Ok(index) = could_be_number.parse::<u32>() {
                    last_index = std::cmp::max(index + 1, last_index);
                }
            }
        }
    }
    let network_specs = get_network_specs(database_name, network_specs_key)?;
    let mut identity_adds: Vec<(AddressKey, AddressDetails)> = Vec::new();
    let mut current_events: Vec<Event> = Vec::new();
    for i in 0..increment {
        let path = address_details.path.to_string() + "//" + &(last_index + i).to_string();
        let prep_data = create_address::<Signer>(
            database_name,
            &identity_adds,
            &path,
            &network_specs,
            &address_details.seed_name,
            seed_phrase,
        )?;
        identity_adds = prep_data.address_prep;
        current_events.extend_from_slice(&prep_data.history_prep);
    }
    let id_batch = upd_id_batch(Batch::default(), identity_adds);
    TrDbCold::new()
        .set_addresses(id_batch) // add created addresses
        .set_history(events_to_batch::<Signer>(database_name, current_events)?) // add corresponding history
        .apply::<Signer>(database_name)
}

/// Check derivation format and determine if it has a password.
///
/// Invalid derivation produces an error. Valid derivation is checked for
/// password with regex.
///
// TODO regex and secrets, see `create_address` comments.
#[cfg(feature = "signer")]
pub(crate) fn is_passworded(path: &str) -> Result<bool, ErrorSigner> {
    match REG_PATH.captures(path) {
        Some(caps) => Ok(caps.name("password").is_some()),
        None => Err(ErrorSigner::AddressGeneration(AddressGeneration::Extra(
            ExtraAddressGenerationSigner::InvalidDerivation,
        ))),
    }
}

/// Proposed derivation status.
#[cfg(feature = "signer")]
pub enum DerivationCheck {
    /// Derivation has bad format, UI disables proceeding with address
    /// generation.
    BadFormat,

    /// Derivation has password (`///<password>` part).
    ///
    /// Dynamic check in the database for already existing address is disabled.
    Password,

    /// Derivation has no password.
    ///
    /// Dynamic check in the database for already existing address is enabled.
    ///
    /// Inner content reflects if the already existing address is found and its
    /// details.
    NoPassword(Option<(MultiSigner, AddressDetails)>),
}

/// Preliminarily checks if the user-proposed derivation could be used to create
/// the address.
///
/// This function **does not** use secret phrase, and only searches the
/// [`AddressDetails`] from the database for already existing addresses with
/// same derivation path, in case there is no password in the proposed
/// derivation.
///
/// If the proposed derivation is passworded, no checking could be done without
/// using the seed phrase, and UI allows to proceed to try creating new address.
/// If address already exists, an error would appear on the next stage.
///
/// No checking for collisions is done here (i.e. no checking if the same
/// [`AddressKey`] will be produced for <secret phrase 1> + <derivation path 1>
/// as for already known <secret phrase 2> + <derivation path 2>), because seed
/// phrase is not known. If collision occurs, an error would appear on the next
/// stage.
///
/// Note that the only errors in this function could appear from database
/// malfunction when the database is being searched for the exact match, in case
/// of password-free valid derivation. Bad format of the derivation is **not**
/// an error, UI just does not allow to proceed.
#[cfg(feature = "signer")]
pub(crate) fn derivation_check(
    seed_name: &str,
    path: &str,
    network_specs_key: &NetworkSpecsKey,
    database_name: &str,
) -> Result<DerivationCheck, ErrorSigner> {
    match is_passworded(path) {
        // Proposed derivation has password, no checks could be made, proceed.
        Ok(true) => Ok(DerivationCheck::Password),

        // Proposed derivation has no password, checking the database for exact
        // coincidence.
        Ok(false) => {
            let mut found_exact = None;
            for (multisigner, address_details) in get_all_addresses(database_name)?.into_iter() {
                if (address_details.seed_name == seed_name) // seed name
                    && (address_details.path == path) // derivation path, cropped part without password
                    && (address_details.network_id.contains(network_specs_key)) // in this network
                    && (!address_details.has_pwd)
                // has no password to begin with
                {
                    found_exact = Some((multisigner, address_details));
                    break;
                }
            }
            Ok(DerivationCheck::NoPassword(found_exact))
        }

        // Proposed derivation is not suitable, UI would not allow to proceed.
        // Note that this is **not** an error.
        Err(_) => Ok(DerivationCheck::BadFormat),
    }
}

/// Separate derivation path with password into non-secret part and password.
///
/// Function is expected to deal **only** with derivations having a password
/// (i.e. with `///<password>` part of the derivation path). Password-free
/// derivations do not get to the point in `navigator` where this function is
/// called. Calling this function on password-free derivation is an error.
///
/// Function receives derivation path with secret password part, and outputs
/// hard and soft derivations part and secret password part of the derivation
/// path separately.
///
// TODO regex and secrets, see `create_address` comments.
#[cfg(feature = "signer")]
pub fn cut_path(path: &str) -> Result<(String, String), ErrorSigner> {
    match REG_PATH.captures(path) {
        Some(caps) => {
            let cropped_path = match caps.name("path") {
                Some(a) => a.as_str().to_string(),
                None => "".to_string(),
            };
            match caps.name("password") {
                Some(pwd) => Ok((cropped_path, pwd.as_str().to_string())),
                None => Err(ErrorSigner::Interface(InterfaceSigner::LostPwd)),
            }
        }
        None => Err(ErrorSigner::AddressGeneration(AddressGeneration::Extra(
            ExtraAddressGenerationSigner::InvalidDerivation,
        ))),
    }
}

/// Create a new address in the Signer database.
///
/// If the associated [`AddressKey`] already exists in the [`ADDRTREE`] tree of
/// the Signer database, a new network [`NetworkSpecsKey`] is added into
/// `network_id` set of the `AddressDetails`. If the `AddressKey` is new,
/// a new `ADDRTREE` entry is made.
///
/// Secrets passed into this function are:
///
/// - seed phrase
/// - path, possibly with secret password part (`///<...>`).
///
/// Both are input as `&str` and go directly in `create_address` (both) and
/// `derivation_check` (path only).
#[cfg(feature = "signer")]
pub fn try_create_address(
    seed_name: &str,
    seed_phrase: &str,
    path: &str,
    network_specs_key: &NetworkSpecsKey,
    database_name: &str,
) -> Result<(), ErrorSigner> {
    match derivation_check(seed_name, path, network_specs_key, database_name)? {
        // UI should prevent user from getting into `try_create_address` if
        // derivation has a bad format
        DerivationCheck::BadFormat => Err(ErrorSigner::AddressGeneration(
            AddressGeneration::Extra(ExtraAddressGenerationSigner::InvalidDerivation),
        )),

        // UI should prevent user from getting into `try_create_address` if
        // derivation already exists
        DerivationCheck::NoPassword(Some((multisigner, address_details))) => Err(
            <Signer>::address_generation_common(AddressGenerationCommon::DerivationExists(
                multisigner,
                address_details,
                network_specs_key.to_owned(),
            )),
        ),

        // Valid derivation:
        // - without a password and not in the database
        // - with password
        // Signer can try adding either. Collisions (for both cases) and exact
        // coincidence (for passworded derivation) could not have been checked
        // preliminarily and would result in `create_address` errors here.
        _ => {
            let network_specs = get_network_specs(database_name, network_specs_key)?;
            let prep_data = create_address::<Signer>(
                database_name,
                &Vec::new(), // a single address is created, no data to check against here
                path,
                &network_specs,
                seed_name,
                seed_phrase,
            )?;
            let id_batch = upd_id_batch(Batch::default(), prep_data.address_prep);
            TrDbCold::new()
                .set_addresses(id_batch) // add created address
                .set_history(events_to_batch::<Signer>(
                    database_name,
                    prep_data.history_prep,
                )?) // add corresponding history
                .apply::<Signer>(database_name)
        }
    }
}

/// Generate test Alice addresses in test cold database.
///
/// Function wipes [`ADDRTREE`] and adds:
///
/// - seed key, i.e. seed addresses for all 3 default networks (Polkadot,
/// Kusama, Westend)
/// - addresses with default derivation path in each default network
/// - address with `//Alice` derivation path in Westend network
#[cfg(feature = "active")]
pub fn generate_test_identities(database_name: &str) -> Result<(), ErrorActive> {
    // clear the tree
    let entry_batch = make_batch_clear_tree::<Active>(database_name, ADDRTREE)?;

    // make a record that the tree was wiped
    let mut events = vec![Event::IdentitiesWiped];

    // data for adding seed addresses and addresses with default derivation path
    let prep_data = populate_addresses::<Active>(database_name, "Alice", ALICE_SEED_PHRASE, true)?;

    // Address preparation set, to be used as following `create_address` input.
    // Alice addresses are known and good, so checking them for collisions is
    // not really necessary. This is here just for the sake of completedness.
    let mut address_prep = prep_data.address_prep.to_vec();

    // update events
    events.extend_from_slice(&prep_data.history_prep);

    for network_specs in get_all_networks::<Active>(database_name)?.iter() {
        if (network_specs.name == "westend") && (network_specs.encryption == Encryption::Sr25519) {
            // data for adding address with `//Alice` derivation path in Westend
            // network
            let prep_data = create_address::<Active>(
                database_name,
                &address_prep, // address
                "//Alice",
                network_specs,
                "Alice",
                ALICE_SEED_PHRASE,
            )?;
            address_prep = prep_data.address_prep;
            events.extend_from_slice(&prep_data.history_prep);
        }
    }

    TrDbCold::new()
        .set_addresses(upd_id_batch(entry_batch, address_prep)) // add created addresses
        .set_history(events_to_batch::<Active>(database_name, events)?) // add corresponding history
        .apply::<Active>(database_name)
}

/// Remove all addresses associated with given seed name from the Signer
/// database.
///
/// Complementary action in frontend is removal of the seed data from the device
/// key management system.
///
// TODO remove seed must have an associated log entry; decide who emits it -
// front or back - and add.
#[cfg(feature = "signer")]
pub fn remove_seed(database_name: &str, seed_name: &str) -> Result<(), ErrorSigner> {
    // `Batch` to use
    let mut identity_batch = Batch::default();

    // Associated `Event` set
    let mut events: Vec<Event> = Vec::new();

    // All addresses with given seed name from the database
    let id_set = get_addresses_by_seed_name(database_name, seed_name)?;

    for (multisigner, address_details) in id_set.iter() {
        let address_key = AddressKey::from_multisigner(multisigner);

        // removal of all addresses corresponging to `AddressKey`
        identity_batch.remove(address_key.key());

        let public_key = multisigner_to_public(multisigner);
        for network_specs_key in address_details.network_id.iter() {
            let (genesis_hash_vec, _) = network_specs_key.genesis_hash_encryption::<Signer>(
                SpecsKeySource::AddrTree(address_key.to_owned()),
            )?;
            let identity_history = IdentityHistory::get(
                seed_name,
                &address_details.encryption,
                &public_key,
                &address_details.path,
                &genesis_hash_vec,
            );

            // separate `Event` for each `NetworkSpecsKey` from `network_id` set
            events.push(Event::IdentityRemoved(identity_history));
        }
    }
    TrDbCold::new()
        .set_addresses(identity_batch) // modify addresses
        .set_history(events_to_batch::<Signer>(database_name, events)?) // add corresponding history
        .apply::<Signer>(database_name)
}

/// Create a set of addresses with password-free derivations for user-selected
/// seed.
///
/// Function creates addresses in the Signer database for the derivations
/// received as a part of `derivations` payload. Derivations are already checked
/// and temporarily stored in `TRANSACTIONS` tree of the Signer database.
/// Function retrieves the checked data from the database using input checksum.
///
/// If an address already exists in the database, i.e. the [`AddressDetails`]
/// data associated with the [`AddressKey`] contains exactly same derivation
/// path and `network_id` set contains the network [`NetworkSpecsKey`], it is
/// ignored.
///
/// Collision with address already in the database or with another address from
/// derivations set produces an error.
///
/// Function inputs secret seed phrase as `&str`. It is passed as `&str` into
/// into `create_address` and used there.
///
// TODO this is likely to be considerably changed as soon as UI/UX design
// appears
#[cfg(feature = "signer")]
pub fn import_derivations(
    checksum: u32,
    seed_name: &str,
    seed_phrase: &str,
    database_name: &str,
) -> Result<(), ErrorSigner> {
    // derivations data retrieved from the database
    let content_derivations = TrDbColdDerivations::from_storage(database_name, checksum)?;

    // [`NetworkSpecs`] for the network in which the addresses are generated
    let network_specs = content_derivations.network_specs();

    // Address preparation set, to be modified and used as `create_address`
    // input.
    let mut adds: Vec<(AddressKey, AddressDetails)> = Vec::new();

    // Associated `Event` set
    let mut events: Vec<Event> = Vec::new();

    for path in content_derivations.checked_derivations().iter() {
        // try creating address for each of the derivations
        match create_address::<Signer>(
            database_name,
            &adds,
            path,
            network_specs,
            seed_name,
            seed_phrase,
        ) {
            // success, updating address preparation set and `Event` set
            Ok(prep_data) => {
                adds = prep_data.address_prep;
                events.extend_from_slice(&prep_data.history_prep);
            }

            // exactly same address already exists, ignoring it
            Err(ErrorSigner::AddressGeneration(AddressGeneration::Common(
                AddressGenerationCommon::DerivationExists(_, _, _),
            ))) => (),

            // some other error, processed as a real error
            Err(e) => return Err(e),
        }
    }
    TrDbCold::new()
        .set_addresses(upd_id_batch(Batch::default(), adds)) // modify addresses data
        .set_history(events_to_batch::<Signer>(database_name, events)?) // add corresponding history
        .set_transaction(make_batch_clear_tree::<Signer>(database_name, TRANSACTION)?) // clear transaction tree
        .apply::<Signer>(database_name)
}

/// Check derivations before offering user to import them.
///
/// Signer allows bulk import only for valid derivations without password (i.e.
/// without `///<password>` part).
///
/// This function is used in `transaction_parsing::derivations` to check the
/// incoming derivations once they are received in `derivations` qr code
/// payload.
///
/// Note that once the derivations are checked, they are moved around as
/// "checked derivations" and not checked anymore until they are used in
/// `import_derivations`. Only checked derivations are written into the
/// database temporary storage in `TRANSACTION` tree, same data is recovered as
/// ensured by the checksum matching.
#[cfg(feature = "signer")]
pub fn check_derivation_set(derivations: &[String]) -> Result<(), ErrorSigner> {
    for path in derivations.iter() {
        match REG_PATH.captures(path) {
            Some(caps) => {
                if caps.name("password").is_some() {
                    return Err(ErrorSigner::Input(InputSigner::OnlyNoPwdDerivations));
                }
            }
            None => {
                return Err(ErrorSigner::Input(InputSigner::InvalidDerivation(
                    path.to_string(),
                )))
            }
        }
    }
    Ok(())
}

/// Prepare derivations bulk export content [`ContentDerivations`].
///
/// Function is used on the active side. It inputs information about network in
/// which the derivations would be created if the export is successful
/// (genesis hash and `Encryption`), and the plaintext user derivations set.
///
/// Derivations allowed in the export set must be valid and must have no
/// password (i.e. no `///<password>`) part. The derivations source file must
/// have derivations as a list with each new derivation on the new line.
///
/// The source plaintext is cut in lines and each line is processes using regex,
/// all invalid derivations are ignored. Function prints found valid
/// password-free derivations as well.
#[cfg(feature = "active")]
pub fn prepare_derivations_export(
    encryption: &Encryption,
    genesis_hash: &[u8; 32],
    content: &str,
) -> Result<ContentDerivations, ErrorActive> {
    let mut derivations: Vec<String> = Vec::new();
    let content_set: Vec<&str> = content.trim().split('\n').collect();
    for path in content_set.iter() {
        if let Some(caps) = REG_PATH.captures(path) {
            if let Some(p) = caps.name("path") {
                if caps.name("password").is_none() {
                    derivations.push(p.as_str().to_string())
                }
            }
        }
    }
    if derivations.is_empty() {
        return Err(ErrorActive::Input(InputActive::NoValidDerivationsToExport));
    } else {
        println!(
            "Found and used {} valid password-free derivations:",
            derivations.len()
        );
        for x in derivations.iter() {
            println!("\"{}\"", x);
        }
    }
    Ok(ContentDerivations::generate(
        encryption,
        genesis_hash,
        &derivations,
    ))
}
