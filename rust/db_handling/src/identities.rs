//! Creating, collecting, and removing addresses in cold database
//!
//! In Signer and Signer-related ecosystem the address is a key pair within a
//! certain network. Signer Rust database stores only **non-secret** data
//! associated with each address generated by user.
//!
//! Required data to generate address:
//!
//! - seed phrase (secret words set, must be always zeroized after use and is
//! never stored in Rust database)
//! - derivation path (`/soft//hard///password`); password part, i.e. whatever
//! follows `///` is not stored in Rust database and must be zeroized after use
//! - [`NetworkSpecsKey`](definitions::keyring::NetworkSpecsKey)
//!
//! The combination of seed phrase and derivation path allows to generate key
//! pair using the encryption algorithm supported by the network, for which the
//! address is generated.
//!
//! Signer stores only the public key, it is used together with encryption
//! algorithm [`Encryption`](definitions::crypto::Encryption) to generate
//! [`AddressKey`](definitions::keyring::AddressKey).
//!
//! Same `AddressKey` could correspond to more than one network if the addresses
//! were produced for same seed phrase and derivation path, and networks use
//! same encryption algorithm. The networks specs keys of associated networks
//! are stored in `network_id` field of `AddressDetails`.
//!
//! Signer interface shows those addresses as separate entities.
//!
//! Non-secret data associated with `AddressKey` is stored in
//! [`ADDRTREE`](constants::ADDRTREE) tree of the cold database as SCALE-encoded
//! [`AddressDetails`](definitions::users::AddressDetails).
#[cfg(feature = "signer")]
use bip39::{Language, Mnemonic, MnemonicType};
use lazy_static::lazy_static;
use parity_scale_codec::Decode;
#[cfg(any(feature = "active", feature = "signer"))]
use parity_scale_codec::Encode;
use regex::Regex;
#[cfg(feature = "signer")]
use sled::Batch;
use sp_core::H256;
#[cfg(any(feature = "active", feature = "signer"))]
use sp_core::{ecdsa, ed25519, sr25519, Pair};
use sp_runtime::MultiSignature;
#[cfg(any(feature = "active", feature = "signer"))]
use sp_runtime::MultiSigner;
use std::{collections::HashMap, path::Path};
#[cfg(any(feature = "active", feature = "signer"))]
use zeroize::Zeroize;

#[cfg(any(feature = "active", feature = "signer"))]
use constants::ADDRTREE;
#[cfg(feature = "active")]
use constants::ALICE_SEED_PHRASE;
use definitions::derivations::{
    AddrInfo, ExportAddrs, ExportAddrsV1, SeedInfo, SeedKeysPreviewSummary,
};
use definitions::helpers::base58_to_multisigner;
#[cfg(feature = "signer")]
use definitions::helpers::print_multisigner_as_base58_or_eth;
#[cfg(feature = "signer")]
use definitions::helpers::{get_multisigner, unhex};
#[cfg(feature = "signer")]
use definitions::navigation::ExportedSet;
use definitions::network_specs::NetworkSpecs;
#[cfg(any(feature = "active", feature = "signer"))]
use definitions::{
    crypto::Encryption,
    helpers::multisigner_to_public,
    history::{Event, IdentityHistory},
    keyring::{AddressKey, NetworkSpecsKey},
    users::AddressDetails,
};
#[cfg(feature = "signer")]
use definitions::{
    helpers::make_identicon_from_multisigner,
    navigation::{Address, MKeyDetails, MSCNetworkInfo, QrData},
};

#[cfg(any(feature = "active", feature = "signer"))]
use crate::{
    db_transactions::TrDbCold,
    helpers::{get_all_networks, make_batch_clear_tree, open_db, open_tree, upd_id_batch},
    manage_history::events_to_batch,
};
#[cfg(feature = "signer")]
use crate::{
    helpers::{get_address_details, get_network_specs},
    interface_signer::addresses_set_seed_name_network,
};
use crate::{Error, Result};

lazy_static! {
// stolen from sp_core
// removed seed phrase part
// last '+' used to be '*', but empty password is an error
    static ref REG_PATH: Regex = Regex::new(r"^(?P<path>(//?[^/]+)*)(///(?P<password>.+))?$").expect("known value");
}

#[derive(Clone, Encode, Decode)]
pub enum SignaturesBulk {
    #[codec(index = 4)]
    V1(SignaturesBulkV1),
}

impl From<SignaturesBulkV1> for SignaturesBulk {
    fn from(s: SignaturesBulkV1) -> Self {
        Self::V1(s)
    }
}

#[derive(Clone, Encode, Decode)]
pub struct SignaturesBulkV1 {
    /// Array of signatures.
    signatures: Vec<MultiSignature>,
}

impl From<&[MultiSignature]> for SignaturesBulkV1 {
    fn from(signatures: &[MultiSignature]) -> Self {
        Self {
            signatures: signatures.to_owned(),
        }
    }
}

#[derive(Clone, Encode, Decode)]
pub enum TransactionBulk {
    V1(TransactionBulkV1),
}

#[derive(Clone, Encode, Decode)]
pub struct TransactionBulkV1 {
    pub encoded_transactions: Vec<Vec<u8>>,
}

/// Export all info about keys and their addresses known to Signer
#[cfg(feature = "signer")]
pub fn export_all_addrs<P: AsRef<Path>>(
    db_path: P,
    selected_keys: HashMap<String, ExportedSet>,
) -> Result<ExportAddrs> {
    let mut keys: HashMap<String, Vec<(MultiSigner, AddressDetails)>> = HashMap::new();
    let mut addrs = vec![];

    for (m, a) in get_all_addresses(&db_path)?.into_iter() {
        if selected_keys.contains_key(&a.seed_name) {
            keys.entry(a.seed_name.clone()).or_default().push((m, a));
        }
    }

    for (name, keys) in &keys {
        let mut derived_keys = vec![];

        let multisigner = keys
            .iter()
            .find(|(_, a)| a.is_root())
            .map(|(m, _)| m.to_owned())
            .ok_or(Error::NoRootKeyForSeed(name.to_owned()))?;

        for key in keys {
            if key.1.is_root() {
                continue;
            }

            if let Some(selected_derivations) = selected_keys.get(name) {
                let mut selected = false;

                match selected_derivations {
                    ExportedSet::All => selected = true,
                    ExportedSet::Selected {
                        s: selected_derivations,
                    } => {
                        for selected_derivation in selected_derivations {
                            if selected_derivation.derivation == key.1.path
                                && selected_derivation.network_specs_key
                                    == hex::encode(key.1.network_id[0].key())
                            {
                                selected = true;
                                break;
                            }
                        }
                    }
                }

                if !selected {
                    continue;
                }
            }

            let specs = get_network_specs(&db_path, &key.1.network_id[0])?;
            let address = print_multisigner_as_base58_or_eth(
                &key.0,
                Some(specs.specs.base58prefix),
                key.1.encryption,
            );
            derived_keys.push(AddrInfo {
                address: address.clone(),
                derivation_path: if key.1.path.is_empty() {
                    None
                } else {
                    Some(key.1.path.to_owned())
                },
                encryption: key.1.encryption,
                genesis_hash: specs.specs.genesis_hash,
            });
        }

        addrs.push(SeedInfo {
            name: name.to_string(),
            multisigner,
            derived_keys,
        });
    }

    Ok(ExportAddrs::V1(ExportAddrsV1 { addrs }))
}

#[cfg(feature = "signer")]
pub fn import_all_addrs<P: AsRef<Path>>(
    db_path: P,
    seeds_summary: SeedKeysPreviewSummary,
) -> Result<()> {
    // Address preparation set, to be modified and used as `create_address`
    // input.
    let mut adds: Vec<(AddressKey, AddressDetails)> = vec![];

    // Associated `Event` set
    let mut events: Vec<Event> = vec![];

    for addr in &seeds_summary.seed_keys {
        for derived_key in &addr.importable_keys {
            let path = &derived_key.derivation_path;
            let network_specs_key =
                NetworkSpecsKey::from_parts(&derived_key.genesis_hash, &derived_key.encryption);
            let network_specs = get_network_specs(&db_path, &network_specs_key)?;
            match create_derivation_address(
                &db_path,
                &adds, // a single address is created, no data to check against here
                path,
                &network_specs.specs,
                &addr.name,
                &derived_key.address,
                derived_key.has_pwd,
            ) {
                // success, updating address preparation set and `Event` set
                Ok(prep_data) => {
                    adds = prep_data.address_prep;
                    events.extend_from_slice(&prep_data.history_prep);
                }
                // exactly same address already exists, ignoring it
                Err(Error::DerivationExists { .. }) => (),

                // some other error, processed as a real error
                Err(e) => return Err(e),
            }
        }
    }
    TrDbCold::new()
        .set_addresses(upd_id_batch(Batch::default(), adds)) // modify addresses data
        .set_history(events_to_batch(&db_path, events)?) // add corresponding history
        .apply(&db_path)
}

/// Get all existing addresses from the database.
#[cfg(any(feature = "active", feature = "signer"))]
pub fn get_all_addresses<P>(db_path: P) -> Result<Vec<(MultiSigner, AddressDetails)>>
where
    P: AsRef<Path>,
{
    let database = open_db(&db_path)?;
    let identities = open_tree(&database, ADDRTREE)?;
    let mut out: Vec<(MultiSigner, AddressDetails)> = Vec::new();
    for (address_key_vec, address_entry) in identities.iter().flatten() {
        let address_key = AddressKey::from_ivec(&address_key_vec);
        let (multisigner, address_details) =
            AddressDetails::process_entry_with_key_checked(&address_key, address_entry)?;
        out.push((multisigner, address_details));
    }
    Ok(out)
}

#[cfg(any(feature = "active", feature = "signer"))]
pub fn get_multisigner_by_address<P: AsRef<Path>>(
    db_path: P,
    address: &AddressKey,
) -> Result<Option<MultiSigner>> {
    use definitions::helpers::ecdsa_public_to_eth_address;

    Ok(get_all_addresses(db_path)?.into_iter().find_map(|(m, a)| {
        // TODO: Keys in the system should have disambiguous addressing
        // the current state of events has to do with the fact
        // that some parts of UI may be addressing eth keys by
        // Ethereum addresses and other parts by public keys

        // First check if an etherum address is being requested
        if a.encryption == Encryption::Ethereum {
            if let MultiSigner::Ecdsa(ref public) = m {
                if let Ok(addr) = ecdsa_public_to_eth_address(public) {
                    if addr.as_ref() == address.key() {
                        return Some(m);
                    }
                }
            }
        }

        // TODO: for ecdsa address is not simply a public key
        // Do a general check after Ethereum-specific one
        if address.key() == m.encode() {
            return Some(m);
        }
        None
    }))
}

/// Get all existing addresses for a given seed name from the database.
#[cfg(any(feature = "active", feature = "signer"))]
pub fn get_addresses_by_seed_name<P>(
    db_path: P,
    seed_name: &str,
) -> Result<Vec<(MultiSigner, AddressDetails)>>
where
    P: AsRef<Path>,
{
    Ok(get_all_addresses(&db_path)?
        .into_iter()
        .filter(|(_, address_details)| address_details.seed_name == seed_name)
        .collect())
}

/// Generate random phrase with given number of words.
///
/// The output is a **secret seed phrase**.
///
/// Its zeroization and safe handling are delegated to hardware.
#[cfg(feature = "signer")]
pub fn generate_random_phrase(words_number: u32) -> Result<String> {
    let mnemonic_type = MnemonicType::for_word_count(words_number as usize)?;
    let mnemonic = Mnemonic::new(mnemonic_type, Language::English);
    Ok(mnemonic.into_phrase())
}

/// Check that key with a given path should be marked as a progeny of a key with
/// exposed secret.
///
/// There could be false positives here, as the passwords are not stored
/// anywhere in Signer, therefore if there are two passwords, there is no way to
/// check if they are different.
///
/// <table>
///     <tr><th>current</th><th>mark current?</th><th>exposed in set</th></tr>
///     <tr><td><code>//Alice</code></td><td>-</td><td><code>//Ali</code></td></tr>
///     <tr><td><code>//Alice//1</code></td><td>+</td><td><code>//Alice</code></td></tr>
///     <tr><td><code>//Alice///&ltpassword&gt</code></td><td>+</td><td><code>//Alice</code></td></tr>
///     <tr><td><code>//Alice//1///&ltpassword&gt</code></td><td>+</td><td><code>//Alice</code></td></tr>
///     <tr><td><code>//Alice</code></td><td>-</td><td><code>//Alice///&ltpassword&gt</code></td></tr>
///     <tr><td><code>//Alice//1</code></td><td>-</td><td><code>//Alice///&ltpassword&gt</code></td></tr>
///     <tr><td><code>//Alice///&ltpassword1&gt</code></td><td>+</td><td><code>//Alice///&ltpassword0&gt</code></td></tr>
///     <tr><td><code>//Alice//1///&ltpassword1&gt</code></td><td>+</td><td><code>//Alice///&ltpassword0&gt</code></td></tr>
///
/// </table>
#[cfg(any(feature = "active", feature = "signer"))]
pub(crate) fn is_potentially_exposed(
    path: &str,
    path_is_passworded: bool,
    exposed_path: &str,
    exposed_is_passworded: bool,
) -> bool {
    if (path == exposed_path) || path.starts_with(&format!("{}/", exposed_path)) {
        path_is_passworded || !exposed_is_passworded
    } else {
        false
    }
}

/// Check if given key should be marked as exposed because its parent was
/// exposed.
///
/// Input set is already filtered by seed name elsewhere.
#[cfg(any(feature = "active", feature = "signer"))]
fn has_parent_with_exposed_secret<P>(
    new_cropped_path: &str,
    new_is_passworded: bool,
    seed_name: &str,
    db_path: P,
) -> Result<bool>
where
    P: AsRef<Path>,
{
    Ok(get_addresses_by_seed_name(db_path, seed_name)?
        .iter()
        .any(|(_, address_details)| {
            address_details.secret_exposed
                && is_potentially_exposed(
                    new_cropped_path,
                    new_is_passworded,
                    &address_details.path,
                    address_details.has_pwd,
                )
        }))
}

/// Find all `(AddressKey, AddressDetails)` that must be marked as exposed
/// because current key gets exposed.
///
/// Input set is already filtered by the seed name elsewhere.
#[cfg(feature = "signer")]
fn exposed_set(
    exposed_cropped_path: &str,
    exposed_is_passworded: bool,
    filtered_set: Vec<(MultiSigner, AddressDetails)>,
) -> Vec<(MultiSigner, AddressDetails)> {
    filtered_set
        .into_iter()
        .filter(|(_, address_details)| {
            is_potentially_exposed(
                &address_details.path,
                address_details.has_pwd,
                exposed_cropped_path,
                exposed_is_passworded,
            )
        })
        .collect()
}

/// Data associated with address generation
#[cfg(any(feature = "active", feature = "signer"))]
pub(crate) struct PrepData {
    /// information to be added into [`Batch`](sled::Batch) for [`ADDRTREE`]
    /// update
    pub(crate) address_prep: Vec<(AddressKey, AddressDetails)>,

    /// [`Event`] set, to be added into history log
    pub(crate) history_prep: Vec<Event>,
}

/// Prepare data for address generation using seed phrase, derivation path, and
/// network specs.
///
/// Function generates addresses individually, and checks the database to
/// avoid collisions and duplicates. However, sometimes within a single database
/// transaction multiple addresses are generated, and each new address must be
/// checked with already semi-prepared new addresses set, to avoid collisions,
/// duplicates and overwriting.
///
/// Therefore, function inputs a set of `(AddressKey, AddressDetails)` values
/// already processed in preparation for the current database transaction and if
/// corresponding `AddressKey` is already there, adds new `NetworkSpecsKey` into
/// `AddressDetails` field `network_id` instead of creating a new entry.
///
/// The output [`PrepData`] contains:
///
/// - `address_prep` set of `(AddressKey, AddressDetails)` values that
/// eventually will be transformed into [`Batch`](sled::Batch) to update the
/// `ADDRTREE` of the cold database
/// - output `Event` set that will be eventually added into `HISTORY` as a part
/// of single `Entry`(definitions::history::Entry)
///
/// Function creates only **one** address, and output `PrepData` **updates**
/// address preparation set received as input.
///
/// Function gets used both on Active side (when generating test cold database
/// with well-known addresses) and on Signer side (when real addresses are
/// actually created by the user).
///
/// Secrets passed into this function are:
///
/// - seed phrase
/// - path, possibly with secret password part (`///<...>`).
///
/// Both are input as `&str`. Seed phrase is combined with derivation path into
/// a string, a reference to which is sent into inner logic of
/// [`sp_core::crypto`]. Combined secret string is then zeroized here regardless
/// of the address generation success.
#[cfg(any(feature = "active", feature = "signer"))]
pub(crate) fn create_address<P>(
    db_path: P,
    input_batch_prep: &[(AddressKey, AddressDetails)],
    path: &str,
    network_specs: &NetworkSpecs,
    seed_name: &str,
    seed_phrase: &str,
) -> Result<PrepData>
where
    P: AsRef<Path>,
{
    // Check that the seed phrase is not empty.
    // In upstream, empty seed phrase means default Alice seed phrase.
    if seed_phrase.is_empty() {
        return Err(Error::EmptySeed);
    }
    // create fixed-length string to avoid reallocations
    let mut full_address = String::with_capacity(seed_phrase.len() + path.len());
    full_address.push_str(seed_phrase);
    full_address.push_str(path);

    let multisigner = match network_specs.encryption {
        Encryption::Ed25519 => match ed25519::Pair::from_string(&full_address, None) {
            Ok(a) => {
                full_address.zeroize();
                MultiSigner::Ed25519(a.public())
            }
            Err(e) => {
                full_address.zeroize();
                return Err(Error::SecretStringError(e));
            }
        },
        Encryption::Sr25519 => match sr25519::Pair::from_string(&full_address, None) {
            Ok(a) => {
                full_address.zeroize();
                MultiSigner::Sr25519(a.public())
            }
            Err(e) => {
                full_address.zeroize();
                return Err(Error::SecretStringError(e));
            }
        },
        Encryption::Ecdsa | Encryption::Ethereum => {
            match ecdsa::Pair::from_string(&full_address, None) {
                Ok(a) => {
                    full_address.zeroize();
                    MultiSigner::Ecdsa(a.public())
                }
                Err(e) => {
                    full_address.zeroize();
                    return Err(Error::SecretStringError(e));
                }
            }
        }
    };

    // TODO regex elements may keep the line with password somewhere, how to
    // zeroize then? checked regex crate and it appears that only references are
    // moved around; need to double-check later;
    let (cropped_path, has_pwd) = match REG_PATH.captures(path) {
        Some(caps) => match caps.name("path") {
            Some(a) => (a.as_str(), caps.name("password").is_some()),
            None => ("", caps.name("password").is_some()),
        },
        None => ("", false),
    };

    do_create_address(
        db_path,
        input_batch_prep,
        cropped_path,
        network_specs,
        seed_name,
        multisigner,
        has_pwd,
    )
}

#[cfg(any(feature = "active", feature = "signer"))]
pub(crate) fn create_derivation_address<P>(
    db_path: P,
    input_batch_prep: &[(AddressKey, AddressDetails)],
    path: &str,
    network_specs: &NetworkSpecs,
    seed_name: &str,
    ss58: &str,
    has_pwd: bool,
) -> Result<PrepData>
where
    P: AsRef<Path>,
{
    let multisigner = base58_to_multisigner(ss58, &network_specs.encryption)?;
    do_create_address(
        db_path,
        input_batch_prep,
        path,
        network_specs,
        seed_name,
        multisigner,
        has_pwd,
    )
}

fn do_create_address<P>(
    db_path: P,
    input_batch_prep: &[(AddressKey, AddressDetails)],
    cropped_path: &str,
    network_specs: &NetworkSpecs,
    seed_name: &str,
    multisigner: MultiSigner,
    has_pwd: bool,
) -> Result<PrepData>
where
    P: AsRef<Path>,
{
    // Check that the seed name is not empty.
    if seed_name.is_empty() {
        return Err(Error::EmptySeedName);
    }
    let mut address_prep = input_batch_prep.to_vec();
    let network_specs_key =
        NetworkSpecsKey::from_parts(&network_specs.genesis_hash, &network_specs.encryption);

    let public_key = multisigner_to_public(&multisigner);
    let address_key = AddressKey::from_multisigner(&multisigner);

    // prepare history log here
    let identity_history = IdentityHistory::get(
        seed_name,
        &network_specs.encryption,
        &public_key,
        cropped_path,
        network_specs.genesis_hash,
    );
    let history_prep = vec![Event::IdentityAdded { identity_history }];

    // check if the same address key already participates in current database
    // transaction

    // number in `(AddressKey, AddressDetails)` set with same `AddressKey`, if
    // found
    let mut number_in_current = None;

    for (i, (x_address_key, x_address_details)) in address_prep.iter().enumerate() {
        // `AddressKey` found in transaction preparation
        if x_address_key == &address_key {
            let in_this_network = x_address_details.network_id.contains(&network_specs_key);

            // Even though the public key and `Encryption` are same (resulting
            // in the same `AddressKey`), the path in corresponding
            // `AddressDetails` already in transaction preparation is different
            // from the cropped path used in current address generation.
            // If not checked, may result in uncertainty, as two entries with
            // identical `AddressKey` would be in the set, and during database
            // updating would be effectively overwritten, with only one,
            // undefined, staying in the database.
            if x_address_details.path != cropped_path {
                return Err(Error::KeyCollisionBatch {
                    seed_name_existing: x_address_details.seed_name.to_string(),
                    seed_name_new: seed_name.to_string(),
                    cropped_path_existing: x_address_details.path.to_string(),
                    cropped_path_new: cropped_path.to_string(),
                    in_this_network,
                });
            }

            // Note that no error would be caused if two identical addresses
            // were proposed in same address generation set.
            if !in_this_network {
                number_in_current = Some(i);
                break;
            }
        }
    }
    match number_in_current {
        // `AddressKey` already participates in transaction, just add
        // `NetworkSpecsKey` into corresponding `AddressDetails` `network_id`
        // set
        Some(i) => {
            let mut mod_entry = address_prep.remove(i);
            mod_entry.1.network_id.push(network_specs_key);
            address_prep.push(mod_entry);
            Ok(PrepData {
                address_prep,
                history_prep,
            })
        }

        // `AddressKey` is not yet in the transaction
        None => {
            // The only way to create address with `secret_exposed` marker is if
            // the parent with exposed secret is in the database.
            //
            // If the address key already exists in the database, the
            // `secret_exposed` flag will not be changed by extending key to
            // another network.
            let secret_exposed =
                has_parent_with_exposed_secret(cropped_path, has_pwd, seed_name, &db_path)?;

            // check if the `AddressKey` is already in the database
            let database = open_db(&db_path)?;
            let identities = open_tree(&database, ADDRTREE)?;
            match identities.get(address_key.key()) {
                // `AddressKey` is in the database
                Ok(Some(address_entry)) => {
                    let mut address_details =
                        AddressDetails::from_entry_with_key_checked(&address_key, address_entry)?;

                    // Even though the public key and `Encryption` are same
                    // (resulting in the same `AddressKey`), the path in
                    // corresponding `AddressDetails` in the database is
                    // different from the cropped path currently used.
                    // <seed phrase 1> + <derivation path 1> resulted in same
                    // public key as <seed phrase 2> + <derivation path 2>.
                    // For different seed phrases it is possible, but quite
                    // unlikely situation.
                    // For different *spellings* of derivation path, e.g. "//01"
                    // and "//1" it is more likely to happen.
                    // In any case, this is collision error and address is not
                    // created.
                    // TODO more descriptive error may be better
                    if address_details.path != cropped_path {
                        return Err(Error::KeyCollision {
                            seed_name: address_details.seed_name,
                        });
                    }

                    // Expected `secret_exposed` flag activated. Could indicate
                    // the database corruption.
                    if secret_exposed && !address_details.secret_exposed {
                        return Err(Error::SecretExposedMismatch {
                            multisigner,
                            address_details,
                        });
                    }

                    // Check if the address already exists for the network.
                    // UI should not allow user get here unless the derivation
                    // is passworded and already exists.
                    // Proposed derivation is checked dynamically before
                    // address generation could be even called.
                    if !address_details.network_id.contains(&network_specs_key) {
                        address_details.network_id.push(network_specs_key);
                        address_prep.push((address_key, address_details));
                        Ok(PrepData {
                            address_prep,
                            history_prep,
                        })
                    } else {
                        Err(Error::DerivationExists {
                            multisigner,
                            address_details,
                            network_specs_key,
                        })
                    }
                }

                // `AddressKey` is not in the database either.
                // Make altogether new entry.
                Ok(None) => {
                    let address_details = AddressDetails {
                        seed_name: seed_name.to_string(),
                        path: cropped_path.to_string(),
                        has_pwd,
                        network_id: vec![network_specs_key],
                        encryption: network_specs.encryption.to_owned(),
                        secret_exposed,
                    };
                    address_prep.push((address_key, address_details));
                    Ok(PrepData {
                        address_prep,
                        history_prep,
                    })
                }

                // database error
                Err(e) => Err(e.into()),
            }
        }
    }
}

/// Prepare data for default addresses generation for a seed.
///
/// Each network has a default derivation path, recorded in [`NetworkSpecs`]
/// field `path_id`, normally `path_id` is `//<network_name>`.
///
/// This function prepares the generation of addresses with default derivation
/// paths for each of the available networks. Additionally, if the
/// `make_seed_keys` flag is set to `true` the function also prepares seed key
/// generation.
///
/// The output [`PrepData`] contains:
///
/// - `address_prep` set of `(AddressKey, AddressDetails)` values that
/// eventually will be transformed into [`Batch`](sled::Batch) to update the
/// `ADDRTREE` of the cold database
/// - output `Event` set that will be eventually added into `HISTORY` as a part
/// of single `Entry`(definitions::history::Entry)
///
/// All output `PrepData` elements are generated within this function.
/// It does not input addresses previously processed for the same transaction
/// and therefore does not check for collisions, so this function always goes
/// first, when there are no address additions planned yet.
///
/// This function inputs secret seed phrase as `&str`. It is passed as `&str`
/// into `create_address` and used there.
#[cfg(any(feature = "active", feature = "signer"))]
fn populate_addresses<P>(
    db_path: P,
    seed_name: &str,
    seed_phrase: &str,
    make_seed_keys: bool,
) -> Result<PrepData>
where
    P: AsRef<Path>,
{
    // Set of `(AddressKey, AddressDetails)` to be added into the database.
    // Set is updated and is used on each iteration of `create_address` to check
    // for collisions.
    let mut address_prep: Vec<(AddressKey, AddressDetails)> = Vec::new();

    // Set of associated `Event::IdentityAdded(_)` entries.
    // Gets updated after each successful `create_address` run.
    let mut history_prep: Vec<Event> = Vec::new();

    // Collect all networks known to Signer.
    // Note: networks with all `Encryption` variants are used here if they are
    // in the Signer database.
    let specs_set = get_all_networks(&db_path)?;

    for network_specs in specs_set.iter() {
        // Make seed keys if requested.
        // Seed keys **must** be possible to generate,
        // if a seed key has a collision with some other key, it is an error
        if make_seed_keys {
            let prep_data = create_address(
                &db_path,
                &address_prep,
                "",
                &network_specs.specs,
                seed_name,
                seed_phrase,
            )?;
            address_prep = prep_data.address_prep;
            history_prep.extend_from_slice(&prep_data.history_prep);
        }

        // make keys with default derivation if possible;
        // key with default derivation may collide with some other key,
        // this should not prevent generating a seed;
        if let Ok(prep_data) = create_address(
            &db_path,
            &address_prep,
            &network_specs.specs.path_id,
            &network_specs.specs,
            seed_name,
            seed_phrase,
        ) {
            address_prep = prep_data.address_prep;
            history_prep.extend_from_slice(&prep_data.history_prep);
        }
    }
    Ok(PrepData {
        address_prep,
        history_prep,
    })
}

/// Accept seed into Signer: add default addresses for a seed in the Signer
/// database.
///
/// Each network has a default derivation path, recorded in [`NetworkSpecs`]
/// field `path_id`, normally `path_id` is `//<network_name>`.
///
/// This function adds addresses with default derivation paths into the Signer
/// database. If the `make_seed_keys` flag is set to `true`, seed keys are also
/// added. History log is accordingly updated.
///
/// This function inputs secret seed phrase as `&str`. It is passed as `&str`
/// into `populate_addresses` and used there.
#[cfg(feature = "signer")]
pub fn try_create_seed<P>(
    seed_name: &str,
    seed_phrase: &str,
    make_seed_keys: bool,
    db_path: P,
) -> Result<()>
where
    P: AsRef<Path>,
{
    let mut events: Vec<Event> = vec![Event::SeedCreated {
        seed_created: seed_name.to_string(),
    }];

    let prep_data = populate_addresses(&db_path, seed_name, seed_phrase, make_seed_keys)?;
    events.extend_from_slice(&prep_data.history_prep);
    TrDbCold::new()
        .set_addresses(upd_id_batch(Batch::default(), prep_data.address_prep)) // add addresses just made in populate_addresses
        .set_history(events_to_batch(&db_path, events)?) // add corresponding history
        .apply(&db_path)
}

/// Remove address from the Signer database.
///
/// Address is determined by [`MultiSigner`] and [`NetworkSpecsKey`] of the
/// network.
///
/// Function removes network [`NetworkSpecsKey`] from `network_id` set in
/// [`AddressDetails`] associated with provided [`MultiSigner`]. If no networks
/// associated with [`AddressKey`] remain, i.e. `network_id` set becomes empty,
/// whole entry is removed.
#[cfg(feature = "signer")]
pub fn remove_key<P>(
    db_path: P,
    multisigner: &MultiSigner,
    network_specs_key: &NetworkSpecsKey,
) -> Result<()>
where
    P: AsRef<Path>,
{
    remove_keys_set(&db_path, &[multisigner.to_owned()], network_specs_key)
}

/// Remove a set of addresses within a single network from the Signer database.
///
/// Address is determined by [`MultiSigner`] and [`NetworkSpecsKey`] of the
/// network. Function inputs network `NetworkSpecsKey` and a set of
/// `MultiSigner` values for which the address within a network must be deleted.
///
/// `NetworkSpecsKey` of the network is removed from `network_id` set in
/// [`AddressDetails`] associated with each of the provided `MultiSigner`
/// values. If no networks associated with [`AddressKey`] remain, i.e.
/// `network_id` set becomes empty, whole associated entry is removed.
#[cfg(feature = "signer")]
pub fn remove_keys_set<P>(
    db_path: P,
    multiselect: &[MultiSigner],
    network_specs_key: &NetworkSpecsKey,
) -> Result<()>
where
    P: AsRef<Path>,
{
    let mut id_batch = Batch::default();
    let mut events: Vec<Event> = Vec::new();
    let network_specs = get_network_specs(&db_path, network_specs_key)?;
    for multisigner in multiselect.iter() {
        let public_key = multisigner_to_public(multisigner);
        let address_key = AddressKey::from_multisigner(multisigner);
        let mut address_details = get_address_details(&db_path, &address_key)?;
        let identity_history = IdentityHistory::get(
            &address_details.seed_name,
            &network_specs.specs.encryption,
            &public_key,
            &address_details.path,
            network_specs.specs.genesis_hash,
        );
        events.push(Event::IdentityRemoved { identity_history });
        address_details
            .network_id
            .retain(|id| id != network_specs_key);
        if address_details.network_id.is_empty() {
            id_batch.remove(address_key.key())
        } else {
            id_batch.insert(address_key.key(), address_details.encode())
        }
    }
    TrDbCold::new()
        .set_addresses(id_batch) // modify existing address entries
        .set_history(events_to_batch(&db_path, events)?) // add corresponding history
        .apply(&db_path)
}

/// Add a set of new derived addresses: N+1, N+2, etc into Signer database.
///
/// The number of the added addresses is set by `increment` input.
///
/// Input [`MultiSigner`] and [`NetworkSpecsKey`] determine the address, and the
/// associated [`AddressDetails`] are found in the database. The derivations are
/// based on the `path` from the `AddressDetails`.
///
/// If the database has addressed in given network with path that could be
/// interpreted as `<path>//<number>`, the first derivation of the increment set
/// is `<path>//<number>+1`. If no such addresses are existing in the database,
/// the first derivation of the increment set is `<path>//0`.
///
/// Further derivations of the increment set have number part increased by 1
/// until all requested derivations are generated.
///
/// Note: this is intended only for addresses not protected by the password
/// (i.e. having derivation path **without** `///<password>` part). If the
/// increment set is created on a passworded address, only public derivation
/// path part will be used for increment set generation.
///
/// This function inputs secret seed phrase as `&str`. It is passed as `&str`
/// into `create_address` and used there.
///
/// ## Example
///
/// User creates increment set of 3 on derivation `//user`. Resulting
/// derivations are:
///
/// - `//user`
/// - `//user//0`
/// - `//user//1`
/// - `//user//2`
///
/// User creates increment set of 2 on `//user` again, resulting derivations
/// are:
///
/// - `//user`
/// - `//user//0`
/// - `//user//1`
/// - `//user//2`
/// - `//user//3`
/// - `//user//4`
///
/// If the increment set of 2 is created on `//user//0`, resulting derivations
/// would be:
///
/// - `//user`
/// - `//user//0`
/// - `//user//0//0`
/// - `//user//0//1`
/// - `//user//1`
/// - `//user//2`
/// - `//user//3`
/// - `//user//4`
#[cfg(feature = "signer")]
pub fn create_increment_set<P>(
    increment: u32,
    multisigner: &MultiSigner,
    network_specs_key: &NetworkSpecsKey,
    seed_phrase: &str,
    db_path: P,
) -> Result<()>
where
    P: AsRef<Path>,
{
    let address_details =
        get_address_details(&db_path, &AddressKey::from_multisigner(multisigner))?;
    let existing_identities =
        addresses_set_seed_name_network(&db_path, &address_details.seed_name, network_specs_key)?;
    let mut last_index = 0;
    for (_, details) in existing_identities.iter() {
        if let Some(("", suffix)) = details.path.split_once(&address_details.path) {
            if let Some(could_be_number) = suffix.get(2..) {
                if let Ok(index) = could_be_number.parse::<u32>() {
                    last_index = std::cmp::max(index + 1, last_index);
                }
            }
        }
    }
    let network_specs = get_network_specs(&db_path, network_specs_key)?;
    let mut identity_adds: Vec<(AddressKey, AddressDetails)> = Vec::new();
    let mut current_events: Vec<Event> = Vec::new();
    for i in 0..increment {
        let path = address_details.path.to_string() + "//" + &(last_index + i).to_string();
        let prep_data = create_address(
            &db_path,
            &identity_adds,
            &path,
            &network_specs.specs,
            &address_details.seed_name,
            seed_phrase,
        )?;
        identity_adds = prep_data.address_prep;
        current_events.extend_from_slice(&prep_data.history_prep);
    }
    let id_batch = upd_id_batch(Batch::default(), identity_adds);
    TrDbCold::new()
        .set_addresses(id_batch) // add created addresses
        .set_history(events_to_batch(&db_path, current_events)?) // add corresponding history
        .apply(&db_path)
}

/// Check derivation format and determine if it has a password.
///
/// Invalid derivation produces an error. Valid derivation is checked for
/// password with regex.
///
// TODO regex and secrets, see `create_address` comments.
#[cfg(feature = "signer")]
pub fn is_passworded(path: &str) -> Result<bool> {
    let passworded = REG_PATH
        .captures(path)
        .map(|caps| caps.name("password").is_some())
        .ok_or_else(|| Error::InvalidDerivation(path.to_string()))?;

    Ok(passworded)
}

/// Proposed derivation status.
#[cfg(feature = "signer")]
pub enum DerivationCheck {
    /// Derivation has bad format, UI disables proceeding with address
    /// generation.
    BadFormat,

    /// Derivation has password (`///<password>` part).
    ///
    /// Dynamic check in the database for already existing address is disabled.
    Password,

    /// Derivation has no password.
    ///
    /// Dynamic check in the database for already existing address is enabled.
    ///
    /// Inner content reflects if the already existing address is found and its
    /// details.
    NoPassword(Option<(MultiSigner, AddressDetails)>),
}

/// Preliminary checks if the user-proposed derivation could be used to create
/// the address.
///
/// This function **does not** use secret phrase, and only searches the
/// [`AddressDetails`] from the database for already existing addresses with
/// same derivation path, in case there is no password in the proposed
/// derivation.
///
/// If the proposed derivation is passworded, no checking could be done without
/// using the seed phrase, and UI allows to proceed to try creating new address.
/// If address already exists, an error would appear on the next stage.
///
/// No checking for collisions is done here (i.e. no checking if the same
/// [`AddressKey`] will be produced for <secret phrase 1> + <derivation path 1>
/// as for already known <secret phrase 2> + <derivation path 2>), because seed
/// phrase is not known. If collision occurs, an error would appear on the next
/// stage.
///
/// Note that the only errors in this function could appear from database
/// malfunction when the database is being searched for the exact match, in case
/// of password-free valid derivation. Bad format of the derivation is **not**
/// an error, UI just does not allow to proceed.
#[cfg(feature = "signer")]
pub fn derivation_check<P>(
    seed_name: &str,
    path: &str,
    network_specs_key: &NetworkSpecsKey,
    db_path: P,
) -> Result<DerivationCheck>
where
    P: AsRef<Path>,
{
    match is_passworded(path) {
        // Proposed derivation has password, no checks could be made, proceed.
        Ok(true) => Ok(DerivationCheck::Password),

        // Proposed derivation has no password, checking the database for exact
        // coincidence.
        Ok(false) => {
            let mut found_exact = None;
            for (multisigner, address_details) in get_all_addresses(db_path)?.into_iter() {
                if (address_details.seed_name == seed_name) // seed name
                    && (address_details.path == path) // derivation path, cropped part without password
                    && (address_details.network_id.contains(network_specs_key)) // in this network
                    && (!address_details.has_pwd)
                // has no password to begin with
                {
                    found_exact = Some((multisigner, address_details));
                    break;
                }
            }
            Ok(DerivationCheck::NoPassword(found_exact))
        }

        // Proposed derivation is not suitable, UI would not allow to proceed.
        // Note that this is **not** an error.
        Err(_) => Ok(DerivationCheck::BadFormat),
    }
}

/// Separate derivation path with password into non-secret part and password.
///
/// Function is expected to deal **only** with derivations having a password
/// (i.e. with `///<password>` part of the derivation path). Password-free
/// derivations do not get to the point in `navigator` where this function is
/// called. Calling this function on password-free derivation is an error.
///
/// Function receives derivation path with secret password part, and outputs
/// hard and soft derivations part and secret password part of the derivation
/// path separately.
///
// TODO regex and secrets, see `create_address` comments.
#[cfg(feature = "signer")]
pub fn cut_path(path: &str) -> Result<(String, String)> {
    let caps = REG_PATH
        .captures(path)
        .ok_or_else(|| Error::InvalidDerivation(path.to_string()))?;
    let cropped_path = caps
        .name("path")
        .map(|a| a.as_str().to_string())
        .ok_or_else(|| Error::InvalidDerivation(path.to_string()))?;
    match caps.name("password") {
        Some(pwd) => Ok((cropped_path, pwd.as_str().to_string())),
        None => Err(Error::LostPwd),
    }
}

/// Create a new address in the Signer database.
///
/// If the associated [`AddressKey`] already exists in the [`ADDRTREE`] tree of
/// the Signer database, a new network [`NetworkSpecsKey`] is added into
/// `network_id` set of the `AddressDetails`. If the `AddressKey` is new,
/// a new `ADDRTREE` entry is made.
///
/// Secrets passed into this function are:
///
/// - seed phrase
/// - path, possibly with secret password part (`///<...>`).
///
/// Both are input as `&str` and go directly in `create_address` (both) and
/// `derivation_check` (path only).
#[cfg(feature = "signer")]
pub fn try_create_address<P>(
    seed_name: &str,
    seed_phrase: &str,
    path: &str,
    network_specs_key: &NetworkSpecsKey,
    db_path: P,
) -> Result<()>
where
    P: AsRef<Path>,
{
    match derivation_check(seed_name, path, network_specs_key, &db_path)? {
        // UI should prevent user from getting into `try_create_address` if
        // derivation has a bad format
        DerivationCheck::BadFormat => Err(Error::InvalidDerivation(path.to_string())),

        // UI should prevent user from getting into `try_create_address` if
        // derivation already exists
        DerivationCheck::NoPassword(Some((multisigner, address_details))) => {
            Err(Error::DerivationExists {
                multisigner,
                address_details,
                network_specs_key: network_specs_key.to_owned(),
            })
        }

        // Valid derivation:
        // - without a password and not in the database
        // - with password
        // Signer can try adding either. Collisions (for both cases) and exact
        // coincidence (for passworded derivation) could not have been checked
        // preliminarily and would result in `create_address` errors here.
        _ => {
            let network_specs = get_network_specs(&db_path, network_specs_key)?;
            let prep_data = create_address(
                &db_path,
                &Vec::new(), // a single address is created, no data to check against here
                path,
                &network_specs.specs,
                seed_name,
                seed_phrase,
            )?;
            let id_batch = upd_id_batch(Batch::default(), prep_data.address_prep);
            TrDbCold::new()
                .set_addresses(id_batch) // add created address
                .set_history(events_to_batch(&db_path, prep_data.history_prep)?) // add corresponding history
                .apply(&db_path)
        }
    }
}

/// Generate test Alice addresses in test cold database.
///
/// Function wipes [`ADDRTREE`] and adds:
///
/// - seed key, i.e. seed addresses for all 3 default networks (Polkadot,
/// Kusama, Westend)
/// - addresses with default derivation path in each default network
/// - address with `//Alice` derivation path in Westend network
#[cfg(feature = "active")]
pub fn generate_test_identities<P>(db_path: P) -> Result<()>
where
    P: AsRef<Path>,
{
    // clear the tree
    let entry_batch = make_batch_clear_tree(&db_path, ADDRTREE)?;

    // make a record that the tree was wiped
    let mut events = vec![Event::IdentitiesWiped];

    // data for adding seed addresses and addresses with default derivation path
    let prep_data = populate_addresses(&db_path, "Alice", ALICE_SEED_PHRASE, true)?;

    // Address preparation set, to be used as following `create_address` input.
    // Alice addresses are known and good, so checking them for collisions is
    // not really necessary. This is here just for the sake of completedness.
    let mut address_prep = prep_data.address_prep.to_vec();

    // update events
    events.extend_from_slice(&prep_data.history_prep);

    for network_specs in get_all_networks(&db_path)?.iter() {
        if (network_specs.specs.name == "westend")
            && (network_specs.specs.encryption == Encryption::Sr25519)
        {
            // data for adding address with `//Alice` derivation path in Westend
            // network
            let prep_data = create_address(
                &db_path,
                &address_prep, // address
                "//Alice",
                &network_specs.specs,
                "Alice",
                ALICE_SEED_PHRASE,
            )?;
            address_prep = prep_data.address_prep;
            events.extend_from_slice(&prep_data.history_prep);
        }
    }

    TrDbCold::new()
        .set_addresses(upd_id_batch(entry_batch, address_prep)) // add created addresses
        .set_history(events_to_batch(&db_path, events)?) // add corresponding history
        .apply(&db_path)
}

/// Remove all addresses associated with given seed name from the Signer
/// database.
///
/// Complementary action in frontend is removal of the seed data from the device
/// key management system.
#[cfg(feature = "signer")]
pub fn remove_seed<P>(db_path: P, seed_name: &str) -> Result<()>
where
    P: AsRef<Path>,
{
    // `Batch` to use
    let mut identity_batch = Batch::default();

    // All addresses with given seed name from the database
    let id_set = get_addresses_by_seed_name(&db_path, seed_name)?;
    if id_set.is_empty() {
        return Err(Error::NoKnownSeeds);
    }

    // Associated `Event` set
    let mut events = vec![Event::SeedRemoved {
        seed_name: seed_name.to_owned(),
    }];

    for (multisigner, address_details) in id_set.iter() {
        let address_key = AddressKey::from_multisigner(multisigner);

        // removal of all addresses corresponging to `AddressKey`
        identity_batch.remove(address_key.key());

        let public_key = multisigner_to_public(multisigner);
        for network_specs_key in address_details.network_id.iter() {
            let (genesis_hash_vec, _) = network_specs_key.genesis_hash_encryption()?;
            let identity_history = IdentityHistory::get(
                seed_name,
                &address_details.encryption,
                &public_key,
                &address_details.path,
                genesis_hash_vec,
            );
            // separate `Event` for each `NetworkSpecsKey` from `network_id` set
            events.push(Event::IdentityRemoved { identity_history });
        }
    }
    TrDbCold::new()
        .set_addresses(identity_batch) // modify addresses
        .set_history(events_to_batch(&db_path, events)?) // add corresponding history
        .apply(&db_path)
}

/// Check derivations before offering user to import them.
///
/// Signer allows bulk import only for valid derivations, with or without
/// password. For passworded derivations no password is ever confirmed, as the
/// user presumably has the derivations already recorded somewhere.
///
/// This function is used in `transaction_parsing::derivations` to check the
/// incoming derivations once they are received in `derivations` qr code
/// payload.
///
/// Note that once the derivations are checked, they are moved around as
/// "checked derivations" and not checked anymore until they are used in
/// `import_derivations`. Only checked derivations are written into the
/// database temporary storage in `TRANSACTION` tree, same data is recovered as
/// ensured by the checksum matching.
#[cfg(feature = "signer")]
pub fn check_derivation_set(derivations: &[String]) -> Result<()> {
    for path in derivations.iter() {
        if REG_PATH.captures(path).is_none() {
            return Err(Error::InvalidDerivation(path.to_string()));
        }
    }
    Ok(())
}

#[cfg(feature = "signer")]
fn prepare_secret_key_for_export(
    multisigner: &MultiSigner,
    full_address: &str,
    pwd: Option<&str>,
) -> Result<[u8; 32]> {
    match multisigner {
        MultiSigner::Ed25519(public) => {
            let ed25519_pair =
                ed25519::Pair::from_string(full_address, pwd).map_err(Error::SecretStringError)?;
            if public != &ed25519_pair.public() {
                return Err(Error::WrongPassword);
            }
            Ok(ed25519_pair.seed().to_owned())
        }
        MultiSigner::Sr25519(public) => {
            let (sr25519_pair, seed) = sr25519::Pair::from_string_with_seed(full_address, pwd)
                .map_err(Error::SecretStringError)?;
            if public != &sr25519_pair.public() {
                return Err(Error::WrongPassword);
            }
            Ok(seed.ok_or_else(|| Error::NoSeedForKeyPair {
                multisigner: multisigner.clone(),
            })?)
        }
        MultiSigner::Ecdsa(public) => {
            let ecdsa_pair =
                ecdsa::Pair::from_string(full_address, pwd).map_err(Error::SecretStringError)?;
            if public != &ecdsa_pair.public() {
                return Err(Error::WrongPassword);
            }
            Ok(ecdsa_pair.seed())
        }
    }
}

/// Prepare **secret** key export screen struct [`MKeyDetails`].
///
/// For QR code the secret key information is put in format
/// `secret:0x{}:{network genesis hash}` transformed into bytes, to be
/// compatible with `polkadot-js` interface.
///
/// There is no direct mentioning of [`Encryption`] in the QR code. It is
/// that user knows the key in which network and with what encryption they are
/// exporting.
///
/// The QR code here contains sensitive information, and is made with special
/// coloration, so that the difference with safe QR codes is immediately visible
/// on screen.
#[cfg(feature = "signer")]
pub fn export_secret_key<P>(
    db_path: P,
    public_key: &str,
    expected_seed_name: &str,
    network_specs_key_hex: &str,
    seed_phrase: &str,
    mut key_password: Option<String>,
) -> Result<MKeyDetails>
where
    P: AsRef<Path>,
{
    let public_key = &unhex(public_key)?;
    let network_specs_key = &NetworkSpecsKey::from_hex(network_specs_key_hex)?;
    let network_specs = get_network_specs(&db_path, network_specs_key)?;
    let multisigner = &get_multisigner(public_key, &network_specs.specs.encryption)?;
    let address_key = AddressKey::from_multisigner(multisigner);
    let address_details = get_address_details(&db_path, &address_key)?;
    if address_details.seed_name != expected_seed_name {
        return Err(Error::SeedNameNotMatching {
            address_key,
            expected_seed_name: expected_seed_name.to_string(),
            real_seed_name: address_details.seed_name,
        });
    }
    if !address_details.network_id.contains(network_specs_key) {
        return Err(Error::NetworkSpecsKeyForAddressNotFound {
            network_specs_key: network_specs_key.to_owned(),
            address_key,
        });
    }
    let public_key = multisigner_to_public(multisigner);

    let style = address_details.encryption.identicon_style();
    let address = Address {
        path: address_details.path.to_string(),
        has_pwd: address_details.has_pwd,
        identicon: make_identicon_from_multisigner(multisigner, style),
        seed_name: address_details.seed_name.to_string(),
        secret_exposed: true,
    };

    let network_info = MSCNetworkInfo {
        network_title: network_specs.specs.title,
        network_logo: network_specs.specs.logo,
        network_specs_key: network_specs_key_hex.to_owned(),
    };

    let database_addresses = get_addresses_by_seed_name(&db_path, expected_seed_name)?;

    let exposed_addresses = exposed_set(
        &address_details.path,
        address_details.has_pwd,
        database_addresses,
    );

    let mut identity_batch = Batch::default();

    for (x_multisigner, x_address_details) in exposed_addresses.into_iter() {
        let mut new_address_details = x_address_details;
        new_address_details.secret_exposed = true;
        identity_batch.insert(
            AddressKey::from_multisigner(&x_multisigner).key(),
            new_address_details.encode(),
        )
    }

    let history_batch = events_to_batch(
        &db_path,
        vec![Event::SecretWasExported {
            identity_history: IdentityHistory::get(
                &address_details.seed_name,
                &address_details.encryption,
                &public_key,
                &address_details.path,
                network_specs.specs.genesis_hash,
            ),
        }],
    )?;

    let qr = generate_secret_qr(
        multisigner,
        &address_details,
        &network_specs.specs.genesis_hash,
        seed_phrase,
        key_password.as_deref(),
    )?;
    key_password.zeroize();

    TrDbCold::new()
        .set_addresses(identity_batch) // modify addresses
        .set_history(history_batch) // add corresponding history
        .apply(&db_path)?;

    Ok(MKeyDetails {
        qr,
        pubkey: hex::encode(public_key),
        network_info,
        base58: print_multisigner_as_base58_or_eth(
            multisigner,
            Some(network_specs.specs.base58prefix),
            address_details.encryption,
        ),
        address,
    })
}

#[cfg(feature = "signer")]
fn generate_secret_qr(
    multisigner: &MultiSigner,
    address_details: &AddressDetails,
    genesis_hash: &H256,
    seed_phrase: &str,
    pwd: Option<&str>,
) -> Result<QrData> {
    // create fixed-length string to avoid reallocations

    let mut full_address = String::with_capacity(seed_phrase.len() + address_details.path.len());
    full_address.push_str(seed_phrase);
    full_address.push_str(&address_details.path);

    let mut secret = match prepare_secret_key_for_export(multisigner, &full_address, pwd) {
        Ok(a) => {
            full_address.zeroize();
            a
        }
        Err(e) => {
            full_address.zeroize();
            return Err(e);
        }
    };

    let qr = QrData::Sensitive {
        data: format!(
            "secret:0x{}:{}",
            hex::encode(secret),
            hex::encode(genesis_hash)
        )
        .as_bytes()
        .to_vec(),
    };
    secret.zeroize();
    Ok(qr)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn potentially_exposed() {
        assert!(is_potentially_exposed("//A//0", false, "//A", false));
        assert!(!is_potentially_exposed("//A//0", false, "//A", true));
        assert!(is_potentially_exposed("//A//0", true, "//A", false));
        assert!(!is_potentially_exposed("//A", false, "//A//0", false));
        assert!(is_potentially_exposed("//A//0", false, "//A//0", false));
        assert!(is_potentially_exposed("//A/0", false, "//A", false));
        assert!(is_potentially_exposed("//A//0//0", true, "//A", true));
        assert!(!is_potentially_exposed("//A//0", false, "//B", false));
    }
}
