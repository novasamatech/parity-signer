//! Creating, collecting, and removing addresses in cold database
//!
//! In Vault and Vault-related ecosystem the address is a key pair within a
//! certain network. Vault Rust database stores only **non-secret** data
//! associated with each address generated by user.
//!
//! Required data to generate address:
//!
//! - seed phrase (secret words set, must be always zeroized after use and is
//! never stored in Rust database)
//! - derivation path (`/soft//hard///password`); password part, i.e. whatever
//! follows `///` is not stored in Rust database and must be zeroized after use
//! - [`NetworkSpecsKey`](definitions::keyring::NetworkSpecsKey)
//!
//! The combination of seed phrase and derivation path allows to generate key
//! pair using the encryption algorithm supported by the network, for which the
//! address is generated.
//!
//! Vault stores only the public key, it is used together with encryption
//! algorithm [`Encryption`](definitions::crypto::Encryption) to generate
//! [`AddressKey`](definitions::keyring::AddressKey).
//!
//! Same `AddressKey` could correspond to more than one network if the addresses
//! were produced for same seed phrase and derivation path, and networks use
//! same encryption algorithm. The networks specs keys of associated networks
//! are stored in `network_id` field of `AddressDetails`.
//!
//! Vault interface shows those addresses as separate entities.
//!
//! Non-secret data associated with `AddressKey` is stored in
//! [`ADDRTREE`](constants::ADDRTREE) tree of the cold database as SCALE-encoded
//! [`AddressDetails`](definitions::users::AddressDetails).
use bip39::{Language, Mnemonic, MnemonicType};
use lazy_static::lazy_static;
use parity_scale_codec::Decode;
#[cfg(feature = "active")]
use parity_scale_codec::Encode;
use regex::Regex;
use sled::Batch;
use sp_core::H256;
#[cfg(feature = "active")]
use sp_core::{ecdsa, ed25519, sr25519, Pair};
use sp_runtime::MultiSignature;
#[cfg(feature = "active")]
use sp_runtime::MultiSigner;
use std::collections::HashMap;
#[cfg(feature = "active")]
use zeroize::Zeroize;

#[cfg(feature = "active")]
use constants::ADDRTREE;
#[cfg(feature = "active")]
use constants::ALICE_SEED_PHRASE;
use definitions::derivations::SeedKeysPreview;
use definitions::dynamic_derivations::{
    DynamicDerivationResponseInfo, DynamicDerivationsAddressRequestV1,
    DynamicDerivationsAddressResponse, DynamicDerivationsAddressResponseV1,
    DynamicDerivationsResponseInfo,
};
use definitions::helpers::base58_or_eth_to_multisigner;
use definitions::helpers::print_multisigner_as_base58_or_eth;
use definitions::helpers::{get_multisigner, unhex};
use definitions::navigation::{DDDetail, DDKeySet, DDPreview, ExportedSet};
use definitions::network_specs::NetworkSpecs;
#[cfg(feature = "active")]
use definitions::{
    crypto::Encryption,
    helpers::multisigner_to_public,
    history::{Event, IdentityHistory},
    keyring::{AddressKey, NetworkSpecsKey},
    users::AddressDetails,
};
use definitions::{
    helpers::make_identicon_from_multisigner,
    navigation::{Address, MKeyDetails, MSCNetworkInfo, QrData},
};
use qrcode_rtx::make_data_packs;

#[cfg(feature = "active")]
use crate::{
    db_transactions::TrDbCold,
    helpers::{get_all_networks, make_batch_clear_tree, open_tree, upd_id_batch},
    manage_history::events_to_batch,
};
use crate::{
    helpers::{get_address_details, get_network_specs},
    interface_signer::addresses_set_seed_name_network,
};
use crate::{Error, Result};

lazy_static! {
// stolen from sp_core
// removed seed phrase part
// last '+' used to be '*', but empty password is an error
    static ref REG_PATH: Regex = Regex::new(r"^(?P<path>(//?[^/]+)*)(///(?P<password>.+))?$").expect("known value");
}

#[derive(Clone, Encode, Decode)]
pub enum SignaturesBulk {
    #[codec(index = 4)]
    V1(SignaturesBulkV1),
}

impl From<SignaturesBulkV1> for SignaturesBulk {
    fn from(s: SignaturesBulkV1) -> Self {
        Self::V1(s)
    }
}

#[derive(Clone, Encode, Decode)]
pub struct SignaturesBulkV1 {
    /// Array of signatures.
    signatures: Vec<MultiSignature>,
}

impl From<&[MultiSignature]> for SignaturesBulkV1 {
    fn from(signatures: &[MultiSignature]) -> Self {
        Self {
            signatures: signatures.to_owned(),
        }
    }
}

#[derive(Clone, Encode, Decode)]
pub enum TransactionBulk {
    V1(TransactionBulkV1),
}

#[derive(Clone, Encode, Decode)]
pub struct TransactionBulkV1 {
    pub encoded_transactions: Vec<Vec<u8>>,
}

#[derive(Clone, Encode, Decode, Debug, Eq, PartialEq)]
pub enum ExportAddrs {
    V1(ExportAddrsV1),
    V2(ExportAddrsV2),
}

#[derive(Clone, Encode, Decode, Debug, Eq, PartialEq)]
pub struct ExportAddrsV1 {
    pub addrs: Vec<SeedInfo>,
}

#[derive(Clone, Encode, Decode, Debug, Eq, PartialEq)]
pub struct ExportAddrsV2 {
    pub addr: SeedInfo,
    features: Vec<VaultFeatures>,
}

impl ExportAddrsV2 {
    pub fn new(addr: SeedInfo) -> Self {
        Self {
            addr,
            features: vec![
                VaultFeatures::BulkOperations,
                VaultFeatures::DynamicDerivations,
            ],
        }
    }
}

impl From<ExportAddrsV2> for ExportAddrsV1 {
    fn from(val: ExportAddrsV2) -> Self {
        ExportAddrsV1 {
            addrs: vec![val.addr],
        }
    }
}

#[derive(Clone, Encode, Decode, Debug, Eq, PartialEq)]
pub enum VaultFeatures {
    BulkOperations,
    DynamicDerivations,
}

#[derive(Clone, Encode, Decode, Debug, Eq, PartialEq)]
pub struct SeedInfo {
    /// Name of the seed.
    pub name: String,

    /// Public key of the root key.
    pub multisigner: MultiSigner,

    /// Derived keys.
    pub derived_keys: Vec<AddrInfo>,
}

#[derive(Clone, Encode, Decode, Debug, Eq, PartialEq)]
pub struct AddrInfo {
    /// Address in the network.
    ///
    /// This is either `ss58` form for substrate-based chains or
    /// h160 form for ethereum based
    /// chains
    pub address: String,

    /// The derivation path of the key if user provided one
    pub derivation_path: Option<String>,

    /// The type of encryption in the network
    pub encryption: Encryption,

    /// Genesis hash
    pub genesis_hash: H256,
}

/// Export info about keys and their addresses known to Vault
pub fn export_key_set_addrs(
    database: &sled::Db,
    seed_name: &str,
    exported_set: ExportedSet,
) -> Result<ExportAddrs> {
    let keys = get_addresses_by_seed_name(database, seed_name)?;
    let root_multisigner = keys
        .iter()
        .find(|(_, a)| a.is_root())
        .map(|(m, _)| m.to_owned())
        .ok_or(Error::NoRootKeyForSeed(seed_name.to_owned()))?;

    let mut derived_keys = vec![];

    for key in keys {
        if key.1.is_root() {
            continue;
        }

        let mut selected = false;

        match &exported_set {
            ExportedSet::All => selected = true,
            ExportedSet::Selected {
                s: selected_derivations,
            } => {
                for selected_derivation in selected_derivations {
                    if let Some(id) = &key.1.network_id {
                        if selected_derivation.derivation == key.1.path
                            && selected_derivation.network_specs_key == hex::encode(id.key())
                        {
                            selected = true;
                            break;
                        }
                    }
                }
            }
        }

        if !selected {
            continue;
        }

        if let Some(id) = &key.1.network_id {
            let specs = get_network_specs(database, id)?;
            let address = print_multisigner_as_base58_or_eth(
                &key.0,
                Some(specs.specs.base58prefix),
                key.1.encryption,
            );
            derived_keys.push(AddrInfo {
                address: address.clone(),
                derivation_path: if key.1.path.is_empty() {
                    None
                } else {
                    Some(key.1.path.to_owned())
                },
                encryption: key.1.encryption,
                genesis_hash: specs.specs.genesis_hash,
            });
        }
    }

    Ok(ExportAddrs::V2(ExportAddrsV2::new(SeedInfo {
        name: seed_name.to_owned(),
        multisigner: root_multisigner,
        derived_keys,
    })))
}

pub fn import_all_addrs(
    database: &sled::Db,
    seed_derived_keys: Vec<SeedKeysPreview>,
) -> Result<()> {
    // Address preparation set, to be modified and used as `create_address`
    // input.
    let mut adds: Vec<(AddressKey, AddressDetails)> = vec![];

    // Associated `Event` set
    let mut events: Vec<Event> = vec![];

    for addr in &seed_derived_keys {
        for derived_key in &addr.derived_keys {
            let path = derived_key.derivation_path.clone().unwrap_or_default();
            let network_specs_key =
                NetworkSpecsKey::from_parts(&derived_key.genesis_hash, &derived_key.encryption);
            let network_specs = get_network_specs(database, &network_specs_key)?;
            match create_derivation_address(
                database,
                &adds, // a single address is created, no data to check against here
                &path,
                &network_specs.specs,
                &addr.name,
                &derived_key.address,
                derived_key
                    .has_pwd
                    .ok_or_else(|| Error::MissingPasswordInfo(path.to_owned()))?,
                false,
            ) {
                // success, updating address preparation set and `Event` set
                Ok(prep_data) => {
                    adds = prep_data.address_prep;
                    events.extend_from_slice(&prep_data.history_prep);
                }
                // exactly same address already exists, ignoring it
                Err(Error::DerivationExists { .. }) => (),

                // some other error, processed as a real error
                Err(e) => return Err(e),
            }
        }
    }
    TrDbCold::new()
        .set_addresses(upd_id_batch(Batch::default(), adds)) // modify addresses data
        .set_history(events_to_batch(database, events)?) // add corresponding history
        .apply(database)
}

/// Get public key from seed phrase and derivation path
fn full_address_to_multisigner(
    mut full_address: String,
    encryption: Encryption,
) -> Result<MultiSigner> {
    let multisigner_result = match encryption {
        Encryption::Ed25519 => match ed25519::Pair::from_string(&full_address, None) {
            Ok(a) => Ok(MultiSigner::Ed25519(a.public())),
            Err(e) => Err(Error::SecretStringError(e)),
        },
        Encryption::Sr25519 => match sr25519::Pair::from_string(&full_address, None) {
            Ok(a) => Ok(MultiSigner::Sr25519(a.public())),
            Err(e) => Err(Error::SecretStringError(e)),
        },
        Encryption::Ecdsa | Encryption::Ethereum => {
            match ecdsa::Pair::from_string(&full_address, None) {
                Ok(a) => Ok(MultiSigner::Ecdsa(a.public())),
                Err(e) => Err(Error::SecretStringError(e)),
            }
        }
    };
    full_address.zeroize();
    multisigner_result
}

/// Return seed name for the given key
fn find_seed_name_for_multisigner(
    database: &sled::Db,
    multisigner: &MultiSigner,
) -> Result<Option<String>> {
    Ok(get_all_addresses(database)?
        .into_iter()
        .find(|(m, _)| m == multisigner)
        .map(|(_, address_details)| address_details.seed_name))
}

pub fn process_dynamic_derivations_v1(
    database: &sled::Db,
    seeds: HashMap<String, String>,
    request: DynamicDerivationsAddressRequestV1,
) -> Result<DDPreview> {
    let mut is_some_already_imported = false;
    let mut is_some_network_missing = false;

    let mut new_addrs: Vec<(AddressKey, AddressDetails)> = vec![];
    let seed_request = &request.addr;
    let seed_name = find_seed_name_for_multisigner(database, &seed_request.multisigner)?
        .ok_or_else(|| Error::NoSeedForKeyPair {
            multisigner: seed_request.multisigner.clone(),
        })?;
    let seed_phrase = seeds
        .get(&seed_name)
        .ok_or_else(|| Error::NoSeedForKeyPair {
            multisigner: seed_request.multisigner.clone(),
        })?;
    let mut derivations = vec![];
    for derivation_request in &seed_request.dynamic_derivations {
        let network_specs_key = NetworkSpecsKey::from_parts(
            &derivation_request.genesis_hash,
            &derivation_request.encryption,
        );
        let network_specs = match get_network_specs(database, &network_specs_key) {
            Ok(s) => s,
            Err(_) => {
                is_some_network_missing = true;
                continue;
            }
        };
        let multisigner = match create_address(
            database,
            &new_addrs,
            &derivation_request.derivation_path,
            Some(&network_specs.specs),
            &seed_name,
            seed_phrase,
            true,
        ) {
            // success
            Ok(prep_data) => {
                new_addrs = prep_data.address_prep;
                new_addrs.last()
                    .expect("new_addrs is never empty")
                    .0
                    .multi_signer()}
            ,
            // exactly same address already exists, ignoring it
            Err(Error::DerivationExists { .. }) => {
                is_some_already_imported = true;
                continue;
            },

            // some other error, processed as a real error
            Err(e) => return Err(e),
        };
        let encryption = derivation_request.encryption;
        derivations.push(DDDetail {
            base58: print_multisigner_as_base58_or_eth(
                multisigner,
                Some(network_specs.specs.base58prefix),
                encryption,
            ),
            path: derivation_request.derivation_path.clone(),
            network_logo: network_specs.specs.logo,
            network_specs_key: hex::encode(network_specs_key.key()),
            identicon: make_identicon_from_multisigner(multisigner, encryption.identicon_style()),
        })
    }

    let key_set = DDKeySet {
        seed_name: seed_name.to_string(),
        derivations,
    };
    let qr = dynamic_derivations_response_qr(&request, seed_phrase)?;
    Ok(DDPreview {
        qr,
        key_set,
        is_some_already_imported,
        is_some_network_missing,
    })
}

/// Prepare QR frames with `DynamicDerivationsAddressResponse`
fn dynamic_derivations_response_qr(
    request: &DynamicDerivationsAddressRequestV1,
    seed_phrase: &str,
) -> Result<Vec<QrData>> {
    let response = dynamic_derivations_response(request, seed_phrase)?;
    let data = [&[0x53, 0xff, 0xdf], response.encode().as_slice()].concat();
    make_data_packs(&data, 128).map_err(|e| Error::DataPacking(e.to_string()))
}

/// Prepare `DynamicDerivationsAddressResponse` for the given request
pub fn dynamic_derivations_response(
    request: &DynamicDerivationsAddressRequestV1,
    seed_phrase: &str,
) -> Result<DynamicDerivationsAddressResponse> {
    let seed_request = &request.addr;
    let mut derivations = vec![];
    for derivation_request in &seed_request.dynamic_derivations {
        let path = derivation_request.derivation_path.as_str();
        // create fixed-length string to avoid reallocations
        let mut full_address = String::with_capacity(seed_phrase.len() + path.len());
        full_address.push_str(seed_phrase);
        full_address.push_str(path);

        derivations.push(DynamicDerivationResponseInfo {
            derivation_path: derivation_request.derivation_path.clone(),
            encryption: derivation_request.encryption,
            public_key: full_address_to_multisigner(full_address, derivation_request.encryption)?,
        });
    }
    let addr = DynamicDerivationsResponseInfo {
        multisigner: seed_request.multisigner.clone(),
        dynamic_derivations: derivations,
    };

    Ok(DynamicDerivationsAddressResponse::V1(
        DynamicDerivationsAddressResponseV1 { addr },
    ))
}

pub fn inject_derivations_has_pwd(
    mut seed_derived_keys: Vec<SeedKeysPreview>,
    seeds: HashMap<String, String>,
) -> Result<Vec<SeedKeysPreview>> {
    let mut sr25519_signers = HashMap::new();
    let mut ed25519_signers = HashMap::new();
    let mut ecdsa_signers = HashMap::new();

    for (k, v) in &seeds {
        let sr25519_public = sr25519::Pair::from_phrase(v, None).unwrap().0.public();
        let ed25519_public = ed25519::Pair::from_phrase(v, None).unwrap().0.public();
        let ecdsa_public = ecdsa::Pair::from_phrase(v, None).unwrap().0.public();
        sr25519_signers.insert(sr25519_public, k);
        ed25519_signers.insert(ed25519_public, k);
        ecdsa_signers.insert(ecdsa_public, k);
    }

    for addr in seed_derived_keys.iter_mut() {
        for derived_key in addr.derived_keys.iter_mut() {
            let path = derived_key.derivation_path.clone().unwrap_or_default();
            let seed_name = match addr.multisigner {
                MultiSigner::Sr25519(p) => sr25519_signers.get(&p),
                MultiSigner::Ed25519(p) => ed25519_signers.get(&p),
                MultiSigner::Ecdsa(p) => ecdsa_signers.get(&p),
            };

            let seed_name = if let Some(seed_name) = seed_name {
                seed_name
            } else {
                continue;
            };

            let seed_phrase = if let Some(seed_phrase) = seeds.get(seed_name.as_str()) {
                seed_phrase
            } else {
                continue;
            };

            // create fixed-length string to avoid reallocation
            let mut full_address = String::with_capacity(seed_phrase.len() + path.len());
            full_address.push_str(seed_phrase);
            full_address.push_str(&path);

            let multisigner_pwdless =
                full_address_to_multisigner(full_address, derived_key.encryption)?;
            let multisigner =
                base58_or_eth_to_multisigner(&derived_key.address, &derived_key.encryption)?;
            derived_key.has_pwd = Some(multisigner_pwdless != multisigner);
        }
    }
    Ok(seed_derived_keys)
}

/// Get all existing addresses from the database.
#[cfg(feature = "active")]
pub fn get_all_addresses(database: &sled::Db) -> Result<Vec<(MultiSigner, AddressDetails)>> {
    let identities = open_tree(database, ADDRTREE)?;
    let mut out: Vec<(MultiSigner, AddressDetails)> = Vec::new();
    for (address_key_vec, address_entry) in identities.iter().flatten() {
        let address_key = AddressKey::from_ivec(&address_key_vec)?;
        let (multisigner, address_details) =
            AddressDetails::process_entry_with_key_checked(&address_key, address_entry)?;
        out.push((multisigner, address_details));
    }
    Ok(out)
}

#[cfg(feature = "active")]
pub fn get_multisigner_by_address(
    database: &sled::Db,
    address: &AddressKey,
) -> Result<Option<MultiSigner>> {
    use definitions::helpers::ecdsa_public_to_eth_address;

    Ok(get_all_addresses(database)?.into_iter().find_map(|(m, a)| {
        // TODO: Keys in the system should have disambiguous addressing
        // the current state of events has to do with the fact
        // that some parts of UI may be addressing eth keys by
        // Ethereum addresses and other parts by public keys

        // First check if an etherum address is being requested
        if a.encryption == Encryption::Ethereum {
            if let MultiSigner::Ecdsa(ref public) = m {
                if let Ok(addr) = ecdsa_public_to_eth_address(public) {
                    if addr.as_ref() == address.key() {
                        return Some(m);
                    }
                }
            }
        }

        // TODO: for ecdsa address is not simply a public key
        // Do a general check after Ethereum-specific one
        if address.multi_signer() == &m {
            return Some(m);
        }
        None
    }))
}

/// Get all existing addresses for a given seed name from the database.
#[cfg(feature = "active")]
pub fn get_addresses_by_seed_name(
    database: &sled::Db,
    seed_name: &str,
) -> Result<Vec<(MultiSigner, AddressDetails)>> {
    Ok(get_all_addresses(database)?
        .into_iter()
        .filter(|(_, address_details)| address_details.seed_name == seed_name)
        .collect())
}

/// Generate random phrase with given number of words.
///
/// The output is a **secret seed phrase**.
///
/// Its zeroization and safe handling are delegated to hardware.
pub fn generate_random_phrase(words_number: u32) -> Result<String> {
    let mnemonic_type = MnemonicType::for_word_count(words_number as usize)?;
    let mnemonic = Mnemonic::new(mnemonic_type, Language::English);
    Ok(mnemonic.into_phrase())
}

/// Check that key with a given path should be marked as a progeny of a key with
/// exposed secret.
///
/// There could be false positives here, as the passwords are not stored
/// anywhere in Vault, therefore if there are two passwords, there is no way to
/// check if they are different.
///
/// <table>
///     <tr><th>current</th><th>mark current?</th><th>exposed in set</th></tr>
///     <tr><td><code>//Alice</code></td><td>-</td><td><code>//Ali</code></td></tr>
///     <tr><td><code>//Alice//1</code></td><td>+</td><td><code>//Alice</code></td></tr>
///     <tr><td><code>//Alice///&ltpassword&gt</code></td><td>+</td><td><code>//Alice</code></td></tr>
///     <tr><td><code>//Alice//1///&ltpassword&gt</code></td><td>+</td><td><code>//Alice</code></td></tr>
///     <tr><td><code>//Alice</code></td><td>-</td><td><code>//Alice///&ltpassword&gt</code></td></tr>
///     <tr><td><code>//Alice//1</code></td><td>-</td><td><code>//Alice///&ltpassword&gt</code></td></tr>
///     <tr><td><code>//Alice///&ltpassword1&gt</code></td><td>+</td><td><code>//Alice///&ltpassword0&gt</code></td></tr>
///     <tr><td><code>//Alice//1///&ltpassword1&gt</code></td><td>+</td><td><code>//Alice///&ltpassword0&gt</code></td></tr>
///
/// </table>
#[cfg(feature = "active")]
pub(crate) fn is_potentially_exposed(
    path: &str,
    path_is_passworded: bool,
    exposed_path: &str,
    exposed_is_passworded: bool,
) -> bool {
    if (path == exposed_path) || path.starts_with(&format!("{exposed_path}/")) {
        path_is_passworded || !exposed_is_passworded
    } else {
        false
    }
}

/// Check if given key should be marked as exposed because its parent was
/// exposed.
///
/// Input set is already filtered by seed name elsewhere.
#[cfg(feature = "active")]
fn has_parent_with_exposed_secret(
    new_cropped_path: &str,
    new_is_passworded: bool,
    seed_name: &str,
    database: &sled::Db,
) -> Result<bool> {
    Ok(get_addresses_by_seed_name(database, seed_name)?
        .iter()
        .any(|(_, address_details)| {
            address_details.secret_exposed
                && is_potentially_exposed(
                    new_cropped_path,
                    new_is_passworded,
                    &address_details.path,
                    address_details.has_pwd,
                )
        }))
}

/// Find all `(AddressKey, AddressDetails)` that must be marked as exposed
/// because current key gets exposed.
///
/// Input set is already filtered by the seed name elsewhere.
fn exposed_set(
    exposed_cropped_path: &str,
    exposed_is_passworded: bool,
    filtered_set: Vec<(MultiSigner, AddressDetails)>,
) -> Vec<(MultiSigner, AddressDetails)> {
    filtered_set
        .into_iter()
        .filter(|(_, address_details)| {
            is_potentially_exposed(
                &address_details.path,
                address_details.has_pwd,
                exposed_cropped_path,
                exposed_is_passworded,
            )
        })
        .collect()
}

/// Data associated with address generation
#[cfg(feature = "active")]
pub(crate) struct PrepData {
    /// information to be added into [`Batch`](sled::Batch) for [`ADDRTREE`]
    /// update
    pub(crate) address_prep: Vec<(AddressKey, AddressDetails)>,

    /// [`Event`] set, to be added into history log
    pub(crate) history_prep: Vec<Event>,
}

/// Prepare data for address generation using seed phrase, derivation path, and
/// network specs.
///
/// Function generates addresses individually, and checks the database to
/// avoid collisions and duplicates. However, sometimes within a single database
/// transaction multiple addresses are generated, and each new address must be
/// checked with already semi-prepared new addresses set, to avoid collisions,
/// duplicates and overwriting.
///
/// Therefore, function inputs a set of `(AddressKey, AddressDetails)` values
/// already processed in preparation for the current database transaction and if
/// corresponding `AddressKey` is already there, adds new `NetworkSpecsKey` into
/// `AddressDetails` field `network_id` instead of creating a new entry.
///
/// The output [`PrepData`] contains:
///
/// - `address_prep` set of `(AddressKey, AddressDetails)` values that
/// eventually will be transformed into [`Batch`](sled::Batch) to update the
/// `ADDRTREE` of the cold database
/// - output `Event` set that will be eventually added into `HISTORY` as a part
/// of single `Entry`(definitions::history::Entry)
///
/// Function creates only **one** address, and output `PrepData` **updates**
/// address preparation set received as input.
///
/// Function gets used both on Active side (when generating test cold database
/// with well-known addresses) and on Vault side (when real addresses are
/// actually created by the user).
///
/// Secrets passed into this function are:
///
/// - seed phrase
/// - path, possibly with secret password part (`///<...>`).
///
/// Both are input as `&str`. Seed phrase is combined with derivation path into
/// a string, a reference to which is sent into inner logic of
/// [`sp_core::crypto`]. Combined secret string is then zeroized here regardless
/// of the address generation success.
#[cfg(feature = "active")]
pub(crate) fn create_address(
    database: &sled::Db,
    input_batch_prep: &[(AddressKey, AddressDetails)],
    path: &str,
    network_specs: Option<&NetworkSpecs>,
    seed_name: &str,
    seed_phrase: &str,
    mark_as_imported: bool,
) -> Result<PrepData> {
    // Check that the seed phrase is not empty.
    // In upstream, empty seed phrase means default Alice seed phrase.
    if seed_phrase.is_empty() {
        return Err(Error::EmptySeed);
    }
    // create fixed-length string to avoid reallocations
    let mut full_address = String::with_capacity(seed_phrase.len() + path.len());
    full_address.push_str(seed_phrase);
    full_address.push_str(path);

    let encryption = network_specs
        .map(|ns| ns.encryption)
        .unwrap_or(Encryption::Sr25519);

    let multisigner = full_address_to_multisigner(full_address, encryption)?;

    // TODO regex elements may keep the line with password somewhere, how to
    // zeroize then? checked regex crate and it appears that only references are
    // moved around; need to double-check later;
    let (cropped_path, has_pwd) = match REG_PATH.captures(path) {
        Some(caps) => match caps.name("path") {
            Some(a) => (a.as_str(), caps.name("password").is_some()),
            None => ("", caps.name("password").is_some()),
        },
        None => ("", false),
    };

    do_create_address(
        database,
        input_batch_prep,
        cropped_path,
        network_specs,
        seed_name,
        multisigner,
        has_pwd,
        mark_as_imported,
    )
}

#[allow(clippy::too_many_arguments)]
pub(crate) fn create_derivation_address(
    database: &sled::Db,
    input_batch_prep: &[(AddressKey, AddressDetails)],
    path: &str,
    network_specs: &NetworkSpecs,
    seed_name: &str,
    ss58: &str,
    has_pwd: bool,
    mark_as_imported: bool,
) -> Result<PrepData> {
    let multisigner = base58_or_eth_to_multisigner(ss58, &network_specs.encryption)?;
    do_create_address(
        database,
        input_batch_prep,
        path,
        Some(network_specs),
        seed_name,
        multisigner,
        has_pwd,
        mark_as_imported,
    )
}

#[allow(clippy::too_many_arguments)]
fn do_create_address(
    database: &sled::Db,
    input_batch_prep: &[(AddressKey, AddressDetails)],
    cropped_path: &str,
    network_specs: Option<&NetworkSpecs>,
    seed_name: &str,
    multisigner: MultiSigner,
    has_pwd: bool,
    mark_as_imported: bool,
) -> Result<PrepData> {
    // Check that the seed name is not empty.
    if seed_name.is_empty() {
        return Err(Error::EmptySeedName);
    }
    let mut address_prep = input_batch_prep.to_vec();
    let mut history_prep = vec![];
    let mut address_key: Option<AddressKey> = None;
    let mut network_specs_key: Option<NetworkSpecsKey> = None;
    if let Some(network_specs) = network_specs {
        network_specs_key = Some(NetworkSpecsKey::from_parts(
            &network_specs.genesis_hash,
            &network_specs.encryption,
        ));

        let public_key = multisigner_to_public(&multisigner);
        address_key = Some(AddressKey::new(
            multisigner.clone(),
            Some(network_specs.genesis_hash),
        ));

        // prepare history log here
        let identity_history = IdentityHistory::get(
            seed_name,
            &network_specs.encryption,
            &public_key,
            cropped_path,
            network_specs.genesis_hash,
        );
        history_prep.push(Event::IdentityAdded { identity_history });
    }
    if address_key.is_none() {
        address_key = Some(AddressKey::new(multisigner.clone(), None))
    }

    // check if the same address key already participates in current database
    // transaction

    // number in `(AddressKey, AddressDetails)` set with same `AddressKey`, if
    // found
    let number_in_current = None;

    match number_in_current {
        // `AddressKey` already participates in transaction, just add
        // `NetworkSpecsKey` into corresponding `AddressDetails` `network_id`
        // set
        Some(i) => {
            let mod_entry = address_prep.remove(i);
            address_prep.push(mod_entry);
            Ok(PrepData {
                address_prep,
                history_prep,
            })
        }

        // `AddressKey` is not yet in the transaction
        None => {
            // The only way to create address with `secret_exposed` marker is if
            // the parent with exposed secret is in the database.
            //
            // If the address key already exists in the database, the
            // `secret_exposed` flag will not be changed by extending key to
            // another network.
            let secret_exposed =
                has_parent_with_exposed_secret(cropped_path, has_pwd, seed_name, database)?;

            // check if the `AddressKey` is already in the database
            let identities = open_tree(database, ADDRTREE)?;
            if let Some(address_key) = address_key {
                match identities.get(address_key.key()) {
                    // `AddressKey` is in the database
                    Ok(Some(address_entry)) => {
                        if let Some(network_specs_key) = network_specs_key {
                            let address_details = AddressDetails::from_entry_with_key_checked(
                                &address_key,
                                address_entry,
                            )?;

                            Err(Error::DerivationExists {
                                multisigner,
                                address_details: Box::new(address_details),
                                network_specs_key,
                            })
                        } else {
                            Ok(PrepData {
                                address_prep,
                                history_prep,
                            })
                        }
                    }

                    // `AddressKey` is not in the database either.
                    // Make altogether new entry.
                    Ok(None) => {
                        let address_details = AddressDetails {
                            seed_name: seed_name.to_string(),
                            path: cropped_path.to_string(),
                            has_pwd,
                            network_id: network_specs_key,
                            encryption: network_specs
                                .map(|ns| ns.encryption)
                                .unwrap_or(Encryption::Sr25519),
                            secret_exposed,
                            was_imported: mark_as_imported,
                        };
                        address_prep.push((address_key, address_details));
                        Ok(PrepData {
                            address_prep,
                            history_prep,
                        })
                    }

                    // database error
                    Err(e) => Err(e.into()),
                }
            } else {
                Ok(PrepData {
                    address_prep,
                    history_prep,
                })
            }
        }
    }
}

/// Prepare data for default addresses generation for a seed.
///
/// Each network has a default derivation path, recorded in [`NetworkSpecs`]
/// field `path_id`, normally `path_id` is `//<network_name>`.
///
/// This function prepares the generation of addresses with default derivation
/// paths for each of the available networks. Additionally, if the
/// `make_seed_keys` flag is set to `true` the function also prepares seed key
/// generation.
///
/// The output [`PrepData`] contains:
///
/// - `address_prep` set of `(AddressKey, AddressDetails)` values that
/// eventually will be transformed into [`Batch`](sled::Batch) to update the
/// `ADDRTREE` of the cold database
/// - output `Event` set that will be eventually added into `HISTORY` as a part
/// of single `Entry`(definitions::history::Entry)
///
/// All output `PrepData` elements are generated within this function.
/// It does not input addresses previously processed for the same transaction
/// and therefore does not check for collisions, so this function always goes
/// first, when there are no address additions planned yet.
///
/// This function inputs secret seed phrase as `&str`. It is passed as `&str`
/// into `create_address` and used there.
#[cfg(feature = "active")]
fn populate_addresses(
    database: &sled::Db,
    seed_name: &str,
    seed_phrase: &str,
    make_seed_keys: bool,
) -> Result<PrepData> {
    // Set of `(AddressKey, AddressDetails)` to be added into the database.
    // Set is updated and is used on each iteration of `create_address` to check
    // for collisions.
    let mut address_prep: Vec<(AddressKey, AddressDetails)> = Vec::new();

    // Set of associated `Event::IdentityAdded(_)` entries.
    // Gets updated after each successful `create_address` run.
    let mut history_prep: Vec<Event> = Vec::new();

    // Make seed keys if requested.
    // Seed keys **must** be possible to generate,
    // if a seed key has a collision with some other key, it is an error
    if make_seed_keys {
        let prep_data = create_address(
            database,
            &address_prep,
            "",
            None,
            seed_name,
            seed_phrase,
            false,
        )?;
        address_prep = prep_data.address_prep;
        history_prep.extend_from_slice(&prep_data.history_prep);
    }
    Ok(PrepData {
        address_prep,
        history_prep,
    })
}

/// Accept seed into Vault: add default addresses for a seed in the Vault
/// database.
///
/// Each network has a default derivation path, recorded in [`NetworkSpecs`]
/// field `path_id`, normally `path_id` is `//<network_name>`.
///
/// This function adds addresses with default derivation paths into the Vault
/// database. If the `make_seed_keys` flag is set to `true`, seed keys are also
/// added. History log is accordingly updated.
///
/// This function inputs secret seed phrase as `&str`. It is passed as `&str`
/// into `populate_addresses` and used there.
pub fn try_create_seed(
    database: &sled::Db,
    seed_name: &str,
    seed_phrase: &str,
    make_seed_keys: bool,
) -> Result<()> {
    let mut events: Vec<Event> = vec![Event::SeedCreated {
        seed_created: seed_name.to_string(),
    }];

    let prep_data = populate_addresses(database, seed_name, seed_phrase, make_seed_keys)?;
    events.extend_from_slice(&prep_data.history_prep);
    TrDbCold::new()
        .set_addresses(upd_id_batch(Batch::default(), prep_data.address_prep)) // add addresses just made in populate_addresses
        .set_history(events_to_batch(database, events)?) // add corresponding history
        .apply(database)
}

/// Creates seed into Vault: add default addresses for `derive_for_networks` in the Vault
///
/// Each network has a default derivation path, recorded in [`NetworkSpecs`]
/// field `path_id`, normally `path_id` is `//<network_name>`.
///
/// `derive_for_networks` is a list of network ids to derive addresses for.
pub fn create_key_set(
    database: &sled::Db,
    seed_name: &str,
    seed_phrase: &str,
    derive_for_networks: Vec<String>,
) -> Result<()> {
    let mut events: Vec<Event> = vec![Event::SeedCreated {
        seed_created: seed_name.to_string(),
    }];
    // create seed root key
    let mut prep_data = populate_addresses(database, seed_name, seed_phrase, true)?;

    for network_key in derive_for_networks {
        let network_spec_key = NetworkSpecsKey::from_hex(&network_key)?;
        let network = get_network_specs(database, &network_spec_key)?.specs;
        let new_prep = create_address(
            database,
            &prep_data.address_prep,
            &network.path_id,
            Some(&network),
            seed_name,
            seed_phrase,
            false,
        )?;
        prep_data
            .address_prep
            .extend_from_slice(&new_prep.address_prep);
        prep_data
            .history_prep
            .extend_from_slice(&new_prep.history_prep);
    }

    events.extend_from_slice(&prep_data.history_prep);
    TrDbCold::new()
        .set_addresses(upd_id_batch(Batch::default(), prep_data.address_prep)) // add addresses just made
        .set_history(events_to_batch(database, events)?) // add corresponding history
        .apply(database)
}

/// Remove address from the Vault database.
///
/// Address is determined by [`MultiSigner`] and [`NetworkSpecsKey`] of the
/// network.
///
/// Function removes network [`NetworkSpecsKey`] from `network_id` set in
/// [`AddressDetails`] associated with provided [`MultiSigner`]. If no networks
/// associated with [`AddressKey`] remain, i.e. `network_id` set becomes empty,
/// whole entry is removed.
pub fn remove_key(
    database: &sled::Db,
    multisigner: &MultiSigner,
    network_specs_key: &NetworkSpecsKey,
) -> Result<()> {
    remove_keys_set(database, &[multisigner.to_owned()], network_specs_key)
}

/// Remove a set of addresses within a single network from the Vault database.
///
/// Address is determined by [`MultiSigner`] and [`NetworkSpecsKey`] of the
/// network. Function inputs network `NetworkSpecsKey` and a set of
/// `MultiSigner` values for which the address within a network must be deleted.
///
/// `NetworkSpecsKey` of the network is removed from `network_id` set in
/// [`AddressDetails`] associated with each of the provided `MultiSigner`
/// values. If no networks associated with [`AddressKey`] remain, i.e.
/// `network_id` set becomes empty, whole associated entry is removed.
pub fn remove_keys_set(
    database: &sled::Db,
    multiselect: &[MultiSigner],
    network_specs_key: &NetworkSpecsKey,
) -> Result<()> {
    let mut id_batch = Batch::default();
    let mut events: Vec<Event> = Vec::new();
    let network_specs = get_network_specs(database, network_specs_key)?;
    for multisigner in multiselect.iter() {
        let public_key = multisigner_to_public(multisigner);
        let address_key =
            AddressKey::new(multisigner.clone(), Some(network_specs.specs.genesis_hash));
        let address_details = get_address_details(database, &address_key)?;
        let identity_history = IdentityHistory::get(
            &address_details.seed_name,
            &network_specs.specs.encryption,
            &public_key,
            &address_details.path,
            network_specs.specs.genesis_hash,
        );
        events.push(Event::IdentityRemoved { identity_history });
        if address_details.network_id.as_ref() == Some(network_specs_key) {
            id_batch.remove(address_key.key())
        } else {
            id_batch.insert(address_key.key(), address_details.encode())
        }
    }
    TrDbCold::new()
        .set_addresses(id_batch) // modify existing address entries
        .set_history(events_to_batch(database, events)?) // add corresponding history
        .apply(database)
}

/// Add a set of new derived addresses: N+1, N+2, etc into Vault database.
///
/// The number of the added addresses is set by `increment` input.
///
/// Input [`MultiSigner`] and [`NetworkSpecsKey`] determine the address, and the
/// associated [`AddressDetails`] are found in the database. The derivations are
/// based on the `path` from the `AddressDetails`.
///
/// If the database has addressed in given network with path that could be
/// interpreted as `<path>//<number>`, the first derivation of the increment set
/// is `<path>//<number>+1`. If no such addresses are existing in the database,
/// the first derivation of the increment set is `<path>//0`.
///
/// Further derivations of the increment set have number part increased by 1
/// until all requested derivations are generated.
///
/// Note: this is intended only for addresses not protected by the password
/// (i.e. having derivation path **without** `///<password>` part). If the
/// increment set is created on a passworded address, only public derivation
/// path part will be used for increment set generation.
///
/// This function inputs secret seed phrase as `&str`. It is passed as `&str`
/// into `create_address` and used there.
///
/// ## Example
///
/// User creates increment set of 3 on derivation `//user`. Resulting
/// derivations are:
///
/// - `//user`
/// - `//user//0`
/// - `//user//1`
/// - `//user//2`
///
/// User creates increment set of 2 on `//user` again, resulting derivations
/// are:
///
/// - `//user`
/// - `//user//0`
/// - `//user//1`
/// - `//user//2`
/// - `//user//3`
/// - `//user//4`
///
/// If the increment set of 2 is created on `//user//0`, resulting derivations
/// would be:
///
/// - `//user`
/// - `//user//0`
/// - `//user//0//0`
/// - `//user//0//1`
/// - `//user//1`
/// - `//user//2`
/// - `//user//3`
/// - `//user//4`
pub fn create_increment_set(
    database: &sled::Db,
    increment: u32,
    multisigner: &MultiSigner,
    network_specs_key: &NetworkSpecsKey,
    seed_phrase: &str,
) -> Result<()> {
    let network_specs = get_network_specs(database, network_specs_key)?;
    let address_details = get_address_details(
        database,
        &AddressKey::new(multisigner.clone(), Some(network_specs.specs.genesis_hash)),
    )?;

    let existing_identities =
        addresses_set_seed_name_network(database, &address_details.seed_name, network_specs_key)?;
    let mut last_index = 0;
    for (_, details) in existing_identities.iter() {
        if let Some(("", suffix)) = details.path.split_once(&address_details.path) {
            if let Some(could_be_number) = suffix.get(2..) {
                if let Ok(index) = could_be_number.parse::<u32>() {
                    last_index = std::cmp::max(index + 1, last_index);
                }
            }
        }
    }
    let mut identity_adds: Vec<(AddressKey, AddressDetails)> = Vec::new();
    let mut current_events: Vec<Event> = Vec::new();
    for i in 0..increment {
        let path = address_details.path.to_string() + "//" + &(last_index + i).to_string();
        let prep_data = create_address(
            database,
            &identity_adds,
            &path,
            Some(&network_specs.specs),
            &address_details.seed_name,
            seed_phrase,
            false,
        )?;
        identity_adds = prep_data.address_prep;
        current_events.extend_from_slice(&prep_data.history_prep);
    }
    let id_batch = upd_id_batch(Batch::default(), identity_adds);
    TrDbCold::new()
        .set_addresses(id_batch) // add created addresses
        .set_history(events_to_batch(database, current_events)?) // add corresponding history
        .apply(database)
}

/// Check derivation format and determine if it has a password.
///
/// Invalid derivation produces an error. Valid derivation is checked for
/// password with regex.
///
// TODO regex and secrets, see `create_address` comments.
pub fn is_passworded(path: &str) -> Result<bool> {
    let passworded = REG_PATH
        .captures(path)
        .map(|caps| caps.name("password").is_some())
        .ok_or_else(|| Error::InvalidDerivation(path.to_string()))?;

    Ok(passworded)
}

/// Proposed derivation status.
pub enum DerivationCheck {
    /// Derivation has bad format, UI disables proceeding with address
    /// generation.
    BadFormat,

    /// Derivation has password (`///<password>` part).
    ///
    /// Dynamic check in the database for already existing address is disabled.
    Password,

    /// Derivation has no password.
    ///
    /// Dynamic check in the database for already existing address is enabled.
    ///
    /// Inner content reflects if the already existing address is found and its
    /// details.
    NoPassword(Option<(MultiSigner, AddressDetails)>),
}

/// Preliminary checks if the user-proposed derivation could be used to create
/// the address.
///
/// This function **does not** use secret phrase, and only searches the
/// [`AddressDetails`] from the database for already existing addresses with
/// same derivation path, in case there is no password in the proposed
/// derivation.
///
/// If the proposed derivation is passworded, no checking could be done without
/// using the seed phrase, and UI allows to proceed to try creating new address.
/// If address already exists, an error would appear on the next stage.
///
/// No checking for collisions is done here (i.e. no checking if the same
/// [`AddressKey`] will be produced for <secret phrase 1> + <derivation path 1>
/// as for already known <secret phrase 2> + <derivation path 2>), because seed
/// phrase is not known. If collision occurs, an error would appear on the next
/// stage.
///
/// Note that the only errors in this function could appear from database
/// malfunction when the database is being searched for the exact match, in case
/// of password-free valid derivation. Bad format of the derivation is **not**
/// an error, UI just does not allow to proceed.
pub fn derivation_check(
    database: &sled::Db,
    seed_name: &str,
    path: &str,
    network_specs_key: &NetworkSpecsKey,
) -> Result<DerivationCheck> {
    match is_passworded(path) {
        // Proposed derivation has password, no checks could be made, proceed.
        Ok(true) => Ok(DerivationCheck::Password),

        // Proposed derivation has no password, checking the database for exact
        // coincidence.
        Ok(false) => {
            let mut found_exact = None;
            for (multisigner, address_details) in get_all_addresses(database)?.into_iter() {
                if (address_details.seed_name == seed_name) // seed name
                    && (address_details.path == path) // derivation path, cropped part without password
                    && (address_details.network_id.as_ref() == Some(network_specs_key)) // in this network
                    && (!address_details.has_pwd)
                // has no password to begin with
                {
                    found_exact = Some((multisigner, address_details));
                    break;
                }
            }
            Ok(DerivationCheck::NoPassword(found_exact))
        }

        // Proposed derivation is not suitable, UI would not allow to proceed.
        // Note that this is **not** an error.
        Err(_) => Ok(DerivationCheck::BadFormat),
    }
}

/// Separate derivation path with password into non-secret part and password.
///
/// Function is expected to deal **only** with derivations having a password
/// (i.e. with `///<password>` part of the derivation path). Password-free
/// derivations do not get to the point in `navigator` where this function is
/// called. Calling this function on password-free derivation is an error.
///
/// Function receives derivation path with secret password part, and outputs
/// hard and soft derivations part and secret password part of the derivation
/// path separately.
///
// TODO regex and secrets, see `create_address` comments.
pub fn cut_path(path: &str) -> Result<(String, String)> {
    let caps = REG_PATH
        .captures(path)
        .ok_or_else(|| Error::InvalidDerivation(path.to_string()))?;
    let cropped_path = caps
        .name("path")
        .map(|a| a.as_str().to_string())
        .ok_or_else(|| Error::InvalidDerivation(path.to_string()))?;
    match caps.name("password") {
        Some(pwd) => Ok((cropped_path, pwd.as_str().to_string())),
        None => Err(Error::LostPwd),
    }
}

/// Create a new address in the Vault database.
///
/// If the associated [`AddressKey`] already exists in the [`ADDRTREE`] tree of
/// the Vault database, a new network [`NetworkSpecsKey`] is added into
/// `network_id` set of the `AddressDetails`. If the `AddressKey` is new,
/// a new `ADDRTREE` entry is made.
///
/// Secrets passed into this function are:
///
/// - seed phrase
/// - path, possibly with secret password part (`///<...>`).
///
/// Both are input as `&str` and go directly in `create_address` (both) and
/// `derivation_check` (path only).
pub fn try_create_address(
    database: &sled::Db,
    seed_name: &str,
    seed_phrase: &str,
    path: &str,
    network_specs_key: &NetworkSpecsKey,
) -> Result<()> {
    do_try_create_address(
        database,
        seed_name,
        seed_phrase,
        path,
        network_specs_key,
        false,
    )
}

/// Create a new address in the Vault database and mark it as imported.
pub fn try_create_imported_address(
    database: &sled::Db,
    seed_name: &str,
    seed_phrase: &str,
    path: &str,
    network_specs_key: &NetworkSpecsKey,
) -> Result<()> {
    do_try_create_address(
        database,
        seed_name,
        seed_phrase,
        path,
        network_specs_key,
        true,
    )
}

fn do_try_create_address(
    database: &sled::Db,
    seed_name: &str,
    seed_phrase: &str,
    path: &str,
    network_specs_key: &NetworkSpecsKey,
    mark_as_imported: bool,
) -> Result<()> {
    match derivation_check(database, seed_name, path, network_specs_key)? {
        // UI should prevent user from getting into `try_create_address` if
        // derivation has a bad format
        DerivationCheck::BadFormat => Err(Error::InvalidDerivation(path.to_string())),

        // UI should prevent user from getting into `try_create_address` if
        // derivation already exists
        DerivationCheck::NoPassword(Some((multisigner, address_details))) => {
            Err(Error::DerivationExists {
                multisigner,
                address_details: Box::new(address_details),
                network_specs_key: network_specs_key.to_owned(),
            })
        }

        // Valid derivation:
        // - without a password and not in the database
        // - with password
        // Vault can try adding either. Collisions (for both cases) and exact
        // coincidence (for passworded derivation) could not have been checked
        // preliminarily and would result in `create_address` errors here.
        _ => {
            let network_specs = get_network_specs(database, network_specs_key)?;
            let prep_data = create_address(
                database,
                &Vec::new(), // a single address is created, no data to check against here
                path,
                Some(&network_specs.specs),
                seed_name,
                seed_phrase,
                mark_as_imported,
            )?;
            let id_batch = upd_id_batch(Batch::default(), prep_data.address_prep);
            TrDbCold::new()
                .set_addresses(id_batch) // add created address
                .set_history(events_to_batch(database, prep_data.history_prep)?) // add corresponding history
                .apply(database)
        }
    }
}

/// Generate test Alice addresses in test cold database.
///
/// Function wipes [`ADDRTREE`] and adds:
///
/// - seed key, i.e. seed addresses for all 3 default networks (Polkadot,
/// Kusama, Westend)
/// - addresses with default derivation path in each default network
/// - address with `//Alice` derivation path in Westend network
#[cfg(feature = "active")]
pub fn generate_test_identities(database: &sled::Db) -> Result<()> {
    // clear the tree
    let entry_batch = make_batch_clear_tree(database, ADDRTREE)?;

    // make a record that the tree was wiped
    let mut events = vec![Event::IdentitiesWiped];

    // data for adding seed addresses and addresses with default derivation path
    let prep_data = populate_addresses(database, "Alice", ALICE_SEED_PHRASE, true)?;

    // Address preparation set, to be used as following `create_address` input.
    // Alice addresses are known and good, so checking them for collisions is
    // not really necessary. This is here just for the sake of completedness.
    let mut address_prep = prep_data.address_prep.to_vec();

    // update events
    events.extend_from_slice(&prep_data.history_prep);

    for network_specs in get_all_networks(database)?.iter() {
        if (network_specs.specs.name == "westend")
            && (network_specs.specs.encryption == Encryption::Sr25519)
        {
            // data for adding address with `//Alice` derivation path in Westend
            // network
            let prep_data = create_address(
                database,
                &address_prep, // address
                "//Alice",
                Some(&network_specs.specs),
                "Alice",
                ALICE_SEED_PHRASE,
                false,
            )?;
            address_prep = prep_data.address_prep;
            events.extend_from_slice(&prep_data.history_prep);
        }
    }

    TrDbCold::new()
        .set_addresses(upd_id_batch(entry_batch, address_prep)) // add created addresses
        .set_history(events_to_batch(database, events)?) // add corresponding history
        .apply(database)
}

/// Remove all addresses associated with given seed name from the Vault
/// database.
///
/// Complementary action in frontend is removal of the seed data from the device
/// key management system.
pub fn remove_seed(database: &sled::Db, seed_name: &str) -> Result<()> {
    // `Batch` to use
    let mut identity_batch = Batch::default();

    // All addresses with given seed name from the database
    let id_set = get_addresses_by_seed_name(database, seed_name)?;
    if id_set.is_empty() {
        return Err(Error::NoKnownSeeds);
    }

    // Associated `Event` set
    let mut events = vec![Event::SeedRemoved {
        seed_name: seed_name.to_owned(),
    }];

    for (multisigner, address_details) in id_set.iter() {
        if let Some(id) = &address_details.network_id {
            let network_specs = get_network_specs(database, id)?;
            let address_key =
                AddressKey::new(multisigner.clone(), Some(network_specs.specs.genesis_hash));

            // removal of all addresses corresponging to `AddressKey`
            identity_batch.remove(address_key.key());

            let public_key = multisigner_to_public(multisigner);
            let (genesis_hash_vec, _) = id.genesis_hash_encryption()?;
            let identity_history = IdentityHistory::get(
                seed_name,
                &address_details.encryption,
                &public_key,
                &address_details.path,
                genesis_hash_vec,
            );
            // separate `Event` for each `NetworkSpecsKey` from `network_id` set
            events.push(Event::IdentityRemoved { identity_history });
        } else {
            let address_key = AddressKey::new(multisigner.clone(), None);
            identity_batch.remove(address_key.key());
        }
    }
    TrDbCold::new()
        .set_addresses(identity_batch) // modify addresses
        .set_history(events_to_batch(database, events)?) // add corresponding history
        .apply(database)
}

/// Check derivations before offering user to import them.
///
/// Vault allows bulk import only for valid derivations, with or without
/// password. For passworded derivations no password is ever confirmed, as the
/// user presumably has the derivations already recorded somewhere.
///
/// This function is used in `transaction_parsing::derivations` to check the
/// incoming derivations once they are received in `derivations` qr code
/// payload.
///
/// Note that once the derivations are checked, they are moved around as
/// "checked derivations" and not checked anymore until they are used in
/// `import_derivations`. Only checked derivations are written into the
/// database temporary storage in `TRANSACTION` tree, same data is recovered as
/// ensured by the checksum matching.
pub fn check_derivation_set(derivations: &[String]) -> Result<()> {
    for path in derivations.iter() {
        if REG_PATH.captures(path).is_none() {
            return Err(Error::InvalidDerivation(path.to_string()));
        }
    }
    Ok(())
}

fn prepare_secret_key_for_export(
    multisigner: &MultiSigner,
    full_address: &str,
    pwd: Option<&str>,
) -> Result<[u8; 32]> {
    match multisigner {
        MultiSigner::Ed25519(public) => {
            let ed25519_pair =
                ed25519::Pair::from_string(full_address, pwd).map_err(Error::SecretStringError)?;
            if public != &ed25519_pair.public() {
                return Err(Error::WrongPassword);
            }
            Ok(ed25519_pair.seed().to_owned())
        }
        MultiSigner::Sr25519(public) => {
            let (sr25519_pair, seed) = sr25519::Pair::from_string_with_seed(full_address, pwd)
                .map_err(Error::SecretStringError)?;
            if public != &sr25519_pair.public() {
                return Err(Error::WrongPassword);
            }
            Ok(seed.ok_or_else(|| Error::NoSeedForKeyPair {
                multisigner: multisigner.clone(),
            })?)
        }
        MultiSigner::Ecdsa(public) => {
            let ecdsa_pair =
                ecdsa::Pair::from_string(full_address, pwd).map_err(Error::SecretStringError)?;
            if public != &ecdsa_pair.public() {
                return Err(Error::WrongPassword);
            }
            Ok(ecdsa_pair.seed())
        }
    }
}

/// Prepare **secret** key export screen struct [`MKeyDetails`].
///
/// For QR code the secret key information is put in format
/// `secret:0x{}:{network genesis hash}` transformed into bytes, to be
/// compatible with `polkadot-js` interface.
///
/// There is no direct mentioning of [`Encryption`] in the QR code. It is
/// that user knows the key in which network and with what encryption they are
/// exporting.
///
/// The QR code here contains sensitive information, and is made with special
/// coloration, so that the difference with safe QR codes is immediately visible
/// on screen.
pub fn export_secret_key(
    database: &sled::Db,
    public_key: &str,
    expected_seed_name: &str,
    network_specs_key_hex: &str,
    seed_phrase: &str,
    mut key_password: Option<String>,
) -> Result<MKeyDetails> {
    let public_key = &unhex(public_key)?;
    let network_specs_key = &NetworkSpecsKey::from_hex(network_specs_key_hex)?;
    let network_specs = get_network_specs(database, network_specs_key)?;
    let multisigner = &get_multisigner(public_key, &network_specs.specs.encryption)?;
    let address_key = AddressKey::new(multisigner.clone(), Some(network_specs.specs.genesis_hash));
    let address_details = get_address_details(database, &address_key)?;
    if address_details.seed_name != expected_seed_name {
        return Err(Error::SeedNameNotMatching {
            address_key,
            expected_seed_name: expected_seed_name.to_string(),
            real_seed_name: address_details.seed_name,
        });
    }
    if address_details.network_id.as_ref() != Some(network_specs_key) {
        return Err(Error::NetworkSpecsKeyForAddressNotFound {
            network_specs_key: network_specs_key.to_owned(),
            address_key,
        });
    }
    let public_key = multisigner_to_public(multisigner);

    let style = address_details.encryption.identicon_style();
    let address = Address {
        path: address_details.path.to_string(),
        has_pwd: address_details.has_pwd,
        identicon: make_identicon_from_multisigner(multisigner, style),
        seed_name: address_details.seed_name.to_string(),
        secret_exposed: true,
    };

    let network_info = MSCNetworkInfo {
        network_title: network_specs.specs.name,
        network_logo: network_specs.specs.logo,
        network_specs_key: network_specs_key_hex.to_owned(),
    };

    let database_addresses = get_addresses_by_seed_name(database, expected_seed_name)?;

    let exposed_addresses = exposed_set(
        &address_details.path,
        address_details.has_pwd,
        database_addresses,
    );

    let mut identity_batch = Batch::default();

    for (x_multisigner, x_address_details) in exposed_addresses.into_iter() {
        let mut new_address_details = x_address_details;
        new_address_details.secret_exposed = true;
        if let Some(id) = &new_address_details.network_id {
            let network_specs = get_network_specs(database, id)?;
            identity_batch.insert(
                AddressKey::new(
                    x_multisigner.clone(),
                    Some(network_specs.specs.genesis_hash),
                )
                .key(),
                new_address_details.encode(),
            )
        }
    }

    let history_batch = events_to_batch(
        database,
        vec![Event::SecretWasExported {
            identity_history: IdentityHistory::get(
                &address_details.seed_name,
                &address_details.encryption,
                &public_key,
                &address_details.path,
                network_specs.specs.genesis_hash,
            ),
        }],
    )?;

    let qr = generate_secret_qr(
        multisigner,
        &address_details,
        &network_specs.specs.genesis_hash,
        seed_phrase,
        key_password.as_deref(),
    )?;
    key_password.zeroize();

    TrDbCold::new()
        .set_addresses(identity_batch) // modify addresses
        .set_history(history_batch) // add corresponding history
        .apply(database)?;

    Ok(MKeyDetails {
        qr,
        pubkey: hex::encode(public_key),
        network_info,
        base58: print_multisigner_as_base58_or_eth(
            multisigner,
            Some(network_specs.specs.base58prefix),
            address_details.encryption,
        ),
        address,
        was_imported: address_details.was_imported,
    })
}

fn generate_secret_qr(
    multisigner: &MultiSigner,
    address_details: &AddressDetails,
    genesis_hash: &H256,
    seed_phrase: &str,
    pwd: Option<&str>,
) -> Result<QrData> {
    // create fixed-length string to avoid reallocations

    let mut full_address = String::with_capacity(seed_phrase.len() + address_details.path.len());
    full_address.push_str(seed_phrase);
    full_address.push_str(&address_details.path);

    let mut secret = match prepare_secret_key_for_export(multisigner, &full_address, pwd) {
        Ok(a) => {
            full_address.zeroize();
            a
        }
        Err(e) => {
            full_address.zeroize();
            return Err(e);
        }
    };

    let qr = QrData::Sensitive {
        data: format!(
            "secret:0x{}:{}",
            hex::encode(secret),
            hex::encode(genesis_hash)
        )
        .as_bytes()
        .to_vec(),
    };
    secret.zeroize();
    Ok(qr)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn potentially_exposed() {
        assert!(is_potentially_exposed("//A//0", false, "//A", false));
        assert!(!is_potentially_exposed("//A//0", false, "//A", true));
        assert!(is_potentially_exposed("//A//0", true, "//A", false));
        assert!(!is_potentially_exposed("//A", false, "//A//0", false));
        assert!(is_potentially_exposed("//A//0", false, "//A//0", false));
        assert!(is_potentially_exposed("//A/0", false, "//A", false));
        assert!(is_potentially_exposed("//A//0//0", true, "//A", true));
        assert!(!is_potentially_exposed("//A//0", false, "//B", false));
    }
}
