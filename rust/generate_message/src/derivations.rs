//! Derivations import
//!
//! Signer can import sets of derivations by accepting updates with `0x53ffde`
//! prelude and
//! [`ContentDerivations`](definitions::qr_transfers::ContentDerivations)
//! content.
//!
//! Derivations imports are always unsigned, and are presumably prepared
//! by users themselves, to avoid manual input of numerous derivations.
//!
//! It is expected that user has network-specific derivations, and therefore,
//! derivations import is prepared for a certain network.
//!
//! Derivations import content is generated by [`prepare_derivations_import`]
//! that needs network-associated encryption algorithm, network genesis hash,
//! and plain text input of derivations with each valid derivation on its own
//! line.
//!
//! Example command line to generate derivations import QR:
//!
//! `$ cargo run derivations -qr -title westend-sr25519 -payload
//! my_westend_set.txt`
use db_handling::identities::prepare_derivations_import;
use qrcode_rtx::make_pretty_qr;

use crate::error::{Error, Result};
use crate::helpers::get_address_book_entry;
use crate::parser::{Derivations, Goal};

/// Generate derivations import QR code and/or text file
///
/// Function inputs [`Derivations`] and, in case of success, as `goal` field in
/// [`Derivations`] suggests, outputs QR code and/or text file with hex-encoded
/// derivations import data in `/generate_message/` folder.
///
/// Derivations import could be generated only for networks known to the hot
/// database. In command line user indicates the network by its address book
/// title, for example `westend-sr25519` or `westend-ed25519`. It goes into
/// `title` field of [`Derivations`], and is processed to get network encryption
/// and genesis hash.
pub fn process_derivations(x: Derivations) -> Result<()> {
    // get network information from the database, by network address book title
    let address_book_entry = get_address_book_entry(&x.title, x.db)?;

    // prepare `ContentDerivations`
    let content = prepare_derivations_import(
        &address_book_entry.encryption,
        address_book_entry.genesis_hash,
        &x.derivations,
    )?;

    // prelude, always identical
    let prelude = hex::decode("53ffde").expect("known static value");

    // complete update content
    let complete_message = [prelude, content.to_transfer()].concat();

    // output file name in `/generate_message/` folder
    let output_name = format!("derivations-{}", x.title);
    match x.goal {
        Goal::Qr => make_pretty_qr(&complete_message, &output_name).map_err(Error::Qr)?,
        Goal::Text => std::fs::write(
            &format!("{}.txt", output_name),
            &hex::encode(&complete_message),
        )?,
        Goal::Both => {
            std::fs::write(
                &format!("{}.txt", output_name),
                &hex::encode(&complete_message),
            )?;
            make_pretty_qr(&complete_message, &output_name).map_err(Error::Qr)?
        }
    }
    Ok(())
}
