//! `derivations` update, for bulk password-free derivations import
//!
//! Signer can import sets of password-free derivations by accepting updates
//! with `0x53ffde` prelude and
//! [`ContentDerivations`](definitions::qr_transfers::ContentDerivations)
//! content.
//!
//! Derivation import updates are always unsigned, and are presumably prepared
//! by users themselves, to avoid manual input of numerous derivations.
//!
//! It is expected that user has network-specific derivations, and therefore,
//! `derivations` update is prepared for a certain network.
//!
//! Update content is generated by
//! [`prepare_derivations_export`](db_handling::identities::prepare_derivations_export)
//! that needs network-associated encryption algorithm, network genesis hash,
//! and plaintext input of derivations with each password-free derivation on its
//! own line.
//!
//! Example command line to generate `derivations` update:
//!
//! `$ cargo run derivations -title westend -payload my_westend_set.txt`
use db_handling::identities::prepare_derivations_export;
use definitions::error_active::ErrorActive;
use qrcode_rtx::make_pretty_qr;

use crate::helpers::get_address_book_entry;
use crate::parser::{Derivations, Goal};

/// Generate `derivations` update QR code and/or text file
///
/// Function inputs [`Derivations`] and, in case of success, as `goal` field in
/// [`Derivations`] suggests, outputs QR code and/or text file with hex-encoded
/// payload content in `/generate_message/` folder.
///
/// `derivations` update could be generated only for networks known to the hot
/// database. In command line user indicates the network by its address book
/// title, for example `westend` or `westend-ed25519`. It goes into `title`
/// field of [`Derivations`], and is processed to get network encryption and
/// genesis hash.
pub fn process_derivations(x: Derivations) -> Result<(), ErrorActive> {
    // get network information from the database, by network address book title
    let address_book_entry = get_address_book_entry(&x.title)?;

    // prepare `ContentDerivations`
    let content = prepare_derivations_export(
        &address_book_entry.encryption,
        &address_book_entry.genesis_hash,
        &x.derivations,
    )?;

    // prelude, always identical
    let prelude = hex::decode("53ffde").expect("known static value");

    // complete update content
    let complete_message = [prelude, content.to_transfer()].concat();

    // output file name in `/generate_message/` folder
    let output_name = format!("derivations-{}", x.title);
    match x.goal {
        Goal::Qr => {
            if let Err(e) = make_pretty_qr(&complete_message, &output_name) {
                return Err(ErrorActive::Qr(e.to_string()));
            }
        }
        Goal::Text => {
            if let Err(e) = std::fs::write(
                &format!("{}.txt", output_name),
                &hex::encode(&complete_message),
            ) {
                return Err(ErrorActive::Output(e));
            }
        }
        Goal::Both => {
            if let Err(e) = std::fs::write(
                &format!("{}.txt", output_name),
                &hex::encode(&complete_message),
            ) {
                return Err(ErrorActive::Output(e));
            }
            if let Err(e) = make_pretty_qr(&complete_message, &output_name) {
                return Err(ErrorActive::Qr(e.to_string()));
            }
        }
    }
    Ok(())
}
