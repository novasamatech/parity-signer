// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(signerFFI)
    import signerFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_signer_efbd_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_signer_efbd_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a libray of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// A helper class to read values out of a byte buffer.
private class Reader {
    let data: Data
    var offset: Data.Index

    init(data: Data) {
        self.data = data
        offset = 0
    }

    // Reads an integer at the current offset, in big-endian order, and advances
    // the offset on success. Throws if reading the integer would move the
    // offset past the end of the buffer.
    func readInt<T: FixedWidthInteger>() throws -> T {
        let range = offset ..< offset + MemoryLayout<T>.size
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        if T.self == UInt8.self {
            let value = data[offset]
            offset += 1
            return value as! T
        }
        var value: T = 0
        let _ = withUnsafeMutableBytes(of: &value) { data.copyBytes(to: $0, from: range) }
        offset = range.upperBound
        return value.bigEndian
    }

    // Reads an arbitrary number of bytes, to be used to read
    // raw bytes, this is useful when lifting strings
    func readBytes(count: Int) throws -> [UInt8] {
        let range = offset ..< (offset + count)
        guard data.count >= range.upperBound else {
            throw UniffiInternalError.bufferOverflow
        }
        var value = [UInt8](repeating: 0, count: count)
        value.withUnsafeMutableBufferPointer { buffer in
            data.copyBytes(to: buffer, from: range)
        }
        offset = range.upperBound
        return value
    }

    // Reads a float at the current offset.
    @inlinable
    func readFloat() throws -> Float {
        return Float(bitPattern: try readInt())
    }

    // Reads a float at the current offset.
    @inlinable
    func readDouble() throws -> Double {
        return Double(bitPattern: try readInt())
    }

    // Indicates if the offset has reached the end of the buffer.
    @inlinable
    func hasRemaining() -> Bool {
        return offset < data.count
    }
}

// A helper class to write values into a byte buffer.
private class Writer {
    var bytes: [UInt8]
    var offset: Array<UInt8>.Index

    init() {
        bytes = []
        offset = 0
    }

    func writeBytes<S>(_ byteArr: S) where S: Sequence, S.Element == UInt8 {
        bytes.append(contentsOf: byteArr)
    }

    // Writes an integer in big-endian order.
    //
    // Warning: make sure what you are trying to write
    // is in the correct type!
    func writeInt<T: FixedWidthInteger>(_ value: T) {
        var value = value.bigEndian
        withUnsafeBytes(of: &value) { bytes.append(contentsOf: $0) }
    }

    @inlinable
    func writeFloat(_ value: Float) {
        writeInt(value.bitPattern)
    }

    @inlinable
    func writeDouble(_ value: Double) {
        writeInt(value.bitPattern)
    }
}

// Types conforming to `Serializable` can be read and written in a bytebuffer.
private protocol Serializable {
    func write(into: Writer)
    static func read(from: Reader) throws -> Self
}

// Types confirming to `ViaFfi` can be transferred back-and-for over the FFI.
// This is analogous to the Rust trait of the same name.
private protocol ViaFfi: Serializable {
    associatedtype FfiType
    static func lift(_ v: FfiType) throws -> Self
    func lower() -> FfiType
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol Primitive {}

private extension Primitive {
    typealias FfiType = Self

    static func lift(_ v: Self) throws -> Self {
        return v
    }

    func lower() -> Self {
        return self
    }
}

// Types conforming to `ViaFfiUsingByteBuffer` lift and lower into a bytebuffer.
// Use this for complex types where it's hard to write a custom lift/lower.
private protocol ViaFfiUsingByteBuffer: Serializable {}

private extension ViaFfiUsingByteBuffer {
    typealias FfiType = RustBuffer

    static func lift(_ buf: FfiType) throws -> Self {
        let reader = Reader(data: Data(rustBuffer: buf))
        let value = try Self.read(from: reader)
        if reader.hasRemaining() {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    func lower() -> FfiType {
        let writer = Writer()
        write(into: writer)
        return RustBuffer(bytes: writer.bytes)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, E: ViaFfiUsingByteBuffer & Error>(_: E.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: { try E.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
    case CALL_SUCCESS:
        return returnedVal

    case CALL_ERROR:
        throw try errorHandler(callStatus.errorBuf)

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw UniffiInternalError.rustPanic(try String.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Protocols for converters we'll implement in templates

private protocol FfiConverter {
    associatedtype SwiftType
    associatedtype FfiType

    static func lift(_ ffiValue: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType

    static func read(from: Reader) throws -> SwiftType
    static func write(_ value: SwiftType, into: Writer)
}

private protocol FfiConverterUsingByteBuffer: FfiConverter where FfiType == RustBuffer {
    // Empty, because we want to declare some helper methods in the extension below.
}

extension FfiConverterUsingByteBuffer {
    static func lower(_ value: SwiftType) -> FfiType {
        let writer = Writer()
        Self.write(value, into: writer)
        return RustBuffer(bytes: writer.bytes)
    }

    static func lift(_ buf: FfiType) throws -> SwiftType {
        let reader = Reader(data: Data(rustBuffer: buf))
        let value = try Self.read(from: reader)
        if reader.hasRemaining() {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }
}

// Helpers for structural types. Note that because of canonical_names, it /should/ be impossible
// to make another `FfiConverterSequence` etc just using the UDL.
private enum FfiConverterSequence {
    static func write<T>(_ value: [T], into buf: Writer, writeItem: (T, Writer) -> Void) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for item in value {
            writeItem(item, buf)
        }
    }

    static func read<T>(from buf: Reader, readItem: (Reader) throws -> T) throws -> [T] {
        let len: Int32 = try buf.readInt()
        var seq = [T]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try readItem(buf))
        }
        return seq
    }
}

private enum FfiConverterOptional {
    static func write<T>(_ value: T?, into buf: Writer, writeItem: (T, Writer) -> Void) {
        guard let value = value else {
            buf.writeInt(Int8(0))
            return
        }
        buf.writeInt(Int8(1))
        writeItem(value, buf)
    }

    static func read<T>(from buf: Reader, readItem: (Reader) throws -> T) throws -> T? {
        switch try buf.readInt() as Int8 {
        case 0: return nil
        case 1: return try readItem(buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private enum FfiConverterDictionary {
    static func write<T>(_ value: [String: T], into buf: Writer, writeItem: (String, T, Writer) -> Void) {
        let len = Int32(value.count)
        buf.writeInt(len)
        for (key, value) in value {
            writeItem(key, value, buf)
        }
    }

    static func read<T>(from buf: Reader, readItem: (Reader) throws -> (String, T)) throws -> [String: T] {
        let len: Int32 = try buf.readInt()
        var dict = [String: T]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let (key, value) = try readItem(buf)
            dict[key] = value
        }
        return dict
    }
}

// Public interface members begin here.

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum VerifierValue {
    case standard(m: String)
}

extension VerifierValue: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> VerifierValue {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .standard(
                m: try FfiConverterTypeMultiSigner.read(buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case let .standard(m):
            buf.writeInt(Int32(1))
            FfiConverterTypeMultiSigner.write(m, buf)
        }
    }
}

extension VerifierValue: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Encryption {
    case ed25519
    case sr25519
    case ecdsa
}

extension Encryption: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Encryption {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .ed25519
        case 2: return .sr25519
        case 3: return .ecdsa
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .ed25519:
            buf.writeInt(Int32(1))

        case .sr25519:
            buf.writeInt(Int32(2))

        case .ecdsa:
            buf.writeInt(Int32(3))
        }
    }
}

extension Encryption: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ValidCurrentVerifier {
    case general
    case custom(v: Verifier)
}

extension ValidCurrentVerifier: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> ValidCurrentVerifier {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .general
        case 2: return .custom(
                v: try Verifier.read(from: buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .general:
            buf.writeInt(Int32(1))

        case let .custom(v):
            buf.writeInt(Int32(2))
            v.write(into: buf)
        }
    }
}

extension ValidCurrentVerifier: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FooterButton {
    case log
    case scan
    case keys
    case settings
}

extension FooterButton: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> FooterButton {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .log
        case 2: return .scan
        case 3: return .keys
        case 4: return .settings
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .log:
            buf.writeInt(Int32(1))

        case .scan:
            buf.writeInt(Int32(2))

        case .keys:
            buf.writeInt(Int32(3))

        case .settings:
            buf.writeInt(Int32(4))
        }
    }
}

extension FooterButton: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RightButton {
    case logRight
    case newSeed
    case backup
    case multiSelect
    case ndMenu
    case typesInfo
    case keyMenu
}

extension RightButton: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> RightButton {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .logRight
        case 2: return .newSeed
        case 3: return .backup
        case 4: return .multiSelect
        case 5: return .ndMenu
        case 6: return .typesInfo
        case 7: return .keyMenu
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .logRight:
            buf.writeInt(Int32(1))

        case .newSeed:
            buf.writeInt(Int32(2))

        case .backup:
            buf.writeInt(Int32(3))

        case .multiSelect:
            buf.writeInt(Int32(4))

        case .ndMenu:
            buf.writeInt(Int32(5))

        case .typesInfo:
            buf.writeInt(Int32(6))

        case .keyMenu:
            buf.writeInt(Int32(7))
        }
    }
}

extension RightButton: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ScreenNameType {
    case h1
    case h4
}

extension ScreenNameType: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> ScreenNameType {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .h1
        case 2: return .h4
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .h1:
            buf.writeInt(Int32(1))

        case .h4:
            buf.writeInt(Int32(2))
        }
    }
}

extension ScreenNameType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Event {
    case metadataAdded(metaValuesDisplay: MetaValuesDisplay)
    case metadataRemoved(metaValuesDisplay: MetaValuesDisplay)
    case metadataSigned(metaValuesExport: MetaValuesExport)
    case networkSpecsAdded(networkSpecsDisplay: NetworkSpecsDisplay)
    case networkSpecsRemoved(networkSpecsDisplay: NetworkSpecsDisplay)
    case networkSpecsSigned(networkSpecsExport: NetworkSpecsExport)
    case networkVerifierSet(networkVerifierDisplay: NetworkVerifierDisplay)
    case generalVerifierSet(verifier: Verifier)
    case typesAdded(typesDisplay: TypesDisplay)
    case typesRemoved(typesDisplay: TypesDisplay)
    case typesSigned(typesExport: TypesExport)
    case transactionSigned(signDisplay: SignDisplay)
    case transactionSignError(signDisplay: SignDisplay)
    case messageSigned(signMessageDisplay: SignMessageDisplay)
    case messageSignError(signMessageDisplay: SignMessageDisplay)
    case identityAdded(identityHistory: IdentityHistory)
    case identityRemoved(identityHistory: IdentityHistory)
    case identitiesWiped
    case deviceWasOnline
    case resetDangerRecord
    case seedCreated(seedCreated: String)
    case seedNameWasShown(seedNameWasShown: String)
    case warning(warning: String)
    case wrongPassword
    case userEntry(userEntry: String)
    case systemEntry(systemEntry: String)
    case historyCleared
    case databaseInitiated
}

extension Event: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Event {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .metadataAdded(
                metaValuesDisplay: try MetaValuesDisplay.read(from: buf)
            )
        case 2: return .metadataRemoved(
                metaValuesDisplay: try MetaValuesDisplay.read(from: buf)
            )
        case 3: return .metadataSigned(
                metaValuesExport: try MetaValuesExport.read(from: buf)
            )
        case 4: return .networkSpecsAdded(
                networkSpecsDisplay: try NetworkSpecsDisplay.read(from: buf)
            )
        case 5: return .networkSpecsRemoved(
                networkSpecsDisplay: try NetworkSpecsDisplay.read(from: buf)
            )
        case 6: return .networkSpecsSigned(
                networkSpecsExport: try NetworkSpecsExport.read(from: buf)
            )
        case 7: return .networkVerifierSet(
                networkVerifierDisplay: try NetworkVerifierDisplay.read(from: buf)
            )
        case 8: return .generalVerifierSet(
                verifier: try Verifier.read(from: buf)
            )
        case 9: return .typesAdded(
                typesDisplay: try TypesDisplay.read(from: buf)
            )
        case 10: return .typesRemoved(
                typesDisplay: try TypesDisplay.read(from: buf)
            )
        case 11: return .typesSigned(
                typesExport: try TypesExport.read(from: buf)
            )
        case 12: return .transactionSigned(
                signDisplay: try SignDisplay.read(from: buf)
            )
        case 13: return .transactionSignError(
                signDisplay: try SignDisplay.read(from: buf)
            )
        case 14: return .messageSigned(
                signMessageDisplay: try SignMessageDisplay.read(from: buf)
            )
        case 15: return .messageSignError(
                signMessageDisplay: try SignMessageDisplay.read(from: buf)
            )
        case 16: return .identityAdded(
                identityHistory: try IdentityHistory.read(from: buf)
            )
        case 17: return .identityRemoved(
                identityHistory: try IdentityHistory.read(from: buf)
            )
        case 18: return .identitiesWiped
        case 19: return .deviceWasOnline
        case 20: return .resetDangerRecord
        case 21: return .seedCreated(
                seedCreated: try String.read(from: buf)
            )
        case 22: return .seedNameWasShown(
                seedNameWasShown: try String.read(from: buf)
            )
        case 23: return .warning(
                warning: try String.read(from: buf)
            )
        case 24: return .wrongPassword
        case 25: return .userEntry(
                userEntry: try String.read(from: buf)
            )
        case 26: return .systemEntry(
                systemEntry: try String.read(from: buf)
            )
        case 27: return .historyCleared
        case 28: return .databaseInitiated
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case let .metadataAdded(metaValuesDisplay):
            buf.writeInt(Int32(1))
            metaValuesDisplay.write(into: buf)

        case let .metadataRemoved(metaValuesDisplay):
            buf.writeInt(Int32(2))
            metaValuesDisplay.write(into: buf)

        case let .metadataSigned(metaValuesExport):
            buf.writeInt(Int32(3))
            metaValuesExport.write(into: buf)

        case let .networkSpecsAdded(networkSpecsDisplay):
            buf.writeInt(Int32(4))
            networkSpecsDisplay.write(into: buf)

        case let .networkSpecsRemoved(networkSpecsDisplay):
            buf.writeInt(Int32(5))
            networkSpecsDisplay.write(into: buf)

        case let .networkSpecsSigned(networkSpecsExport):
            buf.writeInt(Int32(6))
            networkSpecsExport.write(into: buf)

        case let .networkVerifierSet(networkVerifierDisplay):
            buf.writeInt(Int32(7))
            networkVerifierDisplay.write(into: buf)

        case let .generalVerifierSet(verifier):
            buf.writeInt(Int32(8))
            verifier.write(into: buf)

        case let .typesAdded(typesDisplay):
            buf.writeInt(Int32(9))
            typesDisplay.write(into: buf)

        case let .typesRemoved(typesDisplay):
            buf.writeInt(Int32(10))
            typesDisplay.write(into: buf)

        case let .typesSigned(typesExport):
            buf.writeInt(Int32(11))
            typesExport.write(into: buf)

        case let .transactionSigned(signDisplay):
            buf.writeInt(Int32(12))
            signDisplay.write(into: buf)

        case let .transactionSignError(signDisplay):
            buf.writeInt(Int32(13))
            signDisplay.write(into: buf)

        case let .messageSigned(signMessageDisplay):
            buf.writeInt(Int32(14))
            signMessageDisplay.write(into: buf)

        case let .messageSignError(signMessageDisplay):
            buf.writeInt(Int32(15))
            signMessageDisplay.write(into: buf)

        case let .identityAdded(identityHistory):
            buf.writeInt(Int32(16))
            identityHistory.write(into: buf)

        case let .identityRemoved(identityHistory):
            buf.writeInt(Int32(17))
            identityHistory.write(into: buf)

        case .identitiesWiped:
            buf.writeInt(Int32(18))

        case .deviceWasOnline:
            buf.writeInt(Int32(19))

        case .resetDangerRecord:
            buf.writeInt(Int32(20))

        case let .seedCreated(seedCreated):
            buf.writeInt(Int32(21))
            seedCreated.write(into: buf)

        case let .seedNameWasShown(seedNameWasShown):
            buf.writeInt(Int32(22))
            seedNameWasShown.write(into: buf)

        case let .warning(warning):
            buf.writeInt(Int32(23))
            warning.write(into: buf)

        case .wrongPassword:
            buf.writeInt(Int32(24))

        case let .userEntry(userEntry):
            buf.writeInt(Int32(25))
            userEntry.write(into: buf)

        case let .systemEntry(systemEntry):
            buf.writeInt(Int32(26))
            systemEntry.write(into: buf)

        case .historyCleared:
            buf.writeInt(Int32(27))

        case .databaseInitiated:
            buf.writeInt(Int32(28))
        }
    }
}

extension Event: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Action {
    case start
    case navbarLog
    case navbarScan
    case navbarKeys
    case navbarSettings
    case goBack
    case goForward
    case selectSeed
    case selectKey
    case newKey
    case rightButtonAction
    case shield
    case newSeed
    case recoverSeed
    case backupSeed
    case networkSelector
    case nextUnit
    case previousUnit
    case changeNetwork
    case checkPassword
    case transactionFetched
    case removeNetwork
    case removeMetadata
    case removeTypes
    case signNetworkSpecs
    case signMetadata
    case signTypes
    case manageNetworks
    case viewGeneralVerifier
    case manageMetadata
    case removeKey
    case removeSeed
    case clearLog
    case createLogComment
    case showLogDetails
    case swipe
    case longTap
    case selectAll
    case exportMultiSelect
    case increment
    case showDocuments
    case textEntry
    case pushWord
    case nothing
}

extension Action: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Action {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .start
        case 2: return .navbarLog
        case 3: return .navbarScan
        case 4: return .navbarKeys
        case 5: return .navbarSettings
        case 6: return .goBack
        case 7: return .goForward
        case 8: return .selectSeed
        case 9: return .selectKey
        case 10: return .newKey
        case 11: return .rightButtonAction
        case 12: return .shield
        case 13: return .newSeed
        case 14: return .recoverSeed
        case 15: return .backupSeed
        case 16: return .networkSelector
        case 17: return .nextUnit
        case 18: return .previousUnit
        case 19: return .changeNetwork
        case 20: return .checkPassword
        case 21: return .transactionFetched
        case 22: return .removeNetwork
        case 23: return .removeMetadata
        case 24: return .removeTypes
        case 25: return .signNetworkSpecs
        case 26: return .signMetadata
        case 27: return .signTypes
        case 28: return .manageNetworks
        case 29: return .viewGeneralVerifier
        case 30: return .manageMetadata
        case 31: return .removeKey
        case 32: return .removeSeed
        case 33: return .clearLog
        case 34: return .createLogComment
        case 35: return .showLogDetails
        case 36: return .swipe
        case 37: return .longTap
        case 38: return .selectAll
        case 39: return .exportMultiSelect
        case 40: return .increment
        case 41: return .showDocuments
        case 42: return .textEntry
        case 43: return .pushWord
        case 44: return .nothing
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .start:
            buf.writeInt(Int32(1))

        case .navbarLog:
            buf.writeInt(Int32(2))

        case .navbarScan:
            buf.writeInt(Int32(3))

        case .navbarKeys:
            buf.writeInt(Int32(4))

        case .navbarSettings:
            buf.writeInt(Int32(5))

        case .goBack:
            buf.writeInt(Int32(6))

        case .goForward:
            buf.writeInt(Int32(7))

        case .selectSeed:
            buf.writeInt(Int32(8))

        case .selectKey:
            buf.writeInt(Int32(9))

        case .newKey:
            buf.writeInt(Int32(10))

        case .rightButtonAction:
            buf.writeInt(Int32(11))

        case .shield:
            buf.writeInt(Int32(12))

        case .newSeed:
            buf.writeInt(Int32(13))

        case .recoverSeed:
            buf.writeInt(Int32(14))

        case .backupSeed:
            buf.writeInt(Int32(15))

        case .networkSelector:
            buf.writeInt(Int32(16))

        case .nextUnit:
            buf.writeInt(Int32(17))

        case .previousUnit:
            buf.writeInt(Int32(18))

        case .changeNetwork:
            buf.writeInt(Int32(19))

        case .checkPassword:
            buf.writeInt(Int32(20))

        case .transactionFetched:
            buf.writeInt(Int32(21))

        case .removeNetwork:
            buf.writeInt(Int32(22))

        case .removeMetadata:
            buf.writeInt(Int32(23))

        case .removeTypes:
            buf.writeInt(Int32(24))

        case .signNetworkSpecs:
            buf.writeInt(Int32(25))

        case .signMetadata:
            buf.writeInt(Int32(26))

        case .signTypes:
            buf.writeInt(Int32(27))

        case .manageNetworks:
            buf.writeInt(Int32(28))

        case .viewGeneralVerifier:
            buf.writeInt(Int32(29))

        case .manageMetadata:
            buf.writeInt(Int32(30))

        case .removeKey:
            buf.writeInt(Int32(31))

        case .removeSeed:
            buf.writeInt(Int32(32))

        case .clearLog:
            buf.writeInt(Int32(33))

        case .createLogComment:
            buf.writeInt(Int32(34))

        case .showLogDetails:
            buf.writeInt(Int32(35))

        case .swipe:
            buf.writeInt(Int32(36))

        case .longTap:
            buf.writeInt(Int32(37))

        case .selectAll:
            buf.writeInt(Int32(38))

        case .exportMultiSelect:
            buf.writeInt(Int32(39))

        case .increment:
            buf.writeInt(Int32(40))

        case .showDocuments:
            buf.writeInt(Int32(41))

        case .textEntry:
            buf.writeInt(Int32(42))

        case .pushWord:
            buf.writeInt(Int32(43))

        case .nothing:
            buf.writeInt(Int32(44))
        }
    }
}

extension Action: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TransactionType {
    case sign
    case stub
    case read
    case importDerivations
    case done
}

extension TransactionType: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> TransactionType {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .sign
        case 2: return .stub
        case 3: return .read
        case 4: return .importDerivations
        case 5: return .done
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .sign:
            buf.writeInt(Int32(1))

        case .stub:
            buf.writeInt(Int32(2))

        case .read:
            buf.writeInt(Int32(3))

        case .importDerivations:
            buf.writeInt(Int32(4))

        case .done:
            buf.writeInt(Int32(5))
        }
    }
}

extension TransactionType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DerivationDestination {
    case pwd
    case pin
}

extension DerivationDestination: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> DerivationDestination {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .pwd
        case 2: return .pin
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .pwd:
            buf.writeInt(Int32(1))

        case .pin:
            buf.writeInt(Int32(2))
        }
    }
}

extension DerivationDestination: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ScreenData {
    case scan
    case keys(f: MKeys)
    case settings(f: MSettings)
    case log(f: MLog)
    case logDetails(f: MLogDetails)
    case transaction(f: MTransaction)
    case seedSelector(f: MSeeds)
    case keyDetails(f: MKeyDetails)
    case newSeed(f: MNewSeed)
    case recoverSeedName(f: MRecoverSeedName)
    case recoverSeedPhrase(f: MRecoverSeedPhrase)
    case deriveKey(f: MDeriveKey)
    case vVerifier(f: MVerifierDetails)
    case manageNetworks(f: MManageNetworks)
    case nNetworkDetails(f: MNetworkDetails)
    case signSufficientCrypto(f: MSignSufficientCrypto)
    case selectSeedForBackup(f: MSeeds)
    case documents
    case keyDetailsMulti(f: MKeyDetailsMulti)
}

extension ScreenData: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> ScreenData {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .scan
        case 2: return .keys(
                f: try MKeys.read(from: buf)
            )
        case 3: return .settings(
                f: try MSettings.read(from: buf)
            )
        case 4: return .log(
                f: try MLog.read(from: buf)
            )
        case 5: return .logDetails(
                f: try MLogDetails.read(from: buf)
            )
        case 6: return .transaction(
                f: try MTransaction.read(from: buf)
            )
        case 7: return .seedSelector(
                f: try MSeeds.read(from: buf)
            )
        case 8: return .keyDetails(
                f: try MKeyDetails.read(from: buf)
            )
        case 9: return .newSeed(
                f: try MNewSeed.read(from: buf)
            )
        case 10: return .recoverSeedName(
                f: try MRecoverSeedName.read(from: buf)
            )
        case 11: return .recoverSeedPhrase(
                f: try MRecoverSeedPhrase.read(from: buf)
            )
        case 12: return .deriveKey(
                f: try MDeriveKey.read(from: buf)
            )
        case 13: return .vVerifier(
                f: try MVerifierDetails.read(from: buf)
            )
        case 14: return .manageNetworks(
                f: try MManageNetworks.read(from: buf)
            )
        case 15: return .nNetworkDetails(
                f: try MNetworkDetails.read(from: buf)
            )
        case 16: return .signSufficientCrypto(
                f: try MSignSufficientCrypto.read(from: buf)
            )
        case 17: return .selectSeedForBackup(
                f: try MSeeds.read(from: buf)
            )
        case 18: return .documents
        case 19: return .keyDetailsMulti(
                f: try MKeyDetailsMulti.read(from: buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case .scan:
            buf.writeInt(Int32(1))

        case let .keys(f):
            buf.writeInt(Int32(2))
            f.write(into: buf)

        case let .settings(f):
            buf.writeInt(Int32(3))
            f.write(into: buf)

        case let .log(f):
            buf.writeInt(Int32(4))
            f.write(into: buf)

        case let .logDetails(f):
            buf.writeInt(Int32(5))
            f.write(into: buf)

        case let .transaction(f):
            buf.writeInt(Int32(6))
            f.write(into: buf)

        case let .seedSelector(f):
            buf.writeInt(Int32(7))
            f.write(into: buf)

        case let .keyDetails(f):
            buf.writeInt(Int32(8))
            f.write(into: buf)

        case let .newSeed(f):
            buf.writeInt(Int32(9))
            f.write(into: buf)

        case let .recoverSeedName(f):
            buf.writeInt(Int32(10))
            f.write(into: buf)

        case let .recoverSeedPhrase(f):
            buf.writeInt(Int32(11))
            f.write(into: buf)

        case let .deriveKey(f):
            buf.writeInt(Int32(12))
            f.write(into: buf)

        case let .vVerifier(f):
            buf.writeInt(Int32(13))
            f.write(into: buf)

        case let .manageNetworks(f):
            buf.writeInt(Int32(14))
            f.write(into: buf)

        case let .nNetworkDetails(f):
            buf.writeInt(Int32(15))
            f.write(into: buf)

        case let .signSufficientCrypto(f):
            buf.writeInt(Int32(16))
            f.write(into: buf)

        case let .selectSeedForBackup(f):
            buf.writeInt(Int32(17))
            f.write(into: buf)

        case .documents:
            buf.writeInt(Int32(18))

        case let .keyDetailsMulti(f):
            buf.writeInt(Int32(19))
            f.write(into: buf)
        }
    }
}

extension ScreenData: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ModalData {
    case sufficientCryptoReady(f: MSufficientCryptoReady)
    case backup(f: MBackup)
    case seedMenu(f: MSeedMenu)
    case newSeedBackup(f: MNewSeedBackup)
    case networkSelector(f: MNetworkMenu)
    case passwordConfirm(f: MPasswordConfirm)
    case signatureReady(f: MSignatureReady)
    case enterPassword(f: MEnterPassword)
    case logRight(f: MLogRight)
    case manageNetworks(f: MmManageNetworks)
    case typesInfo(f: MTypesInfo)
    case newSeedMenu
    case networkDetailsMenu
    case manageMetadata
    case keyDetailsAction
    case logComment
    case selectSeed(f: MSeeds)
}

extension ModalData: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> ModalData {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .sufficientCryptoReady(
                f: try MSufficientCryptoReady.read(from: buf)
            )
        case 2: return .backup(
                f: try MBackup.read(from: buf)
            )
        case 3: return .seedMenu(
                f: try MSeedMenu.read(from: buf)
            )
        case 4: return .newSeedBackup(
                f: try MNewSeedBackup.read(from: buf)
            )
        case 5: return .networkSelector(
                f: try MNetworkMenu.read(from: buf)
            )
        case 6: return .passwordConfirm(
                f: try MPasswordConfirm.read(from: buf)
            )
        case 7: return .signatureReady(
                f: try MSignatureReady.read(from: buf)
            )
        case 8: return .enterPassword(
                f: try MEnterPassword.read(from: buf)
            )
        case 9: return .logRight(
                f: try MLogRight.read(from: buf)
            )
        case 10: return .manageNetworks(
                f: try MmManageNetworks.read(from: buf)
            )
        case 11: return .typesInfo(
                f: try MTypesInfo.read(from: buf)
            )
        case 12: return .newSeedMenu
        case 13: return .networkDetailsMenu
        case 14: return .manageMetadata
        case 15: return .keyDetailsAction
        case 16: return .logComment
        case 17: return .selectSeed(
                f: try MSeeds.read(from: buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case let .sufficientCryptoReady(f):
            buf.writeInt(Int32(1))
            f.write(into: buf)

        case let .backup(f):
            buf.writeInt(Int32(2))
            f.write(into: buf)

        case let .seedMenu(f):
            buf.writeInt(Int32(3))
            f.write(into: buf)

        case let .newSeedBackup(f):
            buf.writeInt(Int32(4))
            f.write(into: buf)

        case let .networkSelector(f):
            buf.writeInt(Int32(5))
            f.write(into: buf)

        case let .passwordConfirm(f):
            buf.writeInt(Int32(6))
            f.write(into: buf)

        case let .signatureReady(f):
            buf.writeInt(Int32(7))
            f.write(into: buf)

        case let .enterPassword(f):
            buf.writeInt(Int32(8))
            f.write(into: buf)

        case let .logRight(f):
            buf.writeInt(Int32(9))
            f.write(into: buf)

        case let .manageNetworks(f):
            buf.writeInt(Int32(10))
            f.write(into: buf)

        case let .typesInfo(f):
            buf.writeInt(Int32(11))
            f.write(into: buf)

        case .newSeedMenu:
            buf.writeInt(Int32(12))

        case .networkDetailsMenu:
            buf.writeInt(Int32(13))

        case .manageMetadata:
            buf.writeInt(Int32(14))

        case .keyDetailsAction:
            buf.writeInt(Int32(15))

        case .logComment:
            buf.writeInt(Int32(16))

        case let .selectSeed(f):
            buf.writeInt(Int32(17))
            f.write(into: buf)
        }
    }
}

extension ModalData: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Card {
    case authorCard(f: TransactionAuthor)
    case authorPlainCard(f: MscAuthorPlain)
    case authorPublicKeyCard(f: MVerifierDetails)
    case balanceCard(f: MscCurrency)
    case bitVecCard(f: String)
    case blockHashCard(f: String)
    case callCard(f: MscCall)
    case defaultCard(f: String)
    case derivationsCard(f: [String])
    case enumVariantNameCard(f: MscEnumVariantName)
    case eraImmortalCard
    case eraMortalCard(f: MscEraMortal)
    case errorCard(f: String)
    case fieldNameCard(f: MscFieldName)
    case fieldNumberCard(f: MscFieldNumber)
    case idCard(f: MscId)
    case identityFieldCard(f: String)
    case metaCard(f: MscMetaSpecs)
    case nameVersionCard(f: MscNameVersion)
    case networkGenesisHashCard(f: String)
    case networkNameCard(f: String)
    case networkInfoCard(f: MscNetworkInfo)
    case newSpecsCard(f: NetworkSpecsToSend)
    case nonceCard(f: String)
    case noneCard
    case palletCard(f: String)
    case textCard(f: String)
    case tipCard(f: MscCurrency)
    case tipPlainCard(f: String)
    case txSpecCard(f: String)
    case txSpecPlainCard(f: MscTxSpecPlain)
    case typesInfoCard(f: MTypesInfo)
    case varNameCard(f: String)
    case verifierCard(f: MVerifierDetails)
    case warningCard(f: String)
}

extension Card: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Card {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .authorCard(
                f: try TransactionAuthor.read(from: buf)
            )
        case 2: return .authorPlainCard(
                f: try MscAuthorPlain.read(from: buf)
            )
        case 3: return .authorPublicKeyCard(
                f: try MVerifierDetails.read(from: buf)
            )
        case 4: return .balanceCard(
                f: try MscCurrency.read(from: buf)
            )
        case 5: return .bitVecCard(
                f: try String.read(from: buf)
            )
        case 6: return .blockHashCard(
                f: try String.read(from: buf)
            )
        case 7: return .callCard(
                f: try MscCall.read(from: buf)
            )
        case 8: return .defaultCard(
                f: try String.read(from: buf)
            )
        case 9: return .derivationsCard(
                f: try FfiConverterSequenceString.read(from: buf)
            )
        case 10: return .enumVariantNameCard(
                f: try MscEnumVariantName.read(from: buf)
            )
        case 11: return .eraImmortalCard
        case 12: return .eraMortalCard(
                f: try MscEraMortal.read(from: buf)
            )
        case 13: return .errorCard(
                f: try String.read(from: buf)
            )
        case 14: return .fieldNameCard(
                f: try MscFieldName.read(from: buf)
            )
        case 15: return .fieldNumberCard(
                f: try MscFieldNumber.read(from: buf)
            )
        case 16: return .idCard(
                f: try MscId.read(from: buf)
            )
        case 17: return .identityFieldCard(
                f: try String.read(from: buf)
            )
        case 18: return .metaCard(
                f: try MscMetaSpecs.read(from: buf)
            )
        case 19: return .nameVersionCard(
                f: try MscNameVersion.read(from: buf)
            )
        case 20: return .networkGenesisHashCard(
                f: try String.read(from: buf)
            )
        case 21: return .networkNameCard(
                f: try String.read(from: buf)
            )
        case 22: return .networkInfoCard(
                f: try MscNetworkInfo.read(from: buf)
            )
        case 23: return .newSpecsCard(
                f: try NetworkSpecsToSend.read(from: buf)
            )
        case 24: return .nonceCard(
                f: try String.read(from: buf)
            )
        case 25: return .noneCard
        case 26: return .palletCard(
                f: try String.read(from: buf)
            )
        case 27: return .textCard(
                f: try String.read(from: buf)
            )
        case 28: return .tipCard(
                f: try MscCurrency.read(from: buf)
            )
        case 29: return .tipPlainCard(
                f: try String.read(from: buf)
            )
        case 30: return .txSpecCard(
                f: try String.read(from: buf)
            )
        case 31: return .txSpecPlainCard(
                f: try MscTxSpecPlain.read(from: buf)
            )
        case 32: return .typesInfoCard(
                f: try MTypesInfo.read(from: buf)
            )
        case 33: return .varNameCard(
                f: try String.read(from: buf)
            )
        case 34: return .verifierCard(
                f: try MVerifierDetails.read(from: buf)
            )
        case 35: return .warningCard(
                f: try String.read(from: buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case let .authorCard(f):
            buf.writeInt(Int32(1))
            f.write(into: buf)

        case let .authorPlainCard(f):
            buf.writeInt(Int32(2))
            f.write(into: buf)

        case let .authorPublicKeyCard(f):
            buf.writeInt(Int32(3))
            f.write(into: buf)

        case let .balanceCard(f):
            buf.writeInt(Int32(4))
            f.write(into: buf)

        case let .bitVecCard(f):
            buf.writeInt(Int32(5))
            f.write(into: buf)

        case let .blockHashCard(f):
            buf.writeInt(Int32(6))
            f.write(into: buf)

        case let .callCard(f):
            buf.writeInt(Int32(7))
            f.write(into: buf)

        case let .defaultCard(f):
            buf.writeInt(Int32(8))
            f.write(into: buf)

        case let .derivationsCard(f):
            buf.writeInt(Int32(9))
            FfiConverterSequenceString.write(f, into: buf)

        case let .enumVariantNameCard(f):
            buf.writeInt(Int32(10))
            f.write(into: buf)

        case .eraImmortalCard:
            buf.writeInt(Int32(11))

        case let .eraMortalCard(f):
            buf.writeInt(Int32(12))
            f.write(into: buf)

        case let .errorCard(f):
            buf.writeInt(Int32(13))
            f.write(into: buf)

        case let .fieldNameCard(f):
            buf.writeInt(Int32(14))
            f.write(into: buf)

        case let .fieldNumberCard(f):
            buf.writeInt(Int32(15))
            f.write(into: buf)

        case let .idCard(f):
            buf.writeInt(Int32(16))
            f.write(into: buf)

        case let .identityFieldCard(f):
            buf.writeInt(Int32(17))
            f.write(into: buf)

        case let .metaCard(f):
            buf.writeInt(Int32(18))
            f.write(into: buf)

        case let .nameVersionCard(f):
            buf.writeInt(Int32(19))
            f.write(into: buf)

        case let .networkGenesisHashCard(f):
            buf.writeInt(Int32(20))
            f.write(into: buf)

        case let .networkNameCard(f):
            buf.writeInt(Int32(21))
            f.write(into: buf)

        case let .networkInfoCard(f):
            buf.writeInt(Int32(22))
            f.write(into: buf)

        case let .newSpecsCard(f):
            buf.writeInt(Int32(23))
            f.write(into: buf)

        case let .nonceCard(f):
            buf.writeInt(Int32(24))
            f.write(into: buf)

        case .noneCard:
            buf.writeInt(Int32(25))

        case let .palletCard(f):
            buf.writeInt(Int32(26))
            f.write(into: buf)

        case let .textCard(f):
            buf.writeInt(Int32(27))
            f.write(into: buf)

        case let .tipCard(f):
            buf.writeInt(Int32(28))
            f.write(into: buf)

        case let .tipPlainCard(f):
            buf.writeInt(Int32(29))
            f.write(into: buf)

        case let .txSpecCard(f):
            buf.writeInt(Int32(30))
            f.write(into: buf)

        case let .txSpecPlainCard(f):
            buf.writeInt(Int32(31))
            f.write(into: buf)

        case let .typesInfoCard(f):
            buf.writeInt(Int32(32))
            f.write(into: buf)

        case let .varNameCard(f):
            buf.writeInt(Int32(33))
            f.write(into: buf)

        case let .verifierCard(f):
            buf.writeInt(Int32(34))
            f.write(into: buf)

        case let .warningCard(f):
            buf.writeInt(Int32(35))
            f.write(into: buf)
        }
    }
}

extension Card: Equatable, Hashable {}

public func actionGetName(action: Action) -> String {
    let _retval = try!

        rustCall {
            signer_efbd_action_get_name(action.lower(), $0)
        }
    return try! String.lift(_retval)
}

public func initNavigation(dbname: String, seedNames: String) {
    try!

        rustCall {
            signer_efbd_init_navigation(dbname.lower(), seedNames.lower(), $0)
        }
}

public func backendAction(action: Action, details: String, seedPhrase: String) throws -> ActionResult {
    let _retval = try

        rustCallWithError(ErrorDisplayed.self) {
            signer_efbd_backend_action(action.lower(), details.lower(), seedPhrase.lower(), $0)
        }
    return try ActionResult.lift(_retval)
}

public func updateSeedNames(seedNames: String) {
    try!

        rustCall {
            signer_efbd_update_seed_names(seedNames.lower(), $0)
        }
}

public func qrparserGetPacketsTotal(data: String, cleaned: Bool) throws -> UInt32 {
    let _retval = try

        rustCallWithError(ErrorDisplayed.self) {
            signer_efbd_qrparser_get_packets_total(data.lower(), cleaned.lower(), $0)
        }
    return try UInt32.lift(_retval)
}

public func qrparserTryDecodeQrSequence(data: String, cleaned: Bool) throws -> String {
    let _retval = try

        rustCallWithError(ErrorDisplayed.self) {
            signer_efbd_qrparser_try_decode_qr_sequence(data.lower(), cleaned.lower(), $0)
        }
    return try String.lift(_retval)
}

public func substratePathCheck(seedName: String, path: String, network: String, dbname: String) -> DerivationCheck {
    let _retval = try!

        rustCall {
            signer_efbd_substrate_path_check(seedName.lower(), path.lower(), network.lower(), dbname.lower(), $0)
        }
    return try! DerivationCheck.lift(_retval)
}

public func historyInitHistoryWithCert(dbname: String) throws {
    try

        rustCallWithError(ErrorDisplayed.self) {
            signer_efbd_history_init_history_with_cert(dbname.lower(), $0)
        }
}

public func historyInitHistoryNoCert(dbname: String) throws {
    try

        rustCallWithError(ErrorDisplayed.self) {
            signer_efbd_history_init_history_no_cert(dbname.lower(), $0)
        }
}

public func historyDeviceWasOnline(dbname: String) throws {
    try

        rustCallWithError(ErrorDisplayed.self) {
            signer_efbd_history_device_was_online(dbname.lower(), $0)
        }
}

public func historyGetWarnings(dbname: String) throws -> Bool {
    let _retval = try

        rustCallWithError(ErrorDisplayed.self) {
            signer_efbd_history_get_warnings(dbname.lower(), $0)
        }
    return try Bool.lift(_retval)
}

public func historyAcknowledgeWarnings(dbname: String) throws {
    try

        rustCallWithError(ErrorDisplayed.self) {
            signer_efbd_history_acknowledge_warnings(dbname.lower(), $0)
        }
}

public func historyEntrySystem(event: Event, dbname: String) throws {
    try

        rustCallWithError(ErrorDisplayed.self) {
            signer_efbd_history_entry_system(event.lower(), dbname.lower(), $0)
        }
}

public func historySeedNameWasShown(seedName: String, dbname: String) throws {
    try

        rustCallWithError(ErrorDisplayed.self) {
            signer_efbd_history_seed_name_was_shown(seedName.lower(), dbname.lower(), $0)
        }
}

public func getAllTxCards() -> TransactionCardSet {
    let _retval = try!

        rustCall {
            signer_efbd_get_all_tx_cards($0)
        }
    return try! TransactionCardSet.lift(_retval)
}

public func getAllLogCards() -> String {
    let _retval = try!

        rustCall {
            signer_efbd_get_all_log_cards($0)
        }
    return try! String.lift(_retval)
}

public func initLogging(tag: String) {
    try!

        rustCall {
            signer_efbd_init_logging(tag.lower(), $0)
        }
}

public struct MetaValuesDisplay {
    public var name: String
    public var version: UInt32
    public var metaHash: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, version: UInt32, metaHash: [UInt8]) {
        self.name = name
        self.version = version
        self.metaHash = metaHash
    }
}

extension MetaValuesDisplay: Equatable, Hashable {
    public static func == (lhs: MetaValuesDisplay, rhs: MetaValuesDisplay) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.metaHash != rhs.metaHash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(version)
        hasher.combine(metaHash)
    }
}

private extension MetaValuesDisplay {
    static func read(from buf: Reader) throws -> MetaValuesDisplay {
        return try MetaValuesDisplay(
            name: String.read(from: buf),
            version: UInt32.read(from: buf),
            metaHash: FfiConverterSequenceUInt8.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        name.write(into: buf)
        version.write(into: buf)
        FfiConverterSequenceUInt8.write(metaHash, into: buf)
    }
}

extension MetaValuesDisplay: ViaFfiUsingByteBuffer, ViaFfi {}

public struct Verifier {
    public var v: VerifierValue?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(v: VerifierValue?) {
        self.v = v
    }
}

extension Verifier: Equatable, Hashable {
    public static func == (lhs: Verifier, rhs: Verifier) -> Bool {
        if lhs.v != rhs.v {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(v)
    }
}

private extension Verifier {
    static func read(from buf: Reader) throws -> Verifier {
        return try Verifier(
            v: FfiConverterOptionEnumVerifierValue.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterOptionEnumVerifierValue.write(v, into: buf)
    }
}

extension Verifier: ViaFfiUsingByteBuffer, ViaFfi {}

public struct NetworkSpecs {
    public var base58prefix: UInt16
    public var color: String
    public var decimals: UInt8
    public var encryption: Encryption
    public var genesisHash: [UInt8]
    public var logo: String
    public var name: String
    public var order: UInt8
    public var pathId: String
    public var secondaryColor: String
    public var title: String
    public var unit: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(base58prefix: UInt16, color: String, decimals: UInt8, encryption: Encryption, genesisHash: [UInt8], logo: String, name: String, order: UInt8, pathId: String, secondaryColor: String, title: String, unit: String) {
        self.base58prefix = base58prefix
        self.color = color
        self.decimals = decimals
        self.encryption = encryption
        self.genesisHash = genesisHash
        self.logo = logo
        self.name = name
        self.order = order
        self.pathId = pathId
        self.secondaryColor = secondaryColor
        self.title = title
        self.unit = unit
    }
}

extension NetworkSpecs: Equatable, Hashable {
    public static func == (lhs: NetworkSpecs, rhs: NetworkSpecs) -> Bool {
        if lhs.base58prefix != rhs.base58prefix {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.decimals != rhs.decimals {
            return false
        }
        if lhs.encryption != rhs.encryption {
            return false
        }
        if lhs.genesisHash != rhs.genesisHash {
            return false
        }
        if lhs.logo != rhs.logo {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.order != rhs.order {
            return false
        }
        if lhs.pathId != rhs.pathId {
            return false
        }
        if lhs.secondaryColor != rhs.secondaryColor {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.unit != rhs.unit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(base58prefix)
        hasher.combine(color)
        hasher.combine(decimals)
        hasher.combine(encryption)
        hasher.combine(genesisHash)
        hasher.combine(logo)
        hasher.combine(name)
        hasher.combine(order)
        hasher.combine(pathId)
        hasher.combine(secondaryColor)
        hasher.combine(title)
        hasher.combine(unit)
    }
}

private extension NetworkSpecs {
    static func read(from buf: Reader) throws -> NetworkSpecs {
        return try NetworkSpecs(
            base58prefix: UInt16.read(from: buf),
            color: String.read(from: buf),
            decimals: UInt8.read(from: buf),
            encryption: Encryption.read(from: buf),
            genesisHash: FfiConverterTypeH256.read(buf),
            logo: String.read(from: buf),
            name: String.read(from: buf),
            order: UInt8.read(from: buf),
            pathId: String.read(from: buf),
            secondaryColor: String.read(from: buf),
            title: String.read(from: buf),
            unit: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        base58prefix.write(into: buf)
        color.write(into: buf)
        decimals.write(into: buf)
        encryption.write(into: buf)
        FfiConverterTypeH256.write(genesisHash, buf)
        logo.write(into: buf)
        name.write(into: buf)
        order.write(into: buf)
        pathId.write(into: buf)
        secondaryColor.write(into: buf)
        title.write(into: buf)
        unit.write(into: buf)
    }
}

extension NetworkSpecs: ViaFfiUsingByteBuffer, ViaFfi {}

public struct NetworkSpecsToSend {
    public var base58prefix: UInt16
    public var color: String
    public var decimals: UInt8
    public var encryption: Encryption
    public var genesisHash: [UInt8]
    public var logo: String
    public var name: String
    public var pathId: String
    public var secondaryColor: String
    public var title: String
    public var unit: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(base58prefix: UInt16, color: String, decimals: UInt8, encryption: Encryption, genesisHash: [UInt8], logo: String, name: String, pathId: String, secondaryColor: String, title: String, unit: String) {
        self.base58prefix = base58prefix
        self.color = color
        self.decimals = decimals
        self.encryption = encryption
        self.genesisHash = genesisHash
        self.logo = logo
        self.name = name
        self.pathId = pathId
        self.secondaryColor = secondaryColor
        self.title = title
        self.unit = unit
    }
}

extension NetworkSpecsToSend: Equatable, Hashable {
    public static func == (lhs: NetworkSpecsToSend, rhs: NetworkSpecsToSend) -> Bool {
        if lhs.base58prefix != rhs.base58prefix {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.decimals != rhs.decimals {
            return false
        }
        if lhs.encryption != rhs.encryption {
            return false
        }
        if lhs.genesisHash != rhs.genesisHash {
            return false
        }
        if lhs.logo != rhs.logo {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.pathId != rhs.pathId {
            return false
        }
        if lhs.secondaryColor != rhs.secondaryColor {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.unit != rhs.unit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(base58prefix)
        hasher.combine(color)
        hasher.combine(decimals)
        hasher.combine(encryption)
        hasher.combine(genesisHash)
        hasher.combine(logo)
        hasher.combine(name)
        hasher.combine(pathId)
        hasher.combine(secondaryColor)
        hasher.combine(title)
        hasher.combine(unit)
    }
}

private extension NetworkSpecsToSend {
    static func read(from buf: Reader) throws -> NetworkSpecsToSend {
        return try NetworkSpecsToSend(
            base58prefix: UInt16.read(from: buf),
            color: String.read(from: buf),
            decimals: UInt8.read(from: buf),
            encryption: Encryption.read(from: buf),
            genesisHash: FfiConverterTypeH256.read(buf),
            logo: String.read(from: buf),
            name: String.read(from: buf),
            pathId: String.read(from: buf),
            secondaryColor: String.read(from: buf),
            title: String.read(from: buf),
            unit: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        base58prefix.write(into: buf)
        color.write(into: buf)
        decimals.write(into: buf)
        encryption.write(into: buf)
        FfiConverterTypeH256.write(genesisHash, buf)
        logo.write(into: buf)
        name.write(into: buf)
        pathId.write(into: buf)
        secondaryColor.write(into: buf)
        title.write(into: buf)
        unit.write(into: buf)
    }
}

extension NetworkSpecsToSend: ViaFfiUsingByteBuffer, ViaFfi {}

public struct NetworkSpecsDisplay {
    public var specs: NetworkSpecs
    public var validCurrentVerifier: ValidCurrentVerifier
    public var generalVerifier: Verifier

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(specs: NetworkSpecs, validCurrentVerifier: ValidCurrentVerifier, generalVerifier: Verifier) {
        self.specs = specs
        self.validCurrentVerifier = validCurrentVerifier
        self.generalVerifier = generalVerifier
    }
}

extension NetworkSpecsDisplay: Equatable, Hashable {
    public static func == (lhs: NetworkSpecsDisplay, rhs: NetworkSpecsDisplay) -> Bool {
        if lhs.specs != rhs.specs {
            return false
        }
        if lhs.validCurrentVerifier != rhs.validCurrentVerifier {
            return false
        }
        if lhs.generalVerifier != rhs.generalVerifier {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(specs)
        hasher.combine(validCurrentVerifier)
        hasher.combine(generalVerifier)
    }
}

private extension NetworkSpecsDisplay {
    static func read(from buf: Reader) throws -> NetworkSpecsDisplay {
        return try NetworkSpecsDisplay(
            specs: NetworkSpecs.read(from: buf),
            validCurrentVerifier: ValidCurrentVerifier.read(from: buf),
            generalVerifier: Verifier.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        specs.write(into: buf)
        validCurrentVerifier.write(into: buf)
        generalVerifier.write(into: buf)
    }
}

extension NetworkSpecsDisplay: ViaFfiUsingByteBuffer, ViaFfi {}

public struct NetworkSpecsExport {
    public var specsToSend: NetworkSpecsToSend
    public var signedBy: VerifierValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(specsToSend: NetworkSpecsToSend, signedBy: VerifierValue) {
        self.specsToSend = specsToSend
        self.signedBy = signedBy
    }
}

extension NetworkSpecsExport: Equatable, Hashable {
    public static func == (lhs: NetworkSpecsExport, rhs: NetworkSpecsExport) -> Bool {
        if lhs.specsToSend != rhs.specsToSend {
            return false
        }
        if lhs.signedBy != rhs.signedBy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(specsToSend)
        hasher.combine(signedBy)
    }
}

private extension NetworkSpecsExport {
    static func read(from buf: Reader) throws -> NetworkSpecsExport {
        return try NetworkSpecsExport(
            specsToSend: NetworkSpecsToSend.read(from: buf),
            signedBy: VerifierValue.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        specsToSend.write(into: buf)
        signedBy.write(into: buf)
    }
}

extension NetworkSpecsExport: ViaFfiUsingByteBuffer, ViaFfi {}

public struct NetworkVerifierDisplay {
    public var genesisHash: [UInt8]
    public var validCurrentVerifier: ValidCurrentVerifier
    public var generalVerifier: Verifier

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(genesisHash: [UInt8], validCurrentVerifier: ValidCurrentVerifier, generalVerifier: Verifier) {
        self.genesisHash = genesisHash
        self.validCurrentVerifier = validCurrentVerifier
        self.generalVerifier = generalVerifier
    }
}

extension NetworkVerifierDisplay: Equatable, Hashable {
    public static func == (lhs: NetworkVerifierDisplay, rhs: NetworkVerifierDisplay) -> Bool {
        if lhs.genesisHash != rhs.genesisHash {
            return false
        }
        if lhs.validCurrentVerifier != rhs.validCurrentVerifier {
            return false
        }
        if lhs.generalVerifier != rhs.generalVerifier {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(genesisHash)
        hasher.combine(validCurrentVerifier)
        hasher.combine(generalVerifier)
    }
}

private extension NetworkVerifierDisplay {
    static func read(from buf: Reader) throws -> NetworkVerifierDisplay {
        return try NetworkVerifierDisplay(
            genesisHash: FfiConverterSequenceUInt8.read(from: buf),
            validCurrentVerifier: ValidCurrentVerifier.read(from: buf),
            generalVerifier: Verifier.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterSequenceUInt8.write(genesisHash, into: buf)
        validCurrentVerifier.write(into: buf)
        generalVerifier.write(into: buf)
    }
}

extension NetworkVerifierDisplay: ViaFfiUsingByteBuffer, ViaFfi {}

public struct TypesDisplay {
    public var typesHash: [UInt8]
    public var verifier: Verifier

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(typesHash: [UInt8], verifier: Verifier) {
        self.typesHash = typesHash
        self.verifier = verifier
    }
}

extension TypesDisplay: Equatable, Hashable {
    public static func == (lhs: TypesDisplay, rhs: TypesDisplay) -> Bool {
        if lhs.typesHash != rhs.typesHash {
            return false
        }
        if lhs.verifier != rhs.verifier {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(typesHash)
        hasher.combine(verifier)
    }
}

private extension TypesDisplay {
    static func read(from buf: Reader) throws -> TypesDisplay {
        return try TypesDisplay(
            typesHash: FfiConverterSequenceUInt8.read(from: buf),
            verifier: Verifier.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterSequenceUInt8.write(typesHash, into: buf)
        verifier.write(into: buf)
    }
}

extension TypesDisplay: ViaFfiUsingByteBuffer, ViaFfi {}

public struct TypesExport {
    public var typesHash: [UInt8]
    public var signedBy: VerifierValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(typesHash: [UInt8], signedBy: VerifierValue) {
        self.typesHash = typesHash
        self.signedBy = signedBy
    }
}

extension TypesExport: Equatable, Hashable {
    public static func == (lhs: TypesExport, rhs: TypesExport) -> Bool {
        if lhs.typesHash != rhs.typesHash {
            return false
        }
        if lhs.signedBy != rhs.signedBy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(typesHash)
        hasher.combine(signedBy)
    }
}

private extension TypesExport {
    static func read(from buf: Reader) throws -> TypesExport {
        return try TypesExport(
            typesHash: FfiConverterSequenceUInt8.read(from: buf),
            signedBy: VerifierValue.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterSequenceUInt8.write(typesHash, into: buf)
        signedBy.write(into: buf)
    }
}

extension TypesExport: ViaFfiUsingByteBuffer, ViaFfi {}

public struct SignDisplay {
    public var transaction: [UInt8]
    public var networkName: String
    public var signedBy: VerifierValue
    public var userComment: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(transaction: [UInt8], networkName: String, signedBy: VerifierValue, userComment: String) {
        self.transaction = transaction
        self.networkName = networkName
        self.signedBy = signedBy
        self.userComment = userComment
    }
}

extension SignDisplay: Equatable, Hashable {
    public static func == (lhs: SignDisplay, rhs: SignDisplay) -> Bool {
        if lhs.transaction != rhs.transaction {
            return false
        }
        if lhs.networkName != rhs.networkName {
            return false
        }
        if lhs.signedBy != rhs.signedBy {
            return false
        }
        if lhs.userComment != rhs.userComment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(transaction)
        hasher.combine(networkName)
        hasher.combine(signedBy)
        hasher.combine(userComment)
    }
}

private extension SignDisplay {
    static func read(from buf: Reader) throws -> SignDisplay {
        return try SignDisplay(
            transaction: FfiConverterSequenceUInt8.read(from: buf),
            networkName: String.read(from: buf),
            signedBy: VerifierValue.read(from: buf),
            userComment: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterSequenceUInt8.write(transaction, into: buf)
        networkName.write(into: buf)
        signedBy.write(into: buf)
        userComment.write(into: buf)
    }
}

extension SignDisplay: ViaFfiUsingByteBuffer, ViaFfi {}

public struct SignMessageDisplay {
    public var message: String
    public var networkName: String
    public var signedBy: VerifierValue
    public var userComment: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(message: String, networkName: String, signedBy: VerifierValue, userComment: String) {
        self.message = message
        self.networkName = networkName
        self.signedBy = signedBy
        self.userComment = userComment
    }
}

extension SignMessageDisplay: Equatable, Hashable {
    public static func == (lhs: SignMessageDisplay, rhs: SignMessageDisplay) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        if lhs.networkName != rhs.networkName {
            return false
        }
        if lhs.signedBy != rhs.signedBy {
            return false
        }
        if lhs.userComment != rhs.userComment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
        hasher.combine(networkName)
        hasher.combine(signedBy)
        hasher.combine(userComment)
    }
}

private extension SignMessageDisplay {
    static func read(from buf: Reader) throws -> SignMessageDisplay {
        return try SignMessageDisplay(
            message: String.read(from: buf),
            networkName: String.read(from: buf),
            signedBy: VerifierValue.read(from: buf),
            userComment: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        message.write(into: buf)
        networkName.write(into: buf)
        signedBy.write(into: buf)
        userComment.write(into: buf)
    }
}

extension SignMessageDisplay: ViaFfiUsingByteBuffer, ViaFfi {}

public struct IdentityHistory {
    public var seedName: String
    public var encryption: Encryption
    public var publicKey: [UInt8]
    public var path: String
    public var networkGenesisHash: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(seedName: String, encryption: Encryption, publicKey: [UInt8], path: String, networkGenesisHash: [UInt8]) {
        self.seedName = seedName
        self.encryption = encryption
        self.publicKey = publicKey
        self.path = path
        self.networkGenesisHash = networkGenesisHash
    }
}

extension IdentityHistory: Equatable, Hashable {
    public static func == (lhs: IdentityHistory, rhs: IdentityHistory) -> Bool {
        if lhs.seedName != rhs.seedName {
            return false
        }
        if lhs.encryption != rhs.encryption {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.networkGenesisHash != rhs.networkGenesisHash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(seedName)
        hasher.combine(encryption)
        hasher.combine(publicKey)
        hasher.combine(path)
        hasher.combine(networkGenesisHash)
    }
}

private extension IdentityHistory {
    static func read(from buf: Reader) throws -> IdentityHistory {
        return try IdentityHistory(
            seedName: String.read(from: buf),
            encryption: Encryption.read(from: buf),
            publicKey: FfiConverterSequenceUInt8.read(from: buf),
            path: String.read(from: buf),
            networkGenesisHash: FfiConverterSequenceUInt8.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        seedName.write(into: buf)
        encryption.write(into: buf)
        FfiConverterSequenceUInt8.write(publicKey, into: buf)
        path.write(into: buf)
        FfiConverterSequenceUInt8.write(networkGenesisHash, into: buf)
    }
}

extension IdentityHistory: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MetaValuesExport {
    public var name: String
    public var version: UInt32
    public var metaHash: [UInt8]
    public var signedBy: VerifierValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, version: UInt32, metaHash: [UInt8], signedBy: VerifierValue) {
        self.name = name
        self.version = version
        self.metaHash = metaHash
        self.signedBy = signedBy
    }
}

extension MetaValuesExport: Equatable, Hashable {
    public static func == (lhs: MetaValuesExport, rhs: MetaValuesExport) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.metaHash != rhs.metaHash {
            return false
        }
        if lhs.signedBy != rhs.signedBy {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(version)
        hasher.combine(metaHash)
        hasher.combine(signedBy)
    }
}

private extension MetaValuesExport {
    static func read(from buf: Reader) throws -> MetaValuesExport {
        return try MetaValuesExport(
            name: String.read(from: buf),
            version: UInt32.read(from: buf),
            metaHash: FfiConverterSequenceUInt8.read(from: buf),
            signedBy: VerifierValue.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        name.write(into: buf)
        version.write(into: buf)
        FfiConverterSequenceUInt8.write(metaHash, into: buf)
        signedBy.write(into: buf)
    }
}

extension MetaValuesExport: ViaFfiUsingByteBuffer, ViaFfi {}

public struct ActionResult {
    public var screenLabel: String
    public var back: Bool
    public var footer: Bool
    public var footerButton: FooterButton?
    public var rightButton: RightButton?
    public var screenNameType: ScreenNameType
    public var screenData: ScreenData
    public var modalData: ModalData?
    public var alertData: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(screenLabel: String, back: Bool, footer: Bool, footerButton: FooterButton?, rightButton: RightButton?, screenNameType: ScreenNameType, screenData: ScreenData, modalData: ModalData?, alertData: String?) {
        self.screenLabel = screenLabel
        self.back = back
        self.footer = footer
        self.footerButton = footerButton
        self.rightButton = rightButton
        self.screenNameType = screenNameType
        self.screenData = screenData
        self.modalData = modalData
        self.alertData = alertData
    }
}

extension ActionResult: Equatable, Hashable {
    public static func == (lhs: ActionResult, rhs: ActionResult) -> Bool {
        if lhs.screenLabel != rhs.screenLabel {
            return false
        }
        if lhs.back != rhs.back {
            return false
        }
        if lhs.footer != rhs.footer {
            return false
        }
        if lhs.footerButton != rhs.footerButton {
            return false
        }
        if lhs.rightButton != rhs.rightButton {
            return false
        }
        if lhs.screenNameType != rhs.screenNameType {
            return false
        }
        if lhs.screenData != rhs.screenData {
            return false
        }
        if lhs.modalData != rhs.modalData {
            return false
        }
        if lhs.alertData != rhs.alertData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(screenLabel)
        hasher.combine(back)
        hasher.combine(footer)
        hasher.combine(footerButton)
        hasher.combine(rightButton)
        hasher.combine(screenNameType)
        hasher.combine(screenData)
        hasher.combine(modalData)
        hasher.combine(alertData)
    }
}

private extension ActionResult {
    static func read(from buf: Reader) throws -> ActionResult {
        return try ActionResult(
            screenLabel: String.read(from: buf),
            back: Bool.read(from: buf),
            footer: Bool.read(from: buf),
            footerButton: FfiConverterOptionEnumFooterButton.read(from: buf),
            rightButton: FfiConverterOptionEnumRightButton.read(from: buf),
            screenNameType: ScreenNameType.read(from: buf),
            screenData: ScreenData.read(from: buf),
            modalData: FfiConverterOptionEnumModalData.read(from: buf),
            alertData: FfiConverterOptionString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        screenLabel.write(into: buf)
        back.write(into: buf)
        footer.write(into: buf)
        FfiConverterOptionEnumFooterButton.write(footerButton, into: buf)
        FfiConverterOptionEnumRightButton.write(rightButton, into: buf)
        screenNameType.write(into: buf)
        screenData.write(into: buf)
        FfiConverterOptionEnumModalData.write(modalData, into: buf)
        FfiConverterOptionString.write(alertData, into: buf)
    }
}

extension ActionResult: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MetaValues {
    public var name: String
    public var version: UInt32
    public var optionalBase58prefix: UInt16?
    public var warnIncompleteExtensions: Bool
    public var meta: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, version: UInt32, optionalBase58prefix: UInt16?, warnIncompleteExtensions: Bool, meta: [UInt8]) {
        self.name = name
        self.version = version
        self.optionalBase58prefix = optionalBase58prefix
        self.warnIncompleteExtensions = warnIncompleteExtensions
        self.meta = meta
    }
}

extension MetaValues: Equatable, Hashable {
    public static func == (lhs: MetaValues, rhs: MetaValues) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.optionalBase58prefix != rhs.optionalBase58prefix {
            return false
        }
        if lhs.warnIncompleteExtensions != rhs.warnIncompleteExtensions {
            return false
        }
        if lhs.meta != rhs.meta {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(version)
        hasher.combine(optionalBase58prefix)
        hasher.combine(warnIncompleteExtensions)
        hasher.combine(meta)
    }
}

private extension MetaValues {
    static func read(from buf: Reader) throws -> MetaValues {
        return try MetaValues(
            name: String.read(from: buf),
            version: UInt32.read(from: buf),
            optionalBase58prefix: FfiConverterOptionUInt16.read(from: buf),
            warnIncompleteExtensions: Bool.read(from: buf),
            meta: FfiConverterSequenceUInt8.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        name.write(into: buf)
        version.write(into: buf)
        FfiConverterOptionUInt16.write(optionalBase58prefix, into: buf)
        warnIncompleteExtensions.write(into: buf)
        FfiConverterSequenceUInt8.write(meta, into: buf)
    }
}

extension MetaValues: ViaFfiUsingByteBuffer, ViaFfi {}

public struct Identity {
    public var seedName: String
    public var addressKey: String
    public var publicKey: String
    public var identicon: String
    public var hasPwd: Bool
    public var path: String
    public var isMultiselect: Bool
    public var base58: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(seedName: String, addressKey: String, publicKey: String, identicon: String, hasPwd: Bool, path: String, isMultiselect: Bool, base58: String) {
        self.seedName = seedName
        self.addressKey = addressKey
        self.publicKey = publicKey
        self.identicon = identicon
        self.hasPwd = hasPwd
        self.path = path
        self.isMultiselect = isMultiselect
        self.base58 = base58
    }
}

extension Identity: Equatable, Hashable {
    public static func == (lhs: Identity, rhs: Identity) -> Bool {
        if lhs.seedName != rhs.seedName {
            return false
        }
        if lhs.addressKey != rhs.addressKey {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.identicon != rhs.identicon {
            return false
        }
        if lhs.hasPwd != rhs.hasPwd {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.isMultiselect != rhs.isMultiselect {
            return false
        }
        if lhs.base58 != rhs.base58 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(seedName)
        hasher.combine(addressKey)
        hasher.combine(publicKey)
        hasher.combine(identicon)
        hasher.combine(hasPwd)
        hasher.combine(path)
        hasher.combine(isMultiselect)
        hasher.combine(base58)
    }
}

private extension Identity {
    static func read(from buf: Reader) throws -> Identity {
        return try Identity(
            seedName: String.read(from: buf),
            addressKey: String.read(from: buf),
            publicKey: String.read(from: buf),
            identicon: String.read(from: buf),
            hasPwd: Bool.read(from: buf),
            path: String.read(from: buf),
            isMultiselect: Bool.read(from: buf),
            base58: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        seedName.write(into: buf)
        addressKey.write(into: buf)
        publicKey.write(into: buf)
        identicon.write(into: buf)
        hasPwd.write(into: buf)
        path.write(into: buf)
        isMultiselect.write(into: buf)
        base58.write(into: buf)
    }
}

extension Identity: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MSeedKeyCard {
    public var seedName: String
    public var identicon: String
    public var addressKey: String
    public var base58: String
    public var swiped: Bool
    public var multiselect: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(seedName: String, identicon: String, addressKey: String, base58: String, swiped: Bool, multiselect: Bool) {
        self.seedName = seedName
        self.identicon = identicon
        self.addressKey = addressKey
        self.base58 = base58
        self.swiped = swiped
        self.multiselect = multiselect
    }
}

extension MSeedKeyCard: Equatable, Hashable {
    public static func == (lhs: MSeedKeyCard, rhs: MSeedKeyCard) -> Bool {
        if lhs.seedName != rhs.seedName {
            return false
        }
        if lhs.identicon != rhs.identicon {
            return false
        }
        if lhs.addressKey != rhs.addressKey {
            return false
        }
        if lhs.base58 != rhs.base58 {
            return false
        }
        if lhs.swiped != rhs.swiped {
            return false
        }
        if lhs.multiselect != rhs.multiselect {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(seedName)
        hasher.combine(identicon)
        hasher.combine(addressKey)
        hasher.combine(base58)
        hasher.combine(swiped)
        hasher.combine(multiselect)
    }
}

private extension MSeedKeyCard {
    static func read(from buf: Reader) throws -> MSeedKeyCard {
        return try MSeedKeyCard(
            seedName: String.read(from: buf),
            identicon: String.read(from: buf),
            addressKey: String.read(from: buf),
            base58: String.read(from: buf),
            swiped: Bool.read(from: buf),
            multiselect: Bool.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        seedName.write(into: buf)
        identicon.write(into: buf)
        addressKey.write(into: buf)
        base58.write(into: buf)
        swiped.write(into: buf)
        multiselect.write(into: buf)
    }
}

extension MSeedKeyCard: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MNetworkCard {
    public var title: String
    public var logo: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(title: String, logo: String) {
        self.title = title
        self.logo = logo
    }
}

extension MNetworkCard: Equatable, Hashable {
    public static func == (lhs: MNetworkCard, rhs: MNetworkCard) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.logo != rhs.logo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(logo)
    }
}

private extension MNetworkCard {
    static func read(from buf: Reader) throws -> MNetworkCard {
        return try MNetworkCard(
            title: String.read(from: buf),
            logo: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        title.write(into: buf)
        logo.write(into: buf)
    }
}

extension MNetworkCard: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MKeys {
    public var set: [MKeysCard]
    public var root: MSeedKeyCard
    public var network: MNetworkCard
    public var multiselectMode: Bool
    public var multiselectCount: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(set: [MKeysCard], root: MSeedKeyCard, network: MNetworkCard, multiselectMode: Bool, multiselectCount: String) {
        self.set = set
        self.root = root
        self.network = network
        self.multiselectMode = multiselectMode
        self.multiselectCount = multiselectCount
    }
}

extension MKeys: Equatable, Hashable {
    public static func == (lhs: MKeys, rhs: MKeys) -> Bool {
        if lhs.set != rhs.set {
            return false
        }
        if lhs.root != rhs.root {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        if lhs.multiselectMode != rhs.multiselectMode {
            return false
        }
        if lhs.multiselectCount != rhs.multiselectCount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(set)
        hasher.combine(root)
        hasher.combine(network)
        hasher.combine(multiselectMode)
        hasher.combine(multiselectCount)
    }
}

private extension MKeys {
    static func read(from buf: Reader) throws -> MKeys {
        return try MKeys(
            set: FfiConverterSequenceRecordMKeysCard.read(from: buf),
            root: MSeedKeyCard.read(from: buf),
            network: MNetworkCard.read(from: buf),
            multiselectMode: Bool.read(from: buf),
            multiselectCount: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterSequenceRecordMKeysCard.write(set, into: buf)
        root.write(into: buf)
        network.write(into: buf)
        multiselectMode.write(into: buf)
        multiselectCount.write(into: buf)
    }
}

extension MKeys: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MKeysCard {
    public var addressKey: String
    public var base58: String
    public var identicon: String
    public var hasPwd: Bool
    public var path: String
    public var swiped: Bool
    public var multiselect: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(addressKey: String, base58: String, identicon: String, hasPwd: Bool, path: String, swiped: Bool, multiselect: Bool) {
        self.addressKey = addressKey
        self.base58 = base58
        self.identicon = identicon
        self.hasPwd = hasPwd
        self.path = path
        self.swiped = swiped
        self.multiselect = multiselect
    }
}

extension MKeysCard: Equatable, Hashable {
    public static func == (lhs: MKeysCard, rhs: MKeysCard) -> Bool {
        if lhs.addressKey != rhs.addressKey {
            return false
        }
        if lhs.base58 != rhs.base58 {
            return false
        }
        if lhs.identicon != rhs.identicon {
            return false
        }
        if lhs.hasPwd != rhs.hasPwd {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.swiped != rhs.swiped {
            return false
        }
        if lhs.multiselect != rhs.multiselect {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(addressKey)
        hasher.combine(base58)
        hasher.combine(identicon)
        hasher.combine(hasPwd)
        hasher.combine(path)
        hasher.combine(swiped)
        hasher.combine(multiselect)
    }
}

private extension MKeysCard {
    static func read(from buf: Reader) throws -> MKeysCard {
        return try MKeysCard(
            addressKey: String.read(from: buf),
            base58: String.read(from: buf),
            identicon: String.read(from: buf),
            hasPwd: Bool.read(from: buf),
            path: String.read(from: buf),
            swiped: Bool.read(from: buf),
            multiselect: Bool.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        addressKey.write(into: buf)
        base58.write(into: buf)
        identicon.write(into: buf)
        hasPwd.write(into: buf)
        path.write(into: buf)
        swiped.write(into: buf)
        multiselect.write(into: buf)
    }
}

extension MKeysCard: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MSettings {
    public var publicKey: String?
    public var identicon: String?
    public var encryption: String?
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKey: String?, identicon: String?, encryption: String?, error: String?) {
        self.publicKey = publicKey
        self.identicon = identicon
        self.encryption = encryption
        self.error = error
    }
}

extension MSettings: Equatable, Hashable {
    public static func == (lhs: MSettings, rhs: MSettings) -> Bool {
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.identicon != rhs.identicon {
            return false
        }
        if lhs.encryption != rhs.encryption {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKey)
        hasher.combine(identicon)
        hasher.combine(encryption)
        hasher.combine(error)
    }
}

private extension MSettings {
    static func read(from buf: Reader) throws -> MSettings {
        return try MSettings(
            publicKey: FfiConverterOptionString.read(from: buf),
            identicon: FfiConverterOptionString.read(from: buf),
            encryption: FfiConverterOptionString.read(from: buf),
            error: FfiConverterOptionString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterOptionString.write(publicKey, into: buf)
        FfiConverterOptionString.write(identicon, into: buf)
        FfiConverterOptionString.write(encryption, into: buf)
        FfiConverterOptionString.write(error, into: buf)
    }
}

extension MSettings: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MLog {
    public var log: [History]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(log: [History]) {
        self.log = log
    }
}

extension MLog: Equatable, Hashable {
    public static func == (lhs: MLog, rhs: MLog) -> Bool {
        if lhs.log != rhs.log {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(log)
    }
}

private extension MLog {
    static func read(from buf: Reader) throws -> MLog {
        return try MLog(
            log: FfiConverterSequenceRecordHistory.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterSequenceRecordHistory.write(log, into: buf)
    }
}

extension MLog: ViaFfiUsingByteBuffer, ViaFfi {}

public struct History {
    public var timestamp: String
    public var events: [Event]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(timestamp: String, events: [Event]) {
        self.timestamp = timestamp
        self.events = events
    }
}

extension History: Equatable, Hashable {
    public static func == (lhs: History, rhs: History) -> Bool {
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.events != rhs.events {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(timestamp)
        hasher.combine(events)
    }
}

private extension History {
    static func read(from buf: Reader) throws -> History {
        return try History(
            timestamp: String.read(from: buf),
            events: FfiConverterSequenceEnumEvent.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        timestamp.write(into: buf)
        FfiConverterSequenceEnumEvent.write(events, into: buf)
    }
}

extension History: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MLogDetails {
    public var timestamp: String
    public var events: [Event]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(timestamp: String, events: [Event]) {
        self.timestamp = timestamp
        self.events = events
    }
}

extension MLogDetails: Equatable, Hashable {
    public static func == (lhs: MLogDetails, rhs: MLogDetails) -> Bool {
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.events != rhs.events {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(timestamp)
        hasher.combine(events)
    }
}

private extension MLogDetails {
    static func read(from buf: Reader) throws -> MLogDetails {
        return try MLogDetails(
            timestamp: String.read(from: buf),
            events: FfiConverterSequenceEnumEvent.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        timestamp.write(into: buf)
        FfiConverterSequenceEnumEvent.write(events, into: buf)
    }
}

extension MLogDetails: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MTransaction {
    public var content: TransactionCardSet
    public var ttype: TransactionType
    public var authorInfo: TransactionAuthor?
    public var networkInfo: TransactionNetworkInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(content: TransactionCardSet, ttype: TransactionType, authorInfo: TransactionAuthor?, networkInfo: TransactionNetworkInfo?) {
        self.content = content
        self.ttype = ttype
        self.authorInfo = authorInfo
        self.networkInfo = networkInfo
    }
}

extension MTransaction: Equatable, Hashable {
    public static func == (lhs: MTransaction, rhs: MTransaction) -> Bool {
        if lhs.content != rhs.content {
            return false
        }
        if lhs.ttype != rhs.ttype {
            return false
        }
        if lhs.authorInfo != rhs.authorInfo {
            return false
        }
        if lhs.networkInfo != rhs.networkInfo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(content)
        hasher.combine(ttype)
        hasher.combine(authorInfo)
        hasher.combine(networkInfo)
    }
}

private extension MTransaction {
    static func read(from buf: Reader) throws -> MTransaction {
        return try MTransaction(
            content: TransactionCardSet.read(from: buf),
            ttype: TransactionType.read(from: buf),
            authorInfo: FfiConverterOptionRecordTransactionAuthor.read(from: buf),
            networkInfo: FfiConverterOptionRecordTransactionNetworkInfo.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        content.write(into: buf)
        ttype.write(into: buf)
        FfiConverterOptionRecordTransactionAuthor.write(authorInfo, into: buf)
        FfiConverterOptionRecordTransactionNetworkInfo.write(networkInfo, into: buf)
    }
}

extension MTransaction: ViaFfiUsingByteBuffer, ViaFfi {}

public struct TransactionAuthor {
    public var base58: String
    public var identicon: String
    public var seed: String
    public var derivationPath: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(base58: String, identicon: String, seed: String, derivationPath: String) {
        self.base58 = base58
        self.identicon = identicon
        self.seed = seed
        self.derivationPath = derivationPath
    }
}

extension TransactionAuthor: Equatable, Hashable {
    public static func == (lhs: TransactionAuthor, rhs: TransactionAuthor) -> Bool {
        if lhs.base58 != rhs.base58 {
            return false
        }
        if lhs.identicon != rhs.identicon {
            return false
        }
        if lhs.seed != rhs.seed {
            return false
        }
        if lhs.derivationPath != rhs.derivationPath {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(base58)
        hasher.combine(identicon)
        hasher.combine(seed)
        hasher.combine(derivationPath)
    }
}

private extension TransactionAuthor {
    static func read(from buf: Reader) throws -> TransactionAuthor {
        return try TransactionAuthor(
            base58: String.read(from: buf),
            identicon: String.read(from: buf),
            seed: String.read(from: buf),
            derivationPath: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        base58.write(into: buf)
        identicon.write(into: buf)
        seed.write(into: buf)
        derivationPath.write(into: buf)
    }
}

extension TransactionAuthor: ViaFfiUsingByteBuffer, ViaFfi {}

public struct TransactionNetworkInfo {
    public var networkTitle: String
    public var networkLogo: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkTitle: String, networkLogo: String) {
        self.networkTitle = networkTitle
        self.networkLogo = networkLogo
    }
}

extension TransactionNetworkInfo: Equatable, Hashable {
    public static func == (lhs: TransactionNetworkInfo, rhs: TransactionNetworkInfo) -> Bool {
        if lhs.networkTitle != rhs.networkTitle {
            return false
        }
        if lhs.networkLogo != rhs.networkLogo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkTitle)
        hasher.combine(networkLogo)
    }
}

private extension TransactionNetworkInfo {
    static func read(from buf: Reader) throws -> TransactionNetworkInfo {
        return try TransactionNetworkInfo(
            networkTitle: String.read(from: buf),
            networkLogo: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        networkTitle.write(into: buf)
        networkLogo.write(into: buf)
    }
}

extension TransactionNetworkInfo: ViaFfiUsingByteBuffer, ViaFfi {}

public struct TransactionCard {
    public var index: UInt32
    public var indent: UInt32
    public var card: Card

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(index: UInt32, indent: UInt32, card: Card) {
        self.index = index
        self.indent = indent
        self.card = card
    }
}

extension TransactionCard: Equatable, Hashable {
    public static func == (lhs: TransactionCard, rhs: TransactionCard) -> Bool {
        if lhs.index != rhs.index {
            return false
        }
        if lhs.indent != rhs.indent {
            return false
        }
        if lhs.card != rhs.card {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(index)
        hasher.combine(indent)
        hasher.combine(card)
    }
}

private extension TransactionCard {
    static func read(from buf: Reader) throws -> TransactionCard {
        return try TransactionCard(
            index: UInt32.read(from: buf),
            indent: UInt32.read(from: buf),
            card: Card.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        index.write(into: buf)
        indent.write(into: buf)
        card.write(into: buf)
    }
}

extension TransactionCard: ViaFfiUsingByteBuffer, ViaFfi {}

public struct TransactionCardSet {
    public var author: [TransactionCard]?
    public var error: [TransactionCard]?
    public var extensions: [TransactionCard]?
    public var importingDerivations: [TransactionCard]?
    public var message: [TransactionCard]?
    public var meta: [TransactionCard]?
    public var method: [TransactionCard]?
    public var newSpecs: [TransactionCard]?
    public var verifier: [TransactionCard]?
    public var warning: [TransactionCard]?
    public var typesInfo: [TransactionCard]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(author: [TransactionCard]?, error: [TransactionCard]?, extensions: [TransactionCard]?, importingDerivations: [TransactionCard]?, message: [TransactionCard]?, meta: [TransactionCard]?, method: [TransactionCard]?, newSpecs: [TransactionCard]?, verifier: [TransactionCard]?, warning: [TransactionCard]?, typesInfo: [TransactionCard]?) {
        self.author = author
        self.error = error
        self.extensions = extensions
        self.importingDerivations = importingDerivations
        self.message = message
        self.meta = meta
        self.method = method
        self.newSpecs = newSpecs
        self.verifier = verifier
        self.warning = warning
        self.typesInfo = typesInfo
    }
}

extension TransactionCardSet: Equatable, Hashable {
    public static func == (lhs: TransactionCardSet, rhs: TransactionCardSet) -> Bool {
        if lhs.author != rhs.author {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        if lhs.extensions != rhs.extensions {
            return false
        }
        if lhs.importingDerivations != rhs.importingDerivations {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.meta != rhs.meta {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.newSpecs != rhs.newSpecs {
            return false
        }
        if lhs.verifier != rhs.verifier {
            return false
        }
        if lhs.warning != rhs.warning {
            return false
        }
        if lhs.typesInfo != rhs.typesInfo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(author)
        hasher.combine(error)
        hasher.combine(extensions)
        hasher.combine(importingDerivations)
        hasher.combine(message)
        hasher.combine(meta)
        hasher.combine(method)
        hasher.combine(newSpecs)
        hasher.combine(verifier)
        hasher.combine(warning)
        hasher.combine(typesInfo)
    }
}

private extension TransactionCardSet {
    static func read(from buf: Reader) throws -> TransactionCardSet {
        return try TransactionCardSet(
            author: FfiConverterOptionSequenceRecordTransactionCard.read(from: buf),
            error: FfiConverterOptionSequenceRecordTransactionCard.read(from: buf),
            extensions: FfiConverterOptionSequenceRecordTransactionCard.read(from: buf),
            importingDerivations: FfiConverterOptionSequenceRecordTransactionCard.read(from: buf),
            message: FfiConverterOptionSequenceRecordTransactionCard.read(from: buf),
            meta: FfiConverterOptionSequenceRecordTransactionCard.read(from: buf),
            method: FfiConverterOptionSequenceRecordTransactionCard.read(from: buf),
            newSpecs: FfiConverterOptionSequenceRecordTransactionCard.read(from: buf),
            verifier: FfiConverterOptionSequenceRecordTransactionCard.read(from: buf),
            warning: FfiConverterOptionSequenceRecordTransactionCard.read(from: buf),
            typesInfo: FfiConverterOptionSequenceRecordTransactionCard.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterOptionSequenceRecordTransactionCard.write(author, into: buf)
        FfiConverterOptionSequenceRecordTransactionCard.write(error, into: buf)
        FfiConverterOptionSequenceRecordTransactionCard.write(extensions, into: buf)
        FfiConverterOptionSequenceRecordTransactionCard.write(importingDerivations, into: buf)
        FfiConverterOptionSequenceRecordTransactionCard.write(message, into: buf)
        FfiConverterOptionSequenceRecordTransactionCard.write(meta, into: buf)
        FfiConverterOptionSequenceRecordTransactionCard.write(method, into: buf)
        FfiConverterOptionSequenceRecordTransactionCard.write(newSpecs, into: buf)
        FfiConverterOptionSequenceRecordTransactionCard.write(verifier, into: buf)
        FfiConverterOptionSequenceRecordTransactionCard.write(warning, into: buf)
        FfiConverterOptionSequenceRecordTransactionCard.write(typesInfo, into: buf)
    }
}

extension TransactionCardSet: ViaFfiUsingByteBuffer, ViaFfi {}

public struct SeedNameCard {
    public var seedName: String
    public var identicon: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(seedName: String, identicon: String) {
        self.seedName = seedName
        self.identicon = identicon
    }
}

extension SeedNameCard: Equatable, Hashable {
    public static func == (lhs: SeedNameCard, rhs: SeedNameCard) -> Bool {
        if lhs.seedName != rhs.seedName {
            return false
        }
        if lhs.identicon != rhs.identicon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(seedName)
        hasher.combine(identicon)
    }
}

private extension SeedNameCard {
    static func read(from buf: Reader) throws -> SeedNameCard {
        return try SeedNameCard(
            seedName: String.read(from: buf),
            identicon: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        seedName.write(into: buf)
        identicon.write(into: buf)
    }
}

extension SeedNameCard: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MSeeds {
    public var seedNameCards: [SeedNameCard]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(seedNameCards: [SeedNameCard]) {
        self.seedNameCards = seedNameCards
    }
}

extension MSeeds: Equatable, Hashable {
    public static func == (lhs: MSeeds, rhs: MSeeds) -> Bool {
        if lhs.seedNameCards != rhs.seedNameCards {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(seedNameCards)
    }
}

private extension MSeeds {
    static func read(from buf: Reader) throws -> MSeeds {
        return try MSeeds(
            seedNameCards: FfiConverterSequenceRecordSeedNameCard.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterSequenceRecordSeedNameCard.write(seedNameCards, into: buf)
    }
}

extension MSeeds: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MKeyDetails {
    public var qr: String
    public var pubkey: String
    public var base58: String
    public var identicon: String
    public var seedName: String
    public var path: String
    public var networkTitle: String
    public var networkLogo: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(qr: String, pubkey: String, base58: String, identicon: String, seedName: String, path: String, networkTitle: String, networkLogo: String) {
        self.qr = qr
        self.pubkey = pubkey
        self.base58 = base58
        self.identicon = identicon
        self.seedName = seedName
        self.path = path
        self.networkTitle = networkTitle
        self.networkLogo = networkLogo
    }
}

extension MKeyDetails: Equatable, Hashable {
    public static func == (lhs: MKeyDetails, rhs: MKeyDetails) -> Bool {
        if lhs.qr != rhs.qr {
            return false
        }
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.base58 != rhs.base58 {
            return false
        }
        if lhs.identicon != rhs.identicon {
            return false
        }
        if lhs.seedName != rhs.seedName {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.networkTitle != rhs.networkTitle {
            return false
        }
        if lhs.networkLogo != rhs.networkLogo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(qr)
        hasher.combine(pubkey)
        hasher.combine(base58)
        hasher.combine(identicon)
        hasher.combine(seedName)
        hasher.combine(path)
        hasher.combine(networkTitle)
        hasher.combine(networkLogo)
    }
}

private extension MKeyDetails {
    static func read(from buf: Reader) throws -> MKeyDetails {
        return try MKeyDetails(
            qr: String.read(from: buf),
            pubkey: String.read(from: buf),
            base58: String.read(from: buf),
            identicon: String.read(from: buf),
            seedName: String.read(from: buf),
            path: String.read(from: buf),
            networkTitle: String.read(from: buf),
            networkLogo: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        qr.write(into: buf)
        pubkey.write(into: buf)
        base58.write(into: buf)
        identicon.write(into: buf)
        seedName.write(into: buf)
        path.write(into: buf)
        networkTitle.write(into: buf)
        networkLogo.write(into: buf)
    }
}

extension MKeyDetails: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MNewSeed {
    public var keyboard: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(keyboard: Bool) {
        self.keyboard = keyboard
    }
}

extension MNewSeed: Equatable, Hashable {
    public static func == (lhs: MNewSeed, rhs: MNewSeed) -> Bool {
        if lhs.keyboard != rhs.keyboard {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(keyboard)
    }
}

private extension MNewSeed {
    static func read(from buf: Reader) throws -> MNewSeed {
        return try MNewSeed(
            keyboard: Bool.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        keyboard.write(into: buf)
    }
}

extension MNewSeed: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MRecoverSeedName {
    public var keyboard: Bool
    public var seedName: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(keyboard: Bool, seedName: String) {
        self.keyboard = keyboard
        self.seedName = seedName
    }
}

extension MRecoverSeedName: Equatable, Hashable {
    public static func == (lhs: MRecoverSeedName, rhs: MRecoverSeedName) -> Bool {
        if lhs.keyboard != rhs.keyboard {
            return false
        }
        if lhs.seedName != rhs.seedName {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(keyboard)
        hasher.combine(seedName)
    }
}

private extension MRecoverSeedName {
    static func read(from buf: Reader) throws -> MRecoverSeedName {
        return try MRecoverSeedName(
            keyboard: Bool.read(from: buf),
            seedName: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        keyboard.write(into: buf)
        seedName.write(into: buf)
    }
}

extension MRecoverSeedName: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MRecoverSeedPhrase {
    public var keyboard: Bool
    public var seedName: String
    public var userInput: String
    public var guessSet: [String]
    public var draft: [String]
    public var readySeed: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(keyboard: Bool, seedName: String, userInput: String, guessSet: [String], draft: [String], readySeed: String?) {
        self.keyboard = keyboard
        self.seedName = seedName
        self.userInput = userInput
        self.guessSet = guessSet
        self.draft = draft
        self.readySeed = readySeed
    }
}

extension MRecoverSeedPhrase: Equatable, Hashable {
    public static func == (lhs: MRecoverSeedPhrase, rhs: MRecoverSeedPhrase) -> Bool {
        if lhs.keyboard != rhs.keyboard {
            return false
        }
        if lhs.seedName != rhs.seedName {
            return false
        }
        if lhs.userInput != rhs.userInput {
            return false
        }
        if lhs.guessSet != rhs.guessSet {
            return false
        }
        if lhs.draft != rhs.draft {
            return false
        }
        if lhs.readySeed != rhs.readySeed {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(keyboard)
        hasher.combine(seedName)
        hasher.combine(userInput)
        hasher.combine(guessSet)
        hasher.combine(draft)
        hasher.combine(readySeed)
    }
}

private extension MRecoverSeedPhrase {
    static func read(from buf: Reader) throws -> MRecoverSeedPhrase {
        return try MRecoverSeedPhrase(
            keyboard: Bool.read(from: buf),
            seedName: String.read(from: buf),
            userInput: String.read(from: buf),
            guessSet: FfiConverterSequenceString.read(from: buf),
            draft: FfiConverterSequenceString.read(from: buf),
            readySeed: FfiConverterOptionString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        keyboard.write(into: buf)
        seedName.write(into: buf)
        userInput.write(into: buf)
        FfiConverterSequenceString.write(guessSet, into: buf)
        FfiConverterSequenceString.write(draft, into: buf)
        FfiConverterOptionString.write(readySeed, into: buf)
    }
}

extension MRecoverSeedPhrase: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MDeriveKey {
    public var seedName: String
    public var networkTitle: String
    public var networkLogo: String
    public var networkSpecsKey: String
    public var suggestedDerivation: String
    public var keyboard: Bool
    public var derivationCheck: DerivationCheck?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(seedName: String, networkTitle: String, networkLogo: String, networkSpecsKey: String, suggestedDerivation: String, keyboard: Bool, derivationCheck: DerivationCheck?) {
        self.seedName = seedName
        self.networkTitle = networkTitle
        self.networkLogo = networkLogo
        self.networkSpecsKey = networkSpecsKey
        self.suggestedDerivation = suggestedDerivation
        self.keyboard = keyboard
        self.derivationCheck = derivationCheck
    }
}

extension MDeriveKey: Equatable, Hashable {
    public static func == (lhs: MDeriveKey, rhs: MDeriveKey) -> Bool {
        if lhs.seedName != rhs.seedName {
            return false
        }
        if lhs.networkTitle != rhs.networkTitle {
            return false
        }
        if lhs.networkLogo != rhs.networkLogo {
            return false
        }
        if lhs.networkSpecsKey != rhs.networkSpecsKey {
            return false
        }
        if lhs.suggestedDerivation != rhs.suggestedDerivation {
            return false
        }
        if lhs.keyboard != rhs.keyboard {
            return false
        }
        if lhs.derivationCheck != rhs.derivationCheck {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(seedName)
        hasher.combine(networkTitle)
        hasher.combine(networkLogo)
        hasher.combine(networkSpecsKey)
        hasher.combine(suggestedDerivation)
        hasher.combine(keyboard)
        hasher.combine(derivationCheck)
    }
}

private extension MDeriveKey {
    static func read(from buf: Reader) throws -> MDeriveKey {
        return try MDeriveKey(
            seedName: String.read(from: buf),
            networkTitle: String.read(from: buf),
            networkLogo: String.read(from: buf),
            networkSpecsKey: String.read(from: buf),
            suggestedDerivation: String.read(from: buf),
            keyboard: Bool.read(from: buf),
            derivationCheck: FfiConverterOptionRecordDerivationCheck.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        seedName.write(into: buf)
        networkTitle.write(into: buf)
        networkLogo.write(into: buf)
        networkSpecsKey.write(into: buf)
        suggestedDerivation.write(into: buf)
        keyboard.write(into: buf)
        FfiConverterOptionRecordDerivationCheck.write(derivationCheck, into: buf)
    }
}

extension MDeriveKey: ViaFfiUsingByteBuffer, ViaFfi {}

public struct DerivationCheck {
    public var buttonGood: Bool
    public var whereTo: DerivationDestination?
    public var collision: Address?
    public var error: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(buttonGood: Bool, whereTo: DerivationDestination?, collision: Address?, error: String?) {
        self.buttonGood = buttonGood
        self.whereTo = whereTo
        self.collision = collision
        self.error = error
    }
}

extension DerivationCheck: Equatable, Hashable {
    public static func == (lhs: DerivationCheck, rhs: DerivationCheck) -> Bool {
        if lhs.buttonGood != rhs.buttonGood {
            return false
        }
        if lhs.whereTo != rhs.whereTo {
            return false
        }
        if lhs.collision != rhs.collision {
            return false
        }
        if lhs.error != rhs.error {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(buttonGood)
        hasher.combine(whereTo)
        hasher.combine(collision)
        hasher.combine(error)
    }
}

private extension DerivationCheck {
    static func read(from buf: Reader) throws -> DerivationCheck {
        return try DerivationCheck(
            buttonGood: Bool.read(from: buf),
            whereTo: FfiConverterOptionEnumDerivationDestination.read(from: buf),
            collision: FfiConverterOptionRecordAddress.read(from: buf),
            error: FfiConverterOptionString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        buttonGood.write(into: buf)
        FfiConverterOptionEnumDerivationDestination.write(whereTo, into: buf)
        FfiConverterOptionRecordAddress.write(collision, into: buf)
        FfiConverterOptionString.write(error, into: buf)
    }
}

extension DerivationCheck: ViaFfiUsingByteBuffer, ViaFfi {}

public struct Address {
    public var base58: String
    public var path: String
    public var hasPwd: Bool
    public var identicon: String
    public var seedName: String
    public var multiselect: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(base58: String, path: String, hasPwd: Bool, identicon: String, seedName: String, multiselect: Bool?) {
        self.base58 = base58
        self.path = path
        self.hasPwd = hasPwd
        self.identicon = identicon
        self.seedName = seedName
        self.multiselect = multiselect
    }
}

extension Address: Equatable, Hashable {
    public static func == (lhs: Address, rhs: Address) -> Bool {
        if lhs.base58 != rhs.base58 {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        if lhs.hasPwd != rhs.hasPwd {
            return false
        }
        if lhs.identicon != rhs.identicon {
            return false
        }
        if lhs.seedName != rhs.seedName {
            return false
        }
        if lhs.multiselect != rhs.multiselect {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(base58)
        hasher.combine(path)
        hasher.combine(hasPwd)
        hasher.combine(identicon)
        hasher.combine(seedName)
        hasher.combine(multiselect)
    }
}

private extension Address {
    static func read(from buf: Reader) throws -> Address {
        return try Address(
            base58: String.read(from: buf),
            path: String.read(from: buf),
            hasPwd: Bool.read(from: buf),
            identicon: String.read(from: buf),
            seedName: String.read(from: buf),
            multiselect: FfiConverterOptionBool.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        base58.write(into: buf)
        path.write(into: buf)
        hasPwd.write(into: buf)
        identicon.write(into: buf)
        seedName.write(into: buf)
        FfiConverterOptionBool.write(multiselect, into: buf)
    }
}

extension Address: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MVerifierDetails {
    public var publicKey: String
    public var identicon: String
    public var encryption: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKey: String, identicon: String, encryption: String) {
        self.publicKey = publicKey
        self.identicon = identicon
        self.encryption = encryption
    }
}

extension MVerifierDetails: Equatable, Hashable {
    public static func == (lhs: MVerifierDetails, rhs: MVerifierDetails) -> Bool {
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.identicon != rhs.identicon {
            return false
        }
        if lhs.encryption != rhs.encryption {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKey)
        hasher.combine(identicon)
        hasher.combine(encryption)
    }
}

private extension MVerifierDetails {
    static func read(from buf: Reader) throws -> MVerifierDetails {
        return try MVerifierDetails(
            publicKey: String.read(from: buf),
            identicon: String.read(from: buf),
            encryption: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        publicKey.write(into: buf)
        identicon.write(into: buf)
        encryption.write(into: buf)
    }
}

extension MVerifierDetails: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MNetworkDetails {
    public var base58prefix: UInt16
    public var color: String
    public var decimals: UInt8
    public var encryption: Encryption
    public var genesisHash: String
    public var logo: String
    public var name: String
    public var order: String
    public var pathId: String
    public var secondaryColor: String
    public var title: String
    public var unit: String
    public var currentVerifier: MVerifier
    public var meta: [MMetadataRecord]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(base58prefix: UInt16, color: String, decimals: UInt8, encryption: Encryption, genesisHash: String, logo: String, name: String, order: String, pathId: String, secondaryColor: String, title: String, unit: String, currentVerifier: MVerifier, meta: [MMetadataRecord]) {
        self.base58prefix = base58prefix
        self.color = color
        self.decimals = decimals
        self.encryption = encryption
        self.genesisHash = genesisHash
        self.logo = logo
        self.name = name
        self.order = order
        self.pathId = pathId
        self.secondaryColor = secondaryColor
        self.title = title
        self.unit = unit
        self.currentVerifier = currentVerifier
        self.meta = meta
    }
}

extension MNetworkDetails: Equatable, Hashable {
    public static func == (lhs: MNetworkDetails, rhs: MNetworkDetails) -> Bool {
        if lhs.base58prefix != rhs.base58prefix {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.decimals != rhs.decimals {
            return false
        }
        if lhs.encryption != rhs.encryption {
            return false
        }
        if lhs.genesisHash != rhs.genesisHash {
            return false
        }
        if lhs.logo != rhs.logo {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.order != rhs.order {
            return false
        }
        if lhs.pathId != rhs.pathId {
            return false
        }
        if lhs.secondaryColor != rhs.secondaryColor {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.unit != rhs.unit {
            return false
        }
        if lhs.currentVerifier != rhs.currentVerifier {
            return false
        }
        if lhs.meta != rhs.meta {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(base58prefix)
        hasher.combine(color)
        hasher.combine(decimals)
        hasher.combine(encryption)
        hasher.combine(genesisHash)
        hasher.combine(logo)
        hasher.combine(name)
        hasher.combine(order)
        hasher.combine(pathId)
        hasher.combine(secondaryColor)
        hasher.combine(title)
        hasher.combine(unit)
        hasher.combine(currentVerifier)
        hasher.combine(meta)
    }
}

private extension MNetworkDetails {
    static func read(from buf: Reader) throws -> MNetworkDetails {
        return try MNetworkDetails(
            base58prefix: UInt16.read(from: buf),
            color: String.read(from: buf),
            decimals: UInt8.read(from: buf),
            encryption: Encryption.read(from: buf),
            genesisHash: String.read(from: buf),
            logo: String.read(from: buf),
            name: String.read(from: buf),
            order: String.read(from: buf),
            pathId: String.read(from: buf),
            secondaryColor: String.read(from: buf),
            title: String.read(from: buf),
            unit: String.read(from: buf),
            currentVerifier: MVerifier.read(from: buf),
            meta: FfiConverterSequenceRecordMMetadataRecord.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        base58prefix.write(into: buf)
        color.write(into: buf)
        decimals.write(into: buf)
        encryption.write(into: buf)
        genesisHash.write(into: buf)
        logo.write(into: buf)
        name.write(into: buf)
        order.write(into: buf)
        pathId.write(into: buf)
        secondaryColor.write(into: buf)
        title.write(into: buf)
        unit.write(into: buf)
        currentVerifier.write(into: buf)
        FfiConverterSequenceRecordMMetadataRecord.write(meta, into: buf)
    }
}

extension MNetworkDetails: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MVerifier {
    public var ttype: String
    public var details: MVerifierDetails

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ttype: String, details: MVerifierDetails) {
        self.ttype = ttype
        self.details = details
    }
}

extension MVerifier: Equatable, Hashable {
    public static func == (lhs: MVerifier, rhs: MVerifier) -> Bool {
        if lhs.ttype != rhs.ttype {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ttype)
        hasher.combine(details)
    }
}

private extension MVerifier {
    static func read(from buf: Reader) throws -> MVerifier {
        return try MVerifier(
            ttype: String.read(from: buf),
            details: MVerifierDetails.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        ttype.write(into: buf)
        details.write(into: buf)
    }
}

extension MVerifier: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MMetadataRecord {
    public var specsVersion: String
    public var metaHash: String
    public var metaIdPic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(specsVersion: String, metaHash: String, metaIdPic: String) {
        self.specsVersion = specsVersion
        self.metaHash = metaHash
        self.metaIdPic = metaIdPic
    }
}

extension MMetadataRecord: Equatable, Hashable {
    public static func == (lhs: MMetadataRecord, rhs: MMetadataRecord) -> Bool {
        if lhs.specsVersion != rhs.specsVersion {
            return false
        }
        if lhs.metaHash != rhs.metaHash {
            return false
        }
        if lhs.metaIdPic != rhs.metaIdPic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(specsVersion)
        hasher.combine(metaHash)
        hasher.combine(metaIdPic)
    }
}

private extension MMetadataRecord {
    static func read(from buf: Reader) throws -> MMetadataRecord {
        return try MMetadataRecord(
            specsVersion: String.read(from: buf),
            metaHash: String.read(from: buf),
            metaIdPic: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        specsVersion.write(into: buf)
        metaHash.write(into: buf)
        metaIdPic.write(into: buf)
    }
}

extension MMetadataRecord: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MRawKey {
    public var seedName: String
    public var addressKey: String
    public var publicKey: String
    public var identicon: String
    public var hasPwd: Bool
    public var path: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(seedName: String, addressKey: String, publicKey: String, identicon: String, hasPwd: Bool, path: String) {
        self.seedName = seedName
        self.addressKey = addressKey
        self.publicKey = publicKey
        self.identicon = identicon
        self.hasPwd = hasPwd
        self.path = path
    }
}

extension MRawKey: Equatable, Hashable {
    public static func == (lhs: MRawKey, rhs: MRawKey) -> Bool {
        if lhs.seedName != rhs.seedName {
            return false
        }
        if lhs.addressKey != rhs.addressKey {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.identicon != rhs.identicon {
            return false
        }
        if lhs.hasPwd != rhs.hasPwd {
            return false
        }
        if lhs.path != rhs.path {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(seedName)
        hasher.combine(addressKey)
        hasher.combine(publicKey)
        hasher.combine(identicon)
        hasher.combine(hasPwd)
        hasher.combine(path)
    }
}

private extension MRawKey {
    static func read(from buf: Reader) throws -> MRawKey {
        return try MRawKey(
            seedName: String.read(from: buf),
            addressKey: String.read(from: buf),
            publicKey: String.read(from: buf),
            identicon: String.read(from: buf),
            hasPwd: Bool.read(from: buf),
            path: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        seedName.write(into: buf)
        addressKey.write(into: buf)
        publicKey.write(into: buf)
        identicon.write(into: buf)
        hasPwd.write(into: buf)
        path.write(into: buf)
    }
}

extension MRawKey: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MSignSufficientCrypto {
    public var identities: [MRawKey]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identities: [MRawKey]) {
        self.identities = identities
    }
}

extension MSignSufficientCrypto: Equatable, Hashable {
    public static func == (lhs: MSignSufficientCrypto, rhs: MSignSufficientCrypto) -> Bool {
        if lhs.identities != rhs.identities {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identities)
    }
}

private extension MSignSufficientCrypto {
    static func read(from buf: Reader) throws -> MSignSufficientCrypto {
        return try MSignSufficientCrypto(
            identities: FfiConverterSequenceRecordMRawKey.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterSequenceRecordMRawKey.write(identities, into: buf)
    }
}

extension MSignSufficientCrypto: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MKeyDetailsMulti {
    public var keyDetails: MKeyDetails
    public var currentNumber: String
    public var outOf: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(keyDetails: MKeyDetails, currentNumber: String, outOf: String) {
        self.keyDetails = keyDetails
        self.currentNumber = currentNumber
        self.outOf = outOf
    }
}

extension MKeyDetailsMulti: Equatable, Hashable {
    public static func == (lhs: MKeyDetailsMulti, rhs: MKeyDetailsMulti) -> Bool {
        if lhs.keyDetails != rhs.keyDetails {
            return false
        }
        if lhs.currentNumber != rhs.currentNumber {
            return false
        }
        if lhs.outOf != rhs.outOf {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(keyDetails)
        hasher.combine(currentNumber)
        hasher.combine(outOf)
    }
}

private extension MKeyDetailsMulti {
    static func read(from buf: Reader) throws -> MKeyDetailsMulti {
        return try MKeyDetailsMulti(
            keyDetails: MKeyDetails.read(from: buf),
            currentNumber: String.read(from: buf),
            outOf: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        keyDetails.write(into: buf)
        currentNumber.write(into: buf)
        outOf.write(into: buf)
    }
}

extension MKeyDetailsMulti: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MmNetwork {
    public var key: String
    public var title: String
    public var logo: String
    public var order: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: String, title: String, logo: String, order: UInt8) {
        self.key = key
        self.title = title
        self.logo = logo
        self.order = order
    }
}

extension MmNetwork: Equatable, Hashable {
    public static func == (lhs: MmNetwork, rhs: MmNetwork) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        if lhs.logo != rhs.logo {
            return false
        }
        if lhs.order != rhs.order {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(title)
        hasher.combine(logo)
        hasher.combine(order)
    }
}

private extension MmNetwork {
    static func read(from buf: Reader) throws -> MmNetwork {
        return try MmNetwork(
            key: String.read(from: buf),
            title: String.read(from: buf),
            logo: String.read(from: buf),
            order: UInt8.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        key.write(into: buf)
        title.write(into: buf)
        logo.write(into: buf)
        order.write(into: buf)
    }
}

extension MmNetwork: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MManageNetworks {
    public var networks: [MmNetwork]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networks: [MmNetwork]) {
        self.networks = networks
    }
}

extension MManageNetworks: Equatable, Hashable {
    public static func == (lhs: MManageNetworks, rhs: MManageNetworks) -> Bool {
        if lhs.networks != rhs.networks {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networks)
    }
}

private extension MManageNetworks {
    static func read(from buf: Reader) throws -> MManageNetworks {
        return try MManageNetworks(
            networks: FfiConverterSequenceRecordMmNetwork.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterSequenceRecordMmNetwork.write(networks, into: buf)
    }
}

extension MManageNetworks: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MscContent {
    public var ttype: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ttype: String) {
        self.ttype = ttype
    }
}

extension MscContent: Equatable, Hashable {
    public static func == (lhs: MscContent, rhs: MscContent) -> Bool {
        if lhs.ttype != rhs.ttype {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ttype)
    }
}

private extension MscContent {
    static func read(from buf: Reader) throws -> MscContent {
        return try MscContent(
            ttype: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        ttype.write(into: buf)
    }
}

extension MscContent: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MscAuthor {
    public var base58: String
    public var identicon: String
    public var seed: String
    public var hasPassword: Bool?
    public var derivationPath: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(base58: String, identicon: String, seed: String, hasPassword: Bool?, derivationPath: String) {
        self.base58 = base58
        self.identicon = identicon
        self.seed = seed
        self.hasPassword = hasPassword
        self.derivationPath = derivationPath
    }
}

extension MscAuthor: Equatable, Hashable {
    public static func == (lhs: MscAuthor, rhs: MscAuthor) -> Bool {
        if lhs.base58 != rhs.base58 {
            return false
        }
        if lhs.identicon != rhs.identicon {
            return false
        }
        if lhs.seed != rhs.seed {
            return false
        }
        if lhs.hasPassword != rhs.hasPassword {
            return false
        }
        if lhs.derivationPath != rhs.derivationPath {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(base58)
        hasher.combine(identicon)
        hasher.combine(seed)
        hasher.combine(hasPassword)
        hasher.combine(derivationPath)
    }
}

private extension MscAuthor {
    static func read(from buf: Reader) throws -> MscAuthor {
        return try MscAuthor(
            base58: String.read(from: buf),
            identicon: String.read(from: buf),
            seed: String.read(from: buf),
            hasPassword: FfiConverterOptionBool.read(from: buf),
            derivationPath: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        base58.write(into: buf)
        identicon.write(into: buf)
        seed.write(into: buf)
        FfiConverterOptionBool.write(hasPassword, into: buf)
        derivationPath.write(into: buf)
    }
}

extension MscAuthor: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MSufficientCryptoReady {
    public var authorInfo: MscAuthor
    public var sufficient: String
    public var content: MscContent

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(authorInfo: MscAuthor, sufficient: String, content: MscContent) {
        self.authorInfo = authorInfo
        self.sufficient = sufficient
        self.content = content
    }
}

extension MSufficientCryptoReady: Equatable, Hashable {
    public static func == (lhs: MSufficientCryptoReady, rhs: MSufficientCryptoReady) -> Bool {
        if lhs.authorInfo != rhs.authorInfo {
            return false
        }
        if lhs.sufficient != rhs.sufficient {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(authorInfo)
        hasher.combine(sufficient)
        hasher.combine(content)
    }
}

private extension MSufficientCryptoReady {
    static func read(from buf: Reader) throws -> MSufficientCryptoReady {
        return try MSufficientCryptoReady(
            authorInfo: MscAuthor.read(from: buf),
            sufficient: String.read(from: buf),
            content: MscContent.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        authorInfo.write(into: buf)
        sufficient.write(into: buf)
        content.write(into: buf)
    }
}

extension MSufficientCryptoReady: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MBackup {
    public var seedName: String
    public var derivations: [DerivationPack]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(seedName: String, derivations: [DerivationPack]) {
        self.seedName = seedName
        self.derivations = derivations
    }
}

extension MBackup: Equatable, Hashable {
    public static func == (lhs: MBackup, rhs: MBackup) -> Bool {
        if lhs.seedName != rhs.seedName {
            return false
        }
        if lhs.derivations != rhs.derivations {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(seedName)
        hasher.combine(derivations)
    }
}

private extension MBackup {
    static func read(from buf: Reader) throws -> MBackup {
        return try MBackup(
            seedName: String.read(from: buf),
            derivations: FfiConverterSequenceRecordDerivationPack.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        seedName.write(into: buf)
        FfiConverterSequenceRecordDerivationPack.write(derivations, into: buf)
    }
}

extension MBackup: ViaFfiUsingByteBuffer, ViaFfi {}

public struct DerivationPack {
    public var networkTitle: String
    public var networkLogo: String
    public var networkOrder: String
    public var idSet: [DerivationEntry]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkTitle: String, networkLogo: String, networkOrder: String, idSet: [DerivationEntry]) {
        self.networkTitle = networkTitle
        self.networkLogo = networkLogo
        self.networkOrder = networkOrder
        self.idSet = idSet
    }
}

extension DerivationPack: Equatable, Hashable {
    public static func == (lhs: DerivationPack, rhs: DerivationPack) -> Bool {
        if lhs.networkTitle != rhs.networkTitle {
            return false
        }
        if lhs.networkLogo != rhs.networkLogo {
            return false
        }
        if lhs.networkOrder != rhs.networkOrder {
            return false
        }
        if lhs.idSet != rhs.idSet {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkTitle)
        hasher.combine(networkLogo)
        hasher.combine(networkOrder)
        hasher.combine(idSet)
    }
}

private extension DerivationPack {
    static func read(from buf: Reader) throws -> DerivationPack {
        return try DerivationPack(
            networkTitle: String.read(from: buf),
            networkLogo: String.read(from: buf),
            networkOrder: String.read(from: buf),
            idSet: FfiConverterSequenceRecordDerivationEntry.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        networkTitle.write(into: buf)
        networkLogo.write(into: buf)
        networkOrder.write(into: buf)
        FfiConverterSequenceRecordDerivationEntry.write(idSet, into: buf)
    }
}

extension DerivationPack: ViaFfiUsingByteBuffer, ViaFfi {}

public struct DerivationEntry {
    public var path: String
    public var hasPwd: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(path: String, hasPwd: Bool) {
        self.path = path
        self.hasPwd = hasPwd
    }
}

extension DerivationEntry: Equatable, Hashable {
    public static func == (lhs: DerivationEntry, rhs: DerivationEntry) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        if lhs.hasPwd != rhs.hasPwd {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
        hasher.combine(hasPwd)
    }
}

private extension DerivationEntry {
    static func read(from buf: Reader) throws -> DerivationEntry {
        return try DerivationEntry(
            path: String.read(from: buf),
            hasPwd: Bool.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        path.write(into: buf)
        hasPwd.write(into: buf)
    }
}

extension DerivationEntry: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MSeedMenu {
    public var seed: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(seed: String) {
        self.seed = seed
    }
}

extension MSeedMenu: Equatable, Hashable {
    public static func == (lhs: MSeedMenu, rhs: MSeedMenu) -> Bool {
        if lhs.seed != rhs.seed {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(seed)
    }
}

private extension MSeedMenu {
    static func read(from buf: Reader) throws -> MSeedMenu {
        return try MSeedMenu(
            seed: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        seed.write(into: buf)
    }
}

extension MSeedMenu: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MNewSeedBackup {
    public var seed: String
    public var seedPhrase: String
    public var identicon: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(seed: String, seedPhrase: String, identicon: String) {
        self.seed = seed
        self.seedPhrase = seedPhrase
        self.identicon = identicon
    }
}

extension MNewSeedBackup: Equatable, Hashable {
    public static func == (lhs: MNewSeedBackup, rhs: MNewSeedBackup) -> Bool {
        if lhs.seed != rhs.seed {
            return false
        }
        if lhs.seedPhrase != rhs.seedPhrase {
            return false
        }
        if lhs.identicon != rhs.identicon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(seed)
        hasher.combine(seedPhrase)
        hasher.combine(identicon)
    }
}

private extension MNewSeedBackup {
    static func read(from buf: Reader) throws -> MNewSeedBackup {
        return try MNewSeedBackup(
            seed: String.read(from: buf),
            seedPhrase: String.read(from: buf),
            identicon: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        seed.write(into: buf)
        seedPhrase.write(into: buf)
        identicon.write(into: buf)
    }
}

extension MNewSeedBackup: ViaFfiUsingByteBuffer, ViaFfi {}

public struct Network {
    public var key: String
    public var logo: String
    public var order: UInt32
    public var selected: Bool
    public var title: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: String, logo: String, order: UInt32, selected: Bool, title: String) {
        self.key = key
        self.logo = logo
        self.order = order
        self.selected = selected
        self.title = title
    }
}

extension Network: Equatable, Hashable {
    public static func == (lhs: Network, rhs: Network) -> Bool {
        if lhs.key != rhs.key {
            return false
        }
        if lhs.logo != rhs.logo {
            return false
        }
        if lhs.order != rhs.order {
            return false
        }
        if lhs.selected != rhs.selected {
            return false
        }
        if lhs.title != rhs.title {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(key)
        hasher.combine(logo)
        hasher.combine(order)
        hasher.combine(selected)
        hasher.combine(title)
    }
}

private extension Network {
    static func read(from buf: Reader) throws -> Network {
        return try Network(
            key: String.read(from: buf),
            logo: String.read(from: buf),
            order: UInt32.read(from: buf),
            selected: Bool.read(from: buf),
            title: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        key.write(into: buf)
        logo.write(into: buf)
        order.write(into: buf)
        selected.write(into: buf)
        title.write(into: buf)
    }
}

extension Network: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MNetworkMenu {
    public var networks: [Network]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networks: [Network]) {
        self.networks = networks
    }
}

extension MNetworkMenu: Equatable, Hashable {
    public static func == (lhs: MNetworkMenu, rhs: MNetworkMenu) -> Bool {
        if lhs.networks != rhs.networks {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networks)
    }
}

private extension MNetworkMenu {
    static func read(from buf: Reader) throws -> MNetworkMenu {
        return try MNetworkMenu(
            networks: FfiConverterSequenceRecordNetwork.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        FfiConverterSequenceRecordNetwork.write(networks, into: buf)
    }
}

extension MNetworkMenu: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MPasswordConfirm {
    public var pwd: String
    public var seedName: String
    public var croppedPath: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pwd: String, seedName: String, croppedPath: String) {
        self.pwd = pwd
        self.seedName = seedName
        self.croppedPath = croppedPath
    }
}

extension MPasswordConfirm: Equatable, Hashable {
    public static func == (lhs: MPasswordConfirm, rhs: MPasswordConfirm) -> Bool {
        if lhs.pwd != rhs.pwd {
            return false
        }
        if lhs.seedName != rhs.seedName {
            return false
        }
        if lhs.croppedPath != rhs.croppedPath {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pwd)
        hasher.combine(seedName)
        hasher.combine(croppedPath)
    }
}

private extension MPasswordConfirm {
    static func read(from buf: Reader) throws -> MPasswordConfirm {
        return try MPasswordConfirm(
            pwd: String.read(from: buf),
            seedName: String.read(from: buf),
            croppedPath: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        pwd.write(into: buf)
        seedName.write(into: buf)
        croppedPath.write(into: buf)
    }
}

extension MPasswordConfirm: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MSignatureReady {
    public var signature: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(signature: String) {
        self.signature = signature
    }
}

extension MSignatureReady: Equatable, Hashable {
    public static func == (lhs: MSignatureReady, rhs: MSignatureReady) -> Bool {
        if lhs.signature != rhs.signature {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(signature)
    }
}

private extension MSignatureReady {
    static func read(from buf: Reader) throws -> MSignatureReady {
        return try MSignatureReady(
            signature: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        signature.write(into: buf)
    }
}

extension MSignatureReady: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MEnterPassword {
    public var authorInfo: TransactionAuthor
    public var counter: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(authorInfo: TransactionAuthor, counter: UInt32) {
        self.authorInfo = authorInfo
        self.counter = counter
    }
}

extension MEnterPassword: Equatable, Hashable {
    public static func == (lhs: MEnterPassword, rhs: MEnterPassword) -> Bool {
        if lhs.authorInfo != rhs.authorInfo {
            return false
        }
        if lhs.counter != rhs.counter {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(authorInfo)
        hasher.combine(counter)
    }
}

private extension MEnterPassword {
    static func read(from buf: Reader) throws -> MEnterPassword {
        return try MEnterPassword(
            authorInfo: TransactionAuthor.read(from: buf),
            counter: UInt32.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        authorInfo.write(into: buf)
        counter.write(into: buf)
    }
}

extension MEnterPassword: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MLogRight {
    public var checksum: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(checksum: String) {
        self.checksum = checksum
    }
}

extension MLogRight: Equatable, Hashable {
    public static func == (lhs: MLogRight, rhs: MLogRight) -> Bool {
        if lhs.checksum != rhs.checksum {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(checksum)
    }
}

private extension MLogRight {
    static func read(from buf: Reader) throws -> MLogRight {
        return try MLogRight(
            checksum: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        checksum.write(into: buf)
    }
}

extension MLogRight: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MmmNetwork {
    public var title: String
    public var logo: String
    public var order: UInt32
    public var currentOnScreen: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(title: String, logo: String, order: UInt32, currentOnScreen: Bool) {
        self.title = title
        self.logo = logo
        self.order = order
        self.currentOnScreen = currentOnScreen
    }
}

extension MmmNetwork: Equatable, Hashable {
    public static func == (lhs: MmmNetwork, rhs: MmmNetwork) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.logo != rhs.logo {
            return false
        }
        if lhs.order != rhs.order {
            return false
        }
        if lhs.currentOnScreen != rhs.currentOnScreen {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(logo)
        hasher.combine(order)
        hasher.combine(currentOnScreen)
    }
}

private extension MmmNetwork {
    static func read(from buf: Reader) throws -> MmmNetwork {
        return try MmmNetwork(
            title: String.read(from: buf),
            logo: String.read(from: buf),
            order: UInt32.read(from: buf),
            currentOnScreen: Bool.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        title.write(into: buf)
        logo.write(into: buf)
        order.write(into: buf)
        currentOnScreen.write(into: buf)
    }
}

extension MmmNetwork: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MmManageNetworks {
    public var name: String
    public var version: String
    public var metaHash: String
    public var metaIdPic: String
    public var networks: [MmmNetwork]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, version: String, metaHash: String, metaIdPic: String, networks: [MmmNetwork]) {
        self.name = name
        self.version = version
        self.metaHash = metaHash
        self.metaIdPic = metaIdPic
        self.networks = networks
    }
}

extension MmManageNetworks: Equatable, Hashable {
    public static func == (lhs: MmManageNetworks, rhs: MmManageNetworks) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.metaHash != rhs.metaHash {
            return false
        }
        if lhs.metaIdPic != rhs.metaIdPic {
            return false
        }
        if lhs.networks != rhs.networks {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(version)
        hasher.combine(metaHash)
        hasher.combine(metaIdPic)
        hasher.combine(networks)
    }
}

private extension MmManageNetworks {
    static func read(from buf: Reader) throws -> MmManageNetworks {
        return try MmManageNetworks(
            name: String.read(from: buf),
            version: String.read(from: buf),
            metaHash: String.read(from: buf),
            metaIdPic: String.read(from: buf),
            networks: FfiConverterSequenceRecordMmmNetwork.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        name.write(into: buf)
        version.write(into: buf)
        metaHash.write(into: buf)
        metaIdPic.write(into: buf)
        FfiConverterSequenceRecordMmmNetwork.write(networks, into: buf)
    }
}

extension MmManageNetworks: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MTypesInfo {
    public var typesOnFile: Bool
    public var typesHash: String?
    public var typesIdPic: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(typesOnFile: Bool, typesHash: String?, typesIdPic: String?) {
        self.typesOnFile = typesOnFile
        self.typesHash = typesHash
        self.typesIdPic = typesIdPic
    }
}

extension MTypesInfo: Equatable, Hashable {
    public static func == (lhs: MTypesInfo, rhs: MTypesInfo) -> Bool {
        if lhs.typesOnFile != rhs.typesOnFile {
            return false
        }
        if lhs.typesHash != rhs.typesHash {
            return false
        }
        if lhs.typesIdPic != rhs.typesIdPic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(typesOnFile)
        hasher.combine(typesHash)
        hasher.combine(typesIdPic)
    }
}

private extension MTypesInfo {
    static func read(from buf: Reader) throws -> MTypesInfo {
        return try MTypesInfo(
            typesOnFile: Bool.read(from: buf),
            typesHash: FfiConverterOptionString.read(from: buf),
            typesIdPic: FfiConverterOptionString.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        typesOnFile.write(into: buf)
        FfiConverterOptionString.write(typesHash, into: buf)
        FfiConverterOptionString.write(typesIdPic, into: buf)
    }
}

extension MTypesInfo: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MscAuthorPlain {
    public var base58: String
    public var identicon: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(base58: String, identicon: String) {
        self.base58 = base58
        self.identicon = identicon
    }
}

extension MscAuthorPlain: Equatable, Hashable {
    public static func == (lhs: MscAuthorPlain, rhs: MscAuthorPlain) -> Bool {
        if lhs.base58 != rhs.base58 {
            return false
        }
        if lhs.identicon != rhs.identicon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(base58)
        hasher.combine(identicon)
    }
}

private extension MscAuthorPlain {
    static func read(from buf: Reader) throws -> MscAuthorPlain {
        return try MscAuthorPlain(
            base58: String.read(from: buf),
            identicon: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        base58.write(into: buf)
        identicon.write(into: buf)
    }
}

extension MscAuthorPlain: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MscCall {
    public var methodName: String
    public var docs: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(methodName: String, docs: String) {
        self.methodName = methodName
        self.docs = docs
    }
}

extension MscCall: Equatable, Hashable {
    public static func == (lhs: MscCall, rhs: MscCall) -> Bool {
        if lhs.methodName != rhs.methodName {
            return false
        }
        if lhs.docs != rhs.docs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(methodName)
        hasher.combine(docs)
    }
}

private extension MscCall {
    static func read(from buf: Reader) throws -> MscCall {
        return try MscCall(
            methodName: String.read(from: buf),
            docs: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        methodName.write(into: buf)
        docs.write(into: buf)
    }
}

extension MscCall: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MscCurrency {
    public var amount: String
    public var units: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: String, units: String) {
        self.amount = amount
        self.units = units
    }
}

extension MscCurrency: Equatable, Hashable {
    public static func == (lhs: MscCurrency, rhs: MscCurrency) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.units != rhs.units {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(units)
    }
}

private extension MscCurrency {
    static func read(from buf: Reader) throws -> MscCurrency {
        return try MscCurrency(
            amount: String.read(from: buf),
            units: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        amount.write(into: buf)
        units.write(into: buf)
    }
}

extension MscCurrency: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MscEnumVariantName {
    public var name: String
    public var docsEnumVariant: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, docsEnumVariant: String) {
        self.name = name
        self.docsEnumVariant = docsEnumVariant
    }
}

extension MscEnumVariantName: Equatable, Hashable {
    public static func == (lhs: MscEnumVariantName, rhs: MscEnumVariantName) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.docsEnumVariant != rhs.docsEnumVariant {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(docsEnumVariant)
    }
}

private extension MscEnumVariantName {
    static func read(from buf: Reader) throws -> MscEnumVariantName {
        return try MscEnumVariantName(
            name: String.read(from: buf),
            docsEnumVariant: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        name.write(into: buf)
        docsEnumVariant.write(into: buf)
    }
}

extension MscEnumVariantName: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MscEraMortal {
    public var era: String
    public var phase: String
    public var period: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(era: String, phase: String, period: String) {
        self.era = era
        self.phase = phase
        self.period = period
    }
}

extension MscEraMortal: Equatable, Hashable {
    public static func == (lhs: MscEraMortal, rhs: MscEraMortal) -> Bool {
        if lhs.era != rhs.era {
            return false
        }
        if lhs.phase != rhs.phase {
            return false
        }
        if lhs.period != rhs.period {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(era)
        hasher.combine(phase)
        hasher.combine(period)
    }
}

private extension MscEraMortal {
    static func read(from buf: Reader) throws -> MscEraMortal {
        return try MscEraMortal(
            era: String.read(from: buf),
            phase: String.read(from: buf),
            period: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        era.write(into: buf)
        phase.write(into: buf)
        period.write(into: buf)
    }
}

extension MscEraMortal: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MscFieldName {
    public var name: String
    public var docsFieldName: String
    public var pathType: String
    public var docsType: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, docsFieldName: String, pathType: String, docsType: String) {
        self.name = name
        self.docsFieldName = docsFieldName
        self.pathType = pathType
        self.docsType = docsType
    }
}

extension MscFieldName: Equatable, Hashable {
    public static func == (lhs: MscFieldName, rhs: MscFieldName) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.docsFieldName != rhs.docsFieldName {
            return false
        }
        if lhs.pathType != rhs.pathType {
            return false
        }
        if lhs.docsType != rhs.docsType {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(docsFieldName)
        hasher.combine(pathType)
        hasher.combine(docsType)
    }
}

private extension MscFieldName {
    static func read(from buf: Reader) throws -> MscFieldName {
        return try MscFieldName(
            name: String.read(from: buf),
            docsFieldName: String.read(from: buf),
            pathType: String.read(from: buf),
            docsType: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        name.write(into: buf)
        docsFieldName.write(into: buf)
        pathType.write(into: buf)
        docsType.write(into: buf)
    }
}

extension MscFieldName: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MscFieldNumber {
    public var number: String
    public var docsFieldNumber: String
    public var pathType: String
    public var docsType: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(number: String, docsFieldNumber: String, pathType: String, docsType: String) {
        self.number = number
        self.docsFieldNumber = docsFieldNumber
        self.pathType = pathType
        self.docsType = docsType
    }
}

extension MscFieldNumber: Equatable, Hashable {
    public static func == (lhs: MscFieldNumber, rhs: MscFieldNumber) -> Bool {
        if lhs.number != rhs.number {
            return false
        }
        if lhs.docsFieldNumber != rhs.docsFieldNumber {
            return false
        }
        if lhs.pathType != rhs.pathType {
            return false
        }
        if lhs.docsType != rhs.docsType {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(number)
        hasher.combine(docsFieldNumber)
        hasher.combine(pathType)
        hasher.combine(docsType)
    }
}

private extension MscFieldNumber {
    static func read(from buf: Reader) throws -> MscFieldNumber {
        return try MscFieldNumber(
            number: String.read(from: buf),
            docsFieldNumber: String.read(from: buf),
            pathType: String.read(from: buf),
            docsType: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        number.write(into: buf)
        docsFieldNumber.write(into: buf)
        pathType.write(into: buf)
        docsType.write(into: buf)
    }
}

extension MscFieldNumber: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MscId {
    public var base58: String
    public var identicon: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(base58: String, identicon: String) {
        self.base58 = base58
        self.identicon = identicon
    }
}

extension MscId: Equatable, Hashable {
    public static func == (lhs: MscId, rhs: MscId) -> Bool {
        if lhs.base58 != rhs.base58 {
            return false
        }
        if lhs.identicon != rhs.identicon {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(base58)
        hasher.combine(identicon)
    }
}

private extension MscId {
    static func read(from buf: Reader) throws -> MscId {
        return try MscId(
            base58: String.read(from: buf),
            identicon: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        base58.write(into: buf)
        identicon.write(into: buf)
    }
}

extension MscId: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MscMetaSpecs {
    public var specname: String
    public var specVersion: String
    public var metaHash: String
    public var metaIdPic: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(specname: String, specVersion: String, metaHash: String, metaIdPic: String) {
        self.specname = specname
        self.specVersion = specVersion
        self.metaHash = metaHash
        self.metaIdPic = metaIdPic
    }
}

extension MscMetaSpecs: Equatable, Hashable {
    public static func == (lhs: MscMetaSpecs, rhs: MscMetaSpecs) -> Bool {
        if lhs.specname != rhs.specname {
            return false
        }
        if lhs.specVersion != rhs.specVersion {
            return false
        }
        if lhs.metaHash != rhs.metaHash {
            return false
        }
        if lhs.metaIdPic != rhs.metaIdPic {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(specname)
        hasher.combine(specVersion)
        hasher.combine(metaHash)
        hasher.combine(metaIdPic)
    }
}

private extension MscMetaSpecs {
    static func read(from buf: Reader) throws -> MscMetaSpecs {
        return try MscMetaSpecs(
            specname: String.read(from: buf),
            specVersion: String.read(from: buf),
            metaHash: String.read(from: buf),
            metaIdPic: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        specname.write(into: buf)
        specVersion.write(into: buf)
        metaHash.write(into: buf)
        metaIdPic.write(into: buf)
    }
}

extension MscMetaSpecs: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MscNameVersion {
    public var name: String
    public var version: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, version: String) {
        self.name = name
        self.version = version
    }
}

extension MscNameVersion: Equatable, Hashable {
    public static func == (lhs: MscNameVersion, rhs: MscNameVersion) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(version)
    }
}

private extension MscNameVersion {
    static func read(from buf: Reader) throws -> MscNameVersion {
        return try MscNameVersion(
            name: String.read(from: buf),
            version: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        name.write(into: buf)
        version.write(into: buf)
    }
}

extension MscNameVersion: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MscNetworkInfo {
    public var networkTitle: String
    public var networkLogo: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkTitle: String, networkLogo: String) {
        self.networkTitle = networkTitle
        self.networkLogo = networkLogo
    }
}

extension MscNetworkInfo: Equatable, Hashable {
    public static func == (lhs: MscNetworkInfo, rhs: MscNetworkInfo) -> Bool {
        if lhs.networkTitle != rhs.networkTitle {
            return false
        }
        if lhs.networkLogo != rhs.networkLogo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkTitle)
        hasher.combine(networkLogo)
    }
}

private extension MscNetworkInfo {
    static func read(from buf: Reader) throws -> MscNetworkInfo {
        return try MscNetworkInfo(
            networkTitle: String.read(from: buf),
            networkLogo: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        networkTitle.write(into: buf)
        networkLogo.write(into: buf)
    }
}

extension MscNetworkInfo: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MscTip {
    public var amount: String
    public var units: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(amount: String, units: String) {
        self.amount = amount
        self.units = units
    }
}

extension MscTip: Equatable, Hashable {
    public static func == (lhs: MscTip, rhs: MscTip) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.units != rhs.units {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(units)
    }
}

private extension MscTip {
    static func read(from buf: Reader) throws -> MscTip {
        return try MscTip(
            amount: String.read(from: buf),
            units: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        amount.write(into: buf)
        units.write(into: buf)
    }
}

extension MscTip: ViaFfiUsingByteBuffer, ViaFfi {}

public struct MscTxSpecPlain {
    public var networkGenesisHash: String
    public var version: String
    public var txVersion: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(networkGenesisHash: String, version: String, txVersion: String) {
        self.networkGenesisHash = networkGenesisHash
        self.version = version
        self.txVersion = txVersion
    }
}

extension MscTxSpecPlain: Equatable, Hashable {
    public static func == (lhs: MscTxSpecPlain, rhs: MscTxSpecPlain) -> Bool {
        if lhs.networkGenesisHash != rhs.networkGenesisHash {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.txVersion != rhs.txVersion {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(networkGenesisHash)
        hasher.combine(version)
        hasher.combine(txVersion)
    }
}

private extension MscTxSpecPlain {
    static func read(from buf: Reader) throws -> MscTxSpecPlain {
        return try MscTxSpecPlain(
            networkGenesisHash: String.read(from: buf),
            version: String.read(from: buf),
            txVersion: String.read(from: buf)
        )
    }

    func write(into buf: Writer) {
        networkGenesisHash.write(into: buf)
        version.write(into: buf)
        txVersion.write(into: buf)
    }
}

extension MscTxSpecPlain: ViaFfiUsingByteBuffer, ViaFfi {}

public enum ErrorDisplayed {
    case Str(s: String)
}

extension ErrorDisplayed: ViaFfiUsingByteBuffer, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> ErrorDisplayed {
        let variant: Int32 = try buf.readInt()
        switch variant {
        case 1: return .Str(
                s: try String.read(from: buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    fileprivate func write(into buf: Writer) {
        switch self {
        case let .Str(s):
            buf.writeInt(Int32(1))
            s.write(into: buf)
        }
    }
}

extension ErrorDisplayed: Equatable, Hashable {}

extension ErrorDisplayed: Error {}
private enum FfiConverterTypeEcdsaPublic {
    fileprivate static func read(_ buf: Reader) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.read(from: buf)
    }

    fileprivate static func write(_ value: [UInt8], _ buf: Writer) {
        return FfiConverterSequenceUInt8.write(value, into: buf)
    }

    fileprivate static func lift(_ value: RustBuffer) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(value)
    }

    fileprivate static func lower(_ value: [UInt8]) -> RustBuffer {
        return FfiConverterSequenceUInt8.lower(value)
    }
}

private enum FfiConverterTypeEd25519Public {
    fileprivate static func read(_ buf: Reader) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.read(from: buf)
    }

    fileprivate static func write(_ value: [UInt8], _ buf: Writer) {
        return FfiConverterSequenceUInt8.write(value, into: buf)
    }

    fileprivate static func lift(_ value: RustBuffer) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(value)
    }

    fileprivate static func lower(_ value: [UInt8]) -> RustBuffer {
        return FfiConverterSequenceUInt8.lower(value)
    }
}

private enum FfiConverterTypeH256 {
    fileprivate static func read(_ buf: Reader) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.read(from: buf)
    }

    fileprivate static func write(_ value: [UInt8], _ buf: Writer) {
        return FfiConverterSequenceUInt8.write(value, into: buf)
    }

    fileprivate static func lift(_ value: RustBuffer) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(value)
    }

    fileprivate static func lower(_ value: [UInt8]) -> RustBuffer {
        return FfiConverterSequenceUInt8.lower(value)
    }
}

private enum FfiConverterTypeMultiSigner {
    fileprivate static func read(_ buf: Reader) throws -> String {
        return try String.read(from: buf)
    }

    fileprivate static func write(_ value: String, _ buf: Writer) {
        return value.write(into: buf)
    }

    fileprivate static func lift(_ value: RustBuffer) throws -> String {
        return try String.lift(value)
    }

    fileprivate static func lower(_ value: String) -> RustBuffer {
        return value.lower()
    }
}

private enum FfiConverterTypeSr25519Public {
    fileprivate static func read(_ buf: Reader) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.read(from: buf)
    }

    fileprivate static func write(_ value: [UInt8], _ buf: Writer) {
        return FfiConverterSequenceUInt8.write(value, into: buf)
    }

    fileprivate static func lift(_ value: RustBuffer) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(value)
    }

    fileprivate static func lower(_ value: [UInt8]) -> RustBuffer {
        return FfiConverterSequenceUInt8.lower(value)
    }
}

extension UInt8: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }
}

extension UInt16: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }
}

extension UInt32: Primitive, ViaFfi {
    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }
}

extension Bool: ViaFfi {
    fileprivate typealias FfiType = Int8

    fileprivate static func read(from buf: Reader) throws -> Self {
        return try lift(buf.readInt())
    }

    fileprivate func write(into buf: Writer) {
        buf.writeInt(lower())
    }

    fileprivate static func lift(_ v: FfiType) throws -> Self {
        return v != 0
    }

    fileprivate func lower() -> FfiType {
        return self ? 1 : 0
    }
}

extension String: ViaFfi {
    fileprivate typealias FfiType = RustBuffer

    fileprivate static func lift(_ v: FfiType) throws -> Self {
        defer {
            v.deallocate()
        }
        if v.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: v.data!, count: Int(v.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    fileprivate func lower() -> FfiType {
        return utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    fileprivate static func read(from buf: Reader) throws -> Self {
        let len: Int32 = try buf.readInt()
        return String(bytes: try buf.readBytes(count: Int(len)), encoding: String.Encoding.utf8)!
    }

    fileprivate func write(into buf: Writer) {
        let len = Int32(utf8.count)
        buf.writeInt(len)
        buf.writeBytes(utf8)
    }
}

// Helper code for ActionResult record is found in RecordTemplate.swift
// Helper code for Address record is found in RecordTemplate.swift
// Helper code for DerivationCheck record is found in RecordTemplate.swift
// Helper code for DerivationEntry record is found in RecordTemplate.swift
// Helper code for DerivationPack record is found in RecordTemplate.swift
// Helper code for History record is found in RecordTemplate.swift
// Helper code for Identity record is found in RecordTemplate.swift
// Helper code for IdentityHistory record is found in RecordTemplate.swift
// Helper code for MBackup record is found in RecordTemplate.swift
// Helper code for MDeriveKey record is found in RecordTemplate.swift
// Helper code for MEnterPassword record is found in RecordTemplate.swift
// Helper code for MKeyDetails record is found in RecordTemplate.swift
// Helper code for MKeyDetailsMulti record is found in RecordTemplate.swift
// Helper code for MKeys record is found in RecordTemplate.swift
// Helper code for MKeysCard record is found in RecordTemplate.swift
// Helper code for MLog record is found in RecordTemplate.swift
// Helper code for MLogDetails record is found in RecordTemplate.swift
// Helper code for MLogRight record is found in RecordTemplate.swift
// Helper code for MmmNetwork record is found in RecordTemplate.swift
// Helper code for MmManageNetworks record is found in RecordTemplate.swift
// Helper code for MmNetwork record is found in RecordTemplate.swift
// Helper code for MManageNetworks record is found in RecordTemplate.swift
// Helper code for MMetadataRecord record is found in RecordTemplate.swift
// Helper code for MNetworkCard record is found in RecordTemplate.swift
// Helper code for MNetworkDetails record is found in RecordTemplate.swift
// Helper code for MNetworkMenu record is found in RecordTemplate.swift
// Helper code for MNewSeed record is found in RecordTemplate.swift
// Helper code for MNewSeedBackup record is found in RecordTemplate.swift
// Helper code for MPasswordConfirm record is found in RecordTemplate.swift
// Helper code for MRawKey record is found in RecordTemplate.swift
// Helper code for MRecoverSeedName record is found in RecordTemplate.swift
// Helper code for MRecoverSeedPhrase record is found in RecordTemplate.swift
// Helper code for MscAuthor record is found in RecordTemplate.swift
// Helper code for MscAuthorPlain record is found in RecordTemplate.swift
// Helper code for MscCall record is found in RecordTemplate.swift
// Helper code for MscContent record is found in RecordTemplate.swift
// Helper code for MscCurrency record is found in RecordTemplate.swift
// Helper code for MscEnumVariantName record is found in RecordTemplate.swift
// Helper code for MscEraMortal record is found in RecordTemplate.swift
// Helper code for MscFieldName record is found in RecordTemplate.swift
// Helper code for MscFieldNumber record is found in RecordTemplate.swift
// Helper code for MscId record is found in RecordTemplate.swift
// Helper code for MscMetaSpecs record is found in RecordTemplate.swift
// Helper code for MscNameVersion record is found in RecordTemplate.swift
// Helper code for MscNetworkInfo record is found in RecordTemplate.swift
// Helper code for MscTip record is found in RecordTemplate.swift
// Helper code for MscTxSpecPlain record is found in RecordTemplate.swift
// Helper code for MSeedKeyCard record is found in RecordTemplate.swift
// Helper code for MSeedMenu record is found in RecordTemplate.swift
// Helper code for MSeeds record is found in RecordTemplate.swift
// Helper code for MSettings record is found in RecordTemplate.swift
// Helper code for MSignSufficientCrypto record is found in RecordTemplate.swift
// Helper code for MSignatureReady record is found in RecordTemplate.swift
// Helper code for MSufficientCryptoReady record is found in RecordTemplate.swift
// Helper code for MTransaction record is found in RecordTemplate.swift
// Helper code for MTypesInfo record is found in RecordTemplate.swift
// Helper code for MVerifier record is found in RecordTemplate.swift
// Helper code for MVerifierDetails record is found in RecordTemplate.swift
// Helper code for MetaValues record is found in RecordTemplate.swift
// Helper code for MetaValuesDisplay record is found in RecordTemplate.swift
// Helper code for MetaValuesExport record is found in RecordTemplate.swift
// Helper code for Network record is found in RecordTemplate.swift
// Helper code for NetworkSpecs record is found in RecordTemplate.swift
// Helper code for NetworkSpecsDisplay record is found in RecordTemplate.swift
// Helper code for NetworkSpecsExport record is found in RecordTemplate.swift
// Helper code for NetworkSpecsToSend record is found in RecordTemplate.swift
// Helper code for NetworkVerifierDisplay record is found in RecordTemplate.swift
// Helper code for SeedNameCard record is found in RecordTemplate.swift
// Helper code for SignDisplay record is found in RecordTemplate.swift
// Helper code for SignMessageDisplay record is found in RecordTemplate.swift
// Helper code for TransactionAuthor record is found in RecordTemplate.swift
// Helper code for TransactionCard record is found in RecordTemplate.swift
// Helper code for TransactionCardSet record is found in RecordTemplate.swift
// Helper code for TransactionNetworkInfo record is found in RecordTemplate.swift
// Helper code for TypesDisplay record is found in RecordTemplate.swift
// Helper code for TypesExport record is found in RecordTemplate.swift
// Helper code for Verifier record is found in RecordTemplate.swift
// Helper code for Action enum is found in EnumTemplate.swift
// Helper code for Card enum is found in EnumTemplate.swift
// Helper code for DerivationDestination enum is found in EnumTemplate.swift
// Helper code for Encryption enum is found in EnumTemplate.swift
// Helper code for Event enum is found in EnumTemplate.swift
// Helper code for FooterButton enum is found in EnumTemplate.swift
// Helper code for ModalData enum is found in EnumTemplate.swift
// Helper code for RightButton enum is found in EnumTemplate.swift
// Helper code for ScreenData enum is found in EnumTemplate.swift
// Helper code for ScreenNameType enum is found in EnumTemplate.swift
// Helper code for TransactionType enum is found in EnumTemplate.swift
// Helper code for ValidCurrentVerifier enum is found in EnumTemplate.swift
// Helper code for VerifierValue enum is found in EnumTemplate.swift
// Helper code for ErrorDisplayed error is found in ErrorTemplate.swift

private enum FfiConverterOptionUInt16: FfiConverterUsingByteBuffer {
    typealias SwiftType = UInt16?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try UInt16.read(from: buf)
        }
    }
}

private enum FfiConverterOptionBool: FfiConverterUsingByteBuffer {
    typealias SwiftType = Bool?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try Bool.read(from: buf)
        }
    }
}

private enum FfiConverterOptionString: FfiConverterUsingByteBuffer {
    typealias SwiftType = String?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try String.read(from: buf)
        }
    }
}

private enum FfiConverterOptionRecordAddress: FfiConverterUsingByteBuffer {
    typealias SwiftType = Address?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try Address.read(from: buf)
        }
    }
}

private enum FfiConverterOptionRecordDerivationCheck: FfiConverterUsingByteBuffer {
    typealias SwiftType = DerivationCheck?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try DerivationCheck.read(from: buf)
        }
    }
}

private enum FfiConverterOptionRecordTransactionAuthor: FfiConverterUsingByteBuffer {
    typealias SwiftType = TransactionAuthor?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try TransactionAuthor.read(from: buf)
        }
    }
}

private enum FfiConverterOptionRecordTransactionNetworkInfo: FfiConverterUsingByteBuffer {
    typealias SwiftType = TransactionNetworkInfo?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try TransactionNetworkInfo.read(from: buf)
        }
    }
}

private enum FfiConverterOptionEnumDerivationDestination: FfiConverterUsingByteBuffer {
    typealias SwiftType = DerivationDestination?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try DerivationDestination.read(from: buf)
        }
    }
}

private enum FfiConverterOptionEnumFooterButton: FfiConverterUsingByteBuffer {
    typealias SwiftType = FooterButton?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try FooterButton.read(from: buf)
        }
    }
}

private enum FfiConverterOptionEnumModalData: FfiConverterUsingByteBuffer {
    typealias SwiftType = ModalData?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try ModalData.read(from: buf)
        }
    }
}

private enum FfiConverterOptionEnumRightButton: FfiConverterUsingByteBuffer {
    typealias SwiftType = RightButton?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try RightButton.read(from: buf)
        }
    }
}

private enum FfiConverterOptionEnumVerifierValue: FfiConverterUsingByteBuffer {
    typealias SwiftType = VerifierValue?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try VerifierValue.read(from: buf)
        }
    }
}

private enum FfiConverterOptionSequenceRecordTransactionCard: FfiConverterUsingByteBuffer {
    typealias SwiftType = [TransactionCard]?

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterOptional.write(value, into: buf) { item, buf in
            FfiConverterSequenceRecordTransactionCard.write(item, into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterOptional.read(from: buf) { buf in
            try FfiConverterSequenceRecordTransactionCard.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceUInt8: FfiConverterUsingByteBuffer {
    typealias SwiftType = [UInt8]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try UInt8.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceString: FfiConverterUsingByteBuffer {
    typealias SwiftType = [String]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try String.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceRecordDerivationEntry: FfiConverterUsingByteBuffer {
    typealias SwiftType = [DerivationEntry]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try DerivationEntry.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceRecordDerivationPack: FfiConverterUsingByteBuffer {
    typealias SwiftType = [DerivationPack]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try DerivationPack.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceRecordHistory: FfiConverterUsingByteBuffer {
    typealias SwiftType = [History]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try History.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceRecordMKeysCard: FfiConverterUsingByteBuffer {
    typealias SwiftType = [MKeysCard]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try MKeysCard.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceRecordMmmNetwork: FfiConverterUsingByteBuffer {
    typealias SwiftType = [MmmNetwork]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try MmmNetwork.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceRecordMmNetwork: FfiConverterUsingByteBuffer {
    typealias SwiftType = [MmNetwork]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try MmNetwork.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceRecordMMetadataRecord: FfiConverterUsingByteBuffer {
    typealias SwiftType = [MMetadataRecord]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try MMetadataRecord.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceRecordMRawKey: FfiConverterUsingByteBuffer {
    typealias SwiftType = [MRawKey]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try MRawKey.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceRecordNetwork: FfiConverterUsingByteBuffer {
    typealias SwiftType = [Network]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try Network.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceRecordSeedNameCard: FfiConverterUsingByteBuffer {
    typealias SwiftType = [SeedNameCard]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try SeedNameCard.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceRecordTransactionCard: FfiConverterUsingByteBuffer {
    typealias SwiftType = [TransactionCard]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try TransactionCard.read(from: buf)
        }
    }
}

private enum FfiConverterSequenceEnumEvent: FfiConverterUsingByteBuffer {
    typealias SwiftType = [Event]

    static func write(_ value: SwiftType, into buf: Writer) {
        FfiConverterSequence.write(value, into: buf) { item, buf in
            item.write(into: buf)
        }
    }

    static func read(from buf: Reader) throws -> SwiftType {
        try FfiConverterSequence.read(from: buf) { buf in
            try Event.read(from: buf)
        }
    }
}

// Helper code for EcdsaPublic is found in CustomType.py
// Helper code for Ed25519Public is found in CustomType.py
// Helper code for H256 is found in CustomType.py
// Helper code for MultiSigner is found in CustomType.py
// Helper code for Sr25519Public is found in CustomType.py

/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum SignerLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {
        // No initialization code needed
    }
}
