// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(signerFFI)
import signerFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_signer_23f1_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_signer_23f1_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a libray of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
    (_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
    {
    try makeRustCall(callback, errorHandler: { return try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
        case CALL_SUCCESS:
            return returnedVal

        case CALL_ERROR:
            throw try errorHandler(callStatus.errorBuf)

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


public struct ActionResult {
    public var `screenLabel`: String
    public var `back`: Bool
    public var `footer`: Bool
    public var `footerButton`: FooterButton?
    public var `rightButton`: RightButton?
    public var `screenNameType`: ScreenNameType
    public var `screenData`: ScreenData
    public var `modalData`: ModalData?
    public var `alertData`: AlertData?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`screenLabel`: String, `back`: Bool, `footer`: Bool, `footerButton`: FooterButton?, `rightButton`: RightButton?, `screenNameType`: ScreenNameType, `screenData`: ScreenData, `modalData`: ModalData?, `alertData`: AlertData?) {
        self.`screenLabel` = `screenLabel`
        self.`back` = `back`
        self.`footer` = `footer`
        self.`footerButton` = `footerButton`
        self.`rightButton` = `rightButton`
        self.`screenNameType` = `screenNameType`
        self.`screenData` = `screenData`
        self.`modalData` = `modalData`
        self.`alertData` = `alertData`
    }
}


extension ActionResult: Equatable, Hashable {
    public static func ==(lhs: ActionResult, rhs: ActionResult) -> Bool {
        if lhs.`screenLabel` != rhs.`screenLabel` {
            return false
        }
        if lhs.`back` != rhs.`back` {
            return false
        }
        if lhs.`footer` != rhs.`footer` {
            return false
        }
        if lhs.`footerButton` != rhs.`footerButton` {
            return false
        }
        if lhs.`rightButton` != rhs.`rightButton` {
            return false
        }
        if lhs.`screenNameType` != rhs.`screenNameType` {
            return false
        }
        if lhs.`screenData` != rhs.`screenData` {
            return false
        }
        if lhs.`modalData` != rhs.`modalData` {
            return false
        }
        if lhs.`alertData` != rhs.`alertData` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`screenLabel`)
        hasher.combine(`back`)
        hasher.combine(`footer`)
        hasher.combine(`footerButton`)
        hasher.combine(`rightButton`)
        hasher.combine(`screenNameType`)
        hasher.combine(`screenData`)
        hasher.combine(`modalData`)
        hasher.combine(`alertData`)
    }
}


public struct FfiConverterTypeActionResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ActionResult {
        return try ActionResult(
            `screenLabel`: FfiConverterString.read(from: &buf), 
            `back`: FfiConverterBool.read(from: &buf), 
            `footer`: FfiConverterBool.read(from: &buf), 
            `footerButton`: FfiConverterOptionTypeFooterButton.read(from: &buf), 
            `rightButton`: FfiConverterOptionTypeRightButton.read(from: &buf), 
            `screenNameType`: FfiConverterTypeScreenNameType.read(from: &buf), 
            `screenData`: FfiConverterTypeScreenData.read(from: &buf), 
            `modalData`: FfiConverterOptionTypeModalData.read(from: &buf), 
            `alertData`: FfiConverterOptionTypeAlertData.read(from: &buf)
        )
    }

    public static func write(_ value: ActionResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`screenLabel`, into: &buf)
        FfiConverterBool.write(value.`back`, into: &buf)
        FfiConverterBool.write(value.`footer`, into: &buf)
        FfiConverterOptionTypeFooterButton.write(value.`footerButton`, into: &buf)
        FfiConverterOptionTypeRightButton.write(value.`rightButton`, into: &buf)
        FfiConverterTypeScreenNameType.write(value.`screenNameType`, into: &buf)
        FfiConverterTypeScreenData.write(value.`screenData`, into: &buf)
        FfiConverterOptionTypeModalData.write(value.`modalData`, into: &buf)
        FfiConverterOptionTypeAlertData.write(value.`alertData`, into: &buf)
    }
}


public struct Address {
    public var `path`: String
    public var `hasPwd`: Bool
    public var `identicon`: SignerImage
    public var `seedName`: String
    public var `secretExposed`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`path`: String, `hasPwd`: Bool, `identicon`: SignerImage, `seedName`: String, `secretExposed`: Bool) {
        self.`path` = `path`
        self.`hasPwd` = `hasPwd`
        self.`identicon` = `identicon`
        self.`seedName` = `seedName`
        self.`secretExposed` = `secretExposed`
    }
}


extension Address: Equatable, Hashable {
    public static func ==(lhs: Address, rhs: Address) -> Bool {
        if lhs.`path` != rhs.`path` {
            return false
        }
        if lhs.`hasPwd` != rhs.`hasPwd` {
            return false
        }
        if lhs.`identicon` != rhs.`identicon` {
            return false
        }
        if lhs.`seedName` != rhs.`seedName` {
            return false
        }
        if lhs.`secretExposed` != rhs.`secretExposed` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`path`)
        hasher.combine(`hasPwd`)
        hasher.combine(`identicon`)
        hasher.combine(`seedName`)
        hasher.combine(`secretExposed`)
    }
}


public struct FfiConverterTypeAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Address {
        return try Address(
            `path`: FfiConverterString.read(from: &buf), 
            `hasPwd`: FfiConverterBool.read(from: &buf), 
            `identicon`: FfiConverterTypeSignerImage.read(from: &buf), 
            `seedName`: FfiConverterString.read(from: &buf), 
            `secretExposed`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Address, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`path`, into: &buf)
        FfiConverterBool.write(value.`hasPwd`, into: &buf)
        FfiConverterTypeSignerImage.write(value.`identicon`, into: &buf)
        FfiConverterString.write(value.`seedName`, into: &buf)
        FfiConverterBool.write(value.`secretExposed`, into: &buf)
    }
}


public struct DerivationCheck {
    public var `buttonGood`: Bool
    public var `whereTo`: DerivationDestination?
    public var `collision`: MAddressCard?
    public var `error`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`buttonGood`: Bool, `whereTo`: DerivationDestination?, `collision`: MAddressCard?, `error`: String?) {
        self.`buttonGood` = `buttonGood`
        self.`whereTo` = `whereTo`
        self.`collision` = `collision`
        self.`error` = `error`
    }
}


extension DerivationCheck: Equatable, Hashable {
    public static func ==(lhs: DerivationCheck, rhs: DerivationCheck) -> Bool {
        if lhs.`buttonGood` != rhs.`buttonGood` {
            return false
        }
        if lhs.`whereTo` != rhs.`whereTo` {
            return false
        }
        if lhs.`collision` != rhs.`collision` {
            return false
        }
        if lhs.`error` != rhs.`error` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`buttonGood`)
        hasher.combine(`whereTo`)
        hasher.combine(`collision`)
        hasher.combine(`error`)
    }
}


public struct FfiConverterTypeDerivationCheck: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationCheck {
        return try DerivationCheck(
            `buttonGood`: FfiConverterBool.read(from: &buf), 
            `whereTo`: FfiConverterOptionTypeDerivationDestination.read(from: &buf), 
            `collision`: FfiConverterOptionTypeMAddressCard.read(from: &buf), 
            `error`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: DerivationCheck, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`buttonGood`, into: &buf)
        FfiConverterOptionTypeDerivationDestination.write(value.`whereTo`, into: &buf)
        FfiConverterOptionTypeMAddressCard.write(value.`collision`, into: &buf)
        FfiConverterOptionString.write(value.`error`, into: &buf)
    }
}


public struct DerivationEntry {
    public var `path`: String
    public var `hasPwd`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`path`: String, `hasPwd`: Bool) {
        self.`path` = `path`
        self.`hasPwd` = `hasPwd`
    }
}


extension DerivationEntry: Equatable, Hashable {
    public static func ==(lhs: DerivationEntry, rhs: DerivationEntry) -> Bool {
        if lhs.`path` != rhs.`path` {
            return false
        }
        if lhs.`hasPwd` != rhs.`hasPwd` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`path`)
        hasher.combine(`hasPwd`)
    }
}


public struct FfiConverterTypeDerivationEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationEntry {
        return try DerivationEntry(
            `path`: FfiConverterString.read(from: &buf), 
            `hasPwd`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: DerivationEntry, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`path`, into: &buf)
        FfiConverterBool.write(value.`hasPwd`, into: &buf)
    }
}


public struct DerivationPack {
    public var `networkTitle`: String
    public var `networkLogo`: String
    public var `networkOrder`: String
    public var `idSet`: [DerivationEntry]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`networkTitle`: String, `networkLogo`: String, `networkOrder`: String, `idSet`: [DerivationEntry]) {
        self.`networkTitle` = `networkTitle`
        self.`networkLogo` = `networkLogo`
        self.`networkOrder` = `networkOrder`
        self.`idSet` = `idSet`
    }
}


extension DerivationPack: Equatable, Hashable {
    public static func ==(lhs: DerivationPack, rhs: DerivationPack) -> Bool {
        if lhs.`networkTitle` != rhs.`networkTitle` {
            return false
        }
        if lhs.`networkLogo` != rhs.`networkLogo` {
            return false
        }
        if lhs.`networkOrder` != rhs.`networkOrder` {
            return false
        }
        if lhs.`idSet` != rhs.`idSet` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`networkTitle`)
        hasher.combine(`networkLogo`)
        hasher.combine(`networkOrder`)
        hasher.combine(`idSet`)
    }
}


public struct FfiConverterTypeDerivationPack: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationPack {
        return try DerivationPack(
            `networkTitle`: FfiConverterString.read(from: &buf), 
            `networkLogo`: FfiConverterString.read(from: &buf), 
            `networkOrder`: FfiConverterString.read(from: &buf), 
            `idSet`: FfiConverterSequenceTypeDerivationEntry.read(from: &buf)
        )
    }

    public static func write(_ value: DerivationPack, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`networkTitle`, into: &buf)
        FfiConverterString.write(value.`networkLogo`, into: &buf)
        FfiConverterString.write(value.`networkOrder`, into: &buf)
        FfiConverterSequenceTypeDerivationEntry.write(value.`idSet`, into: &buf)
    }
}


public struct DerivedKeyPreview {
    public var `address`: String
    public var `derivationPath`: String?
    public var `encryption`: Encryption
    public var `genesisHash`: H256
    public var `identicon`: SignerImage
    public var `hasPwd`: Bool?
    public var `networkTitle`: String?
    public var `status`: DerivedKeyStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`address`: String, `derivationPath`: String?, `encryption`: Encryption, `genesisHash`: H256, `identicon`: SignerImage, `hasPwd`: Bool?, `networkTitle`: String?, `status`: DerivedKeyStatus) {
        self.`address` = `address`
        self.`derivationPath` = `derivationPath`
        self.`encryption` = `encryption`
        self.`genesisHash` = `genesisHash`
        self.`identicon` = `identicon`
        self.`hasPwd` = `hasPwd`
        self.`networkTitle` = `networkTitle`
        self.`status` = `status`
    }
}


extension DerivedKeyPreview: Equatable, Hashable {
    public static func ==(lhs: DerivedKeyPreview, rhs: DerivedKeyPreview) -> Bool {
        if lhs.`address` != rhs.`address` {
            return false
        }
        if lhs.`derivationPath` != rhs.`derivationPath` {
            return false
        }
        if lhs.`encryption` != rhs.`encryption` {
            return false
        }
        if lhs.`genesisHash` != rhs.`genesisHash` {
            return false
        }
        if lhs.`identicon` != rhs.`identicon` {
            return false
        }
        if lhs.`hasPwd` != rhs.`hasPwd` {
            return false
        }
        if lhs.`networkTitle` != rhs.`networkTitle` {
            return false
        }
        if lhs.`status` != rhs.`status` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`address`)
        hasher.combine(`derivationPath`)
        hasher.combine(`encryption`)
        hasher.combine(`genesisHash`)
        hasher.combine(`identicon`)
        hasher.combine(`hasPwd`)
        hasher.combine(`networkTitle`)
        hasher.combine(`status`)
    }
}


public struct FfiConverterTypeDerivedKeyPreview: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivedKeyPreview {
        return try DerivedKeyPreview(
            `address`: FfiConverterString.read(from: &buf), 
            `derivationPath`: FfiConverterOptionString.read(from: &buf), 
            `encryption`: FfiConverterTypeEncryption.read(from: &buf), 
            `genesisHash`: FfiConverterTypeH256.read(from: &buf), 
            `identicon`: FfiConverterTypeSignerImage.read(from: &buf), 
            `hasPwd`: FfiConverterOptionBool.read(from: &buf), 
            `networkTitle`: FfiConverterOptionString.read(from: &buf), 
            `status`: FfiConverterTypeDerivedKeyStatus.read(from: &buf)
        )
    }

    public static func write(_ value: DerivedKeyPreview, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`address`, into: &buf)
        FfiConverterOptionString.write(value.`derivationPath`, into: &buf)
        FfiConverterTypeEncryption.write(value.`encryption`, into: &buf)
        FfiConverterTypeH256.write(value.`genesisHash`, into: &buf)
        FfiConverterTypeSignerImage.write(value.`identicon`, into: &buf)
        FfiConverterOptionBool.write(value.`hasPwd`, into: &buf)
        FfiConverterOptionString.write(value.`networkTitle`, into: &buf)
        FfiConverterTypeDerivedKeyStatus.write(value.`status`, into: &buf)
    }
}


public struct History {
    public var `order`: UInt32
    public var `timestamp`: String
    public var `events`: [Event]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`order`: UInt32, `timestamp`: String, `events`: [Event]) {
        self.`order` = `order`
        self.`timestamp` = `timestamp`
        self.`events` = `events`
    }
}


extension History: Equatable, Hashable {
    public static func ==(lhs: History, rhs: History) -> Bool {
        if lhs.`order` != rhs.`order` {
            return false
        }
        if lhs.`timestamp` != rhs.`timestamp` {
            return false
        }
        if lhs.`events` != rhs.`events` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`order`)
        hasher.combine(`timestamp`)
        hasher.combine(`events`)
    }
}


public struct FfiConverterTypeHistory: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> History {
        return try History(
            `order`: FfiConverterUInt32.read(from: &buf), 
            `timestamp`: FfiConverterString.read(from: &buf), 
            `events`: FfiConverterSequenceTypeEvent.read(from: &buf)
        )
    }

    public static func write(_ value: History, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.`order`, into: &buf)
        FfiConverterString.write(value.`timestamp`, into: &buf)
        FfiConverterSequenceTypeEvent.write(value.`events`, into: &buf)
    }
}


public struct IdentityHistory {
    public var `seedName`: String
    public var `encryption`: Encryption
    public var `publicKey`: [UInt8]
    public var `path`: String
    public var `networkGenesisHash`: H256

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`seedName`: String, `encryption`: Encryption, `publicKey`: [UInt8], `path`: String, `networkGenesisHash`: H256) {
        self.`seedName` = `seedName`
        self.`encryption` = `encryption`
        self.`publicKey` = `publicKey`
        self.`path` = `path`
        self.`networkGenesisHash` = `networkGenesisHash`
    }
}


extension IdentityHistory: Equatable, Hashable {
    public static func ==(lhs: IdentityHistory, rhs: IdentityHistory) -> Bool {
        if lhs.`seedName` != rhs.`seedName` {
            return false
        }
        if lhs.`encryption` != rhs.`encryption` {
            return false
        }
        if lhs.`publicKey` != rhs.`publicKey` {
            return false
        }
        if lhs.`path` != rhs.`path` {
            return false
        }
        if lhs.`networkGenesisHash` != rhs.`networkGenesisHash` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`seedName`)
        hasher.combine(`encryption`)
        hasher.combine(`publicKey`)
        hasher.combine(`path`)
        hasher.combine(`networkGenesisHash`)
    }
}


public struct FfiConverterTypeIdentityHistory: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityHistory {
        return try IdentityHistory(
            `seedName`: FfiConverterString.read(from: &buf), 
            `encryption`: FfiConverterTypeEncryption.read(from: &buf), 
            `publicKey`: FfiConverterSequenceUInt8.read(from: &buf), 
            `path`: FfiConverterString.read(from: &buf), 
            `networkGenesisHash`: FfiConverterTypeH256.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityHistory, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`seedName`, into: &buf)
        FfiConverterTypeEncryption.write(value.`encryption`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`publicKey`, into: &buf)
        FfiConverterString.write(value.`path`, into: &buf)
        FfiConverterTypeH256.write(value.`networkGenesisHash`, into: &buf)
    }
}


public struct MAddressCard {
    public var `base58`: String
    public var `addressKey`: String
    public var `address`: Address

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`base58`: String, `addressKey`: String, `address`: Address) {
        self.`base58` = `base58`
        self.`addressKey` = `addressKey`
        self.`address` = `address`
    }
}


extension MAddressCard: Equatable, Hashable {
    public static func ==(lhs: MAddressCard, rhs: MAddressCard) -> Bool {
        if lhs.`base58` != rhs.`base58` {
            return false
        }
        if lhs.`addressKey` != rhs.`addressKey` {
            return false
        }
        if lhs.`address` != rhs.`address` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`base58`)
        hasher.combine(`addressKey`)
        hasher.combine(`address`)
    }
}


public struct FfiConverterTypeMAddressCard: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MAddressCard {
        return try MAddressCard(
            `base58`: FfiConverterString.read(from: &buf), 
            `addressKey`: FfiConverterString.read(from: &buf), 
            `address`: FfiConverterTypeAddress.read(from: &buf)
        )
    }

    public static func write(_ value: MAddressCard, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`base58`, into: &buf)
        FfiConverterString.write(value.`addressKey`, into: &buf)
        FfiConverterTypeAddress.write(value.`address`, into: &buf)
    }
}


public struct MBackup {
    public var `seedName`: String
    public var `derivations`: [DerivationPack]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`seedName`: String, `derivations`: [DerivationPack]) {
        self.`seedName` = `seedName`
        self.`derivations` = `derivations`
    }
}


extension MBackup: Equatable, Hashable {
    public static func ==(lhs: MBackup, rhs: MBackup) -> Bool {
        if lhs.`seedName` != rhs.`seedName` {
            return false
        }
        if lhs.`derivations` != rhs.`derivations` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`seedName`)
        hasher.combine(`derivations`)
    }
}


public struct FfiConverterTypeMBackup: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MBackup {
        return try MBackup(
            `seedName`: FfiConverterString.read(from: &buf), 
            `derivations`: FfiConverterSequenceTypeDerivationPack.read(from: &buf)
        )
    }

    public static func write(_ value: MBackup, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`seedName`, into: &buf)
        FfiConverterSequenceTypeDerivationPack.write(value.`derivations`, into: &buf)
    }
}


public struct MDeriveKey {
    public var `seedName`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`seedName`: String) {
        self.`seedName` = `seedName`
    }
}


extension MDeriveKey: Equatable, Hashable {
    public static func ==(lhs: MDeriveKey, rhs: MDeriveKey) -> Bool {
        if lhs.`seedName` != rhs.`seedName` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`seedName`)
    }
}


public struct FfiConverterTypeMDeriveKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MDeriveKey {
        return try MDeriveKey(
            `seedName`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MDeriveKey, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`seedName`, into: &buf)
    }
}


public struct MEnterPassword {
    public var `authorInfo`: MAddressCard
    public var `networkInfo`: MscNetworkInfo?
    public var `counter`: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`authorInfo`: MAddressCard, `networkInfo`: MscNetworkInfo?, `counter`: UInt32) {
        self.`authorInfo` = `authorInfo`
        self.`networkInfo` = `networkInfo`
        self.`counter` = `counter`
    }
}


extension MEnterPassword: Equatable, Hashable {
    public static func ==(lhs: MEnterPassword, rhs: MEnterPassword) -> Bool {
        if lhs.`authorInfo` != rhs.`authorInfo` {
            return false
        }
        if lhs.`networkInfo` != rhs.`networkInfo` {
            return false
        }
        if lhs.`counter` != rhs.`counter` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`authorInfo`)
        hasher.combine(`networkInfo`)
        hasher.combine(`counter`)
    }
}


public struct FfiConverterTypeMEnterPassword: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MEnterPassword {
        return try MEnterPassword(
            `authorInfo`: FfiConverterTypeMAddressCard.read(from: &buf), 
            `networkInfo`: FfiConverterOptionTypeMscNetworkInfo.read(from: &buf), 
            `counter`: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: MEnterPassword, into buf: inout [UInt8]) {
        FfiConverterTypeMAddressCard.write(value.`authorInfo`, into: &buf)
        FfiConverterOptionTypeMscNetworkInfo.write(value.`networkInfo`, into: &buf)
        FfiConverterUInt32.write(value.`counter`, into: &buf)
    }
}


public struct MEventMaybeDecoded {
    public var `event`: Event
    public var `signedBy`: MAddressCard?
    public var `decoded`: TransactionCardSet?
    public var `verifierDetails`: MVerifierDetails?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`event`: Event, `signedBy`: MAddressCard?, `decoded`: TransactionCardSet?, `verifierDetails`: MVerifierDetails?) {
        self.`event` = `event`
        self.`signedBy` = `signedBy`
        self.`decoded` = `decoded`
        self.`verifierDetails` = `verifierDetails`
    }
}


extension MEventMaybeDecoded: Equatable, Hashable {
    public static func ==(lhs: MEventMaybeDecoded, rhs: MEventMaybeDecoded) -> Bool {
        if lhs.`event` != rhs.`event` {
            return false
        }
        if lhs.`signedBy` != rhs.`signedBy` {
            return false
        }
        if lhs.`decoded` != rhs.`decoded` {
            return false
        }
        if lhs.`verifierDetails` != rhs.`verifierDetails` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`event`)
        hasher.combine(`signedBy`)
        hasher.combine(`decoded`)
        hasher.combine(`verifierDetails`)
    }
}


public struct FfiConverterTypeMEventMaybeDecoded: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MEventMaybeDecoded {
        return try MEventMaybeDecoded(
            `event`: FfiConverterTypeEvent.read(from: &buf), 
            `signedBy`: FfiConverterOptionTypeMAddressCard.read(from: &buf), 
            `decoded`: FfiConverterOptionTypeTransactionCardSet.read(from: &buf), 
            `verifierDetails`: FfiConverterOptionTypeMVerifierDetails.read(from: &buf)
        )
    }

    public static func write(_ value: MEventMaybeDecoded, into buf: inout [UInt8]) {
        FfiConverterTypeEvent.write(value.`event`, into: &buf)
        FfiConverterOptionTypeMAddressCard.write(value.`signedBy`, into: &buf)
        FfiConverterOptionTypeTransactionCardSet.write(value.`decoded`, into: &buf)
        FfiConverterOptionTypeMVerifierDetails.write(value.`verifierDetails`, into: &buf)
    }
}


public struct MKeyAndNetworkCard {
    public var `key`: MKeysCard
    public var `network`: MscNetworkInfo

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`key`: MKeysCard, `network`: MscNetworkInfo) {
        self.`key` = `key`
        self.`network` = `network`
    }
}


extension MKeyAndNetworkCard: Equatable, Hashable {
    public static func ==(lhs: MKeyAndNetworkCard, rhs: MKeyAndNetworkCard) -> Bool {
        if lhs.`key` != rhs.`key` {
            return false
        }
        if lhs.`network` != rhs.`network` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`key`)
        hasher.combine(`network`)
    }
}


public struct FfiConverterTypeMKeyAndNetworkCard: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MKeyAndNetworkCard {
        return try MKeyAndNetworkCard(
            `key`: FfiConverterTypeMKeysCard.read(from: &buf), 
            `network`: FfiConverterTypeMscNetworkInfo.read(from: &buf)
        )
    }

    public static func write(_ value: MKeyAndNetworkCard, into buf: inout [UInt8]) {
        FfiConverterTypeMKeysCard.write(value.`key`, into: &buf)
        FfiConverterTypeMscNetworkInfo.write(value.`network`, into: &buf)
    }
}


public struct MKeyDetails {
    public var `qr`: QrData
    public var `pubkey`: String
    public var `networkInfo`: MscNetworkInfo
    public var `address`: Address
    public var `base58`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`qr`: QrData, `pubkey`: String, `networkInfo`: MscNetworkInfo, `address`: Address, `base58`: String) {
        self.`qr` = `qr`
        self.`pubkey` = `pubkey`
        self.`networkInfo` = `networkInfo`
        self.`address` = `address`
        self.`base58` = `base58`
    }
}


extension MKeyDetails: Equatable, Hashable {
    public static func ==(lhs: MKeyDetails, rhs: MKeyDetails) -> Bool {
        if lhs.`qr` != rhs.`qr` {
            return false
        }
        if lhs.`pubkey` != rhs.`pubkey` {
            return false
        }
        if lhs.`networkInfo` != rhs.`networkInfo` {
            return false
        }
        if lhs.`address` != rhs.`address` {
            return false
        }
        if lhs.`base58` != rhs.`base58` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`qr`)
        hasher.combine(`pubkey`)
        hasher.combine(`networkInfo`)
        hasher.combine(`address`)
        hasher.combine(`base58`)
    }
}


public struct FfiConverterTypeMKeyDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MKeyDetails {
        return try MKeyDetails(
            `qr`: FfiConverterTypeQrData.read(from: &buf), 
            `pubkey`: FfiConverterString.read(from: &buf), 
            `networkInfo`: FfiConverterTypeMscNetworkInfo.read(from: &buf), 
            `address`: FfiConverterTypeAddress.read(from: &buf), 
            `base58`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MKeyDetails, into buf: inout [UInt8]) {
        FfiConverterTypeQrData.write(value.`qr`, into: &buf)
        FfiConverterString.write(value.`pubkey`, into: &buf)
        FfiConverterTypeMscNetworkInfo.write(value.`networkInfo`, into: &buf)
        FfiConverterTypeAddress.write(value.`address`, into: &buf)
        FfiConverterString.write(value.`base58`, into: &buf)
    }
}


public struct MKeyDetailsMulti {
    public var `keyDetails`: MKeyDetails
    public var `currentNumber`: String
    public var `outOf`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`keyDetails`: MKeyDetails, `currentNumber`: String, `outOf`: String) {
        self.`keyDetails` = `keyDetails`
        self.`currentNumber` = `currentNumber`
        self.`outOf` = `outOf`
    }
}


extension MKeyDetailsMulti: Equatable, Hashable {
    public static func ==(lhs: MKeyDetailsMulti, rhs: MKeyDetailsMulti) -> Bool {
        if lhs.`keyDetails` != rhs.`keyDetails` {
            return false
        }
        if lhs.`currentNumber` != rhs.`currentNumber` {
            return false
        }
        if lhs.`outOf` != rhs.`outOf` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`keyDetails`)
        hasher.combine(`currentNumber`)
        hasher.combine(`outOf`)
    }
}


public struct FfiConverterTypeMKeyDetailsMulti: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MKeyDetailsMulti {
        return try MKeyDetailsMulti(
            `keyDetails`: FfiConverterTypeMKeyDetails.read(from: &buf), 
            `currentNumber`: FfiConverterString.read(from: &buf), 
            `outOf`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MKeyDetailsMulti, into buf: inout [UInt8]) {
        FfiConverterTypeMKeyDetails.write(value.`keyDetails`, into: &buf)
        FfiConverterString.write(value.`currentNumber`, into: &buf)
        FfiConverterString.write(value.`outOf`, into: &buf)
    }
}


public struct MKeysCard {
    public var `address`: Address
    public var `addressKey`: String
    public var `base58`: String
    public var `swiped`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`address`: Address, `addressKey`: String, `base58`: String, `swiped`: Bool) {
        self.`address` = `address`
        self.`addressKey` = `addressKey`
        self.`base58` = `base58`
        self.`swiped` = `swiped`
    }
}


extension MKeysCard: Equatable, Hashable {
    public static func ==(lhs: MKeysCard, rhs: MKeysCard) -> Bool {
        if lhs.`address` != rhs.`address` {
            return false
        }
        if lhs.`addressKey` != rhs.`addressKey` {
            return false
        }
        if lhs.`base58` != rhs.`base58` {
            return false
        }
        if lhs.`swiped` != rhs.`swiped` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`address`)
        hasher.combine(`addressKey`)
        hasher.combine(`base58`)
        hasher.combine(`swiped`)
    }
}


public struct FfiConverterTypeMKeysCard: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MKeysCard {
        return try MKeysCard(
            `address`: FfiConverterTypeAddress.read(from: &buf), 
            `addressKey`: FfiConverterString.read(from: &buf), 
            `base58`: FfiConverterString.read(from: &buf), 
            `swiped`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: MKeysCard, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.`address`, into: &buf)
        FfiConverterString.write(value.`addressKey`, into: &buf)
        FfiConverterString.write(value.`base58`, into: &buf)
        FfiConverterBool.write(value.`swiped`, into: &buf)
    }
}


public struct MKeysInfoExport {
    public var `frames`: [QrData]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`frames`: [QrData]) {
        self.`frames` = `frames`
    }
}


extension MKeysInfoExport: Equatable, Hashable {
    public static func ==(lhs: MKeysInfoExport, rhs: MKeysInfoExport) -> Bool {
        if lhs.`frames` != rhs.`frames` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`frames`)
    }
}


public struct FfiConverterTypeMKeysInfoExport: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MKeysInfoExport {
        return try MKeysInfoExport(
            `frames`: FfiConverterSequenceTypeQrData.read(from: &buf)
        )
    }

    public static func write(_ value: MKeysInfoExport, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeQrData.write(value.`frames`, into: &buf)
    }
}


public struct MKeysNew {
    public var `root`: MAddressCard?
    public var `set`: [MKeyAndNetworkCard]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`root`: MAddressCard?, `set`: [MKeyAndNetworkCard]) {
        self.`root` = `root`
        self.`set` = `set`
    }
}


extension MKeysNew: Equatable, Hashable {
    public static func ==(lhs: MKeysNew, rhs: MKeysNew) -> Bool {
        if lhs.`root` != rhs.`root` {
            return false
        }
        if lhs.`set` != rhs.`set` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`root`)
        hasher.combine(`set`)
    }
}


public struct FfiConverterTypeMKeysNew: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MKeysNew {
        return try MKeysNew(
            `root`: FfiConverterOptionTypeMAddressCard.read(from: &buf), 
            `set`: FfiConverterSequenceTypeMKeyAndNetworkCard.read(from: &buf)
        )
    }

    public static func write(_ value: MKeysNew, into buf: inout [UInt8]) {
        FfiConverterOptionTypeMAddressCard.write(value.`root`, into: &buf)
        FfiConverterSequenceTypeMKeyAndNetworkCard.write(value.`set`, into: &buf)
    }
}


public struct MLog {
    public var `log`: [History]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`log`: [History]) {
        self.`log` = `log`
    }
}


extension MLog: Equatable, Hashable {
    public static func ==(lhs: MLog, rhs: MLog) -> Bool {
        if lhs.`log` != rhs.`log` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`log`)
    }
}


public struct FfiConverterTypeMLog: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MLog {
        return try MLog(
            `log`: FfiConverterSequenceTypeHistory.read(from: &buf)
        )
    }

    public static func write(_ value: MLog, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeHistory.write(value.`log`, into: &buf)
    }
}


public struct MLogDetails {
    public var `timestamp`: String
    public var `events`: [MEventMaybeDecoded]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`timestamp`: String, `events`: [MEventMaybeDecoded]) {
        self.`timestamp` = `timestamp`
        self.`events` = `events`
    }
}


extension MLogDetails: Equatable, Hashable {
    public static func ==(lhs: MLogDetails, rhs: MLogDetails) -> Bool {
        if lhs.`timestamp` != rhs.`timestamp` {
            return false
        }
        if lhs.`events` != rhs.`events` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`timestamp`)
        hasher.combine(`events`)
    }
}


public struct FfiConverterTypeMLogDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MLogDetails {
        return try MLogDetails(
            `timestamp`: FfiConverterString.read(from: &buf), 
            `events`: FfiConverterSequenceTypeMEventMaybeDecoded.read(from: &buf)
        )
    }

    public static func write(_ value: MLogDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`timestamp`, into: &buf)
        FfiConverterSequenceTypeMEventMaybeDecoded.write(value.`events`, into: &buf)
    }
}


public struct MLogRight {
    public var `checksum`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`checksum`: String) {
        self.`checksum` = `checksum`
    }
}


extension MLogRight: Equatable, Hashable {
    public static func ==(lhs: MLogRight, rhs: MLogRight) -> Bool {
        if lhs.`checksum` != rhs.`checksum` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`checksum`)
    }
}


public struct FfiConverterTypeMLogRight: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MLogRight {
        return try MLogRight(
            `checksum`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MLogRight, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`checksum`, into: &buf)
    }
}


public struct MmmNetwork {
    public var `title`: String
    public var `logo`: String
    public var `order`: UInt32
    public var `currentOnScreen`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`title`: String, `logo`: String, `order`: UInt32, `currentOnScreen`: Bool) {
        self.`title` = `title`
        self.`logo` = `logo`
        self.`order` = `order`
        self.`currentOnScreen` = `currentOnScreen`
    }
}


extension MmmNetwork: Equatable, Hashable {
    public static func ==(lhs: MmmNetwork, rhs: MmmNetwork) -> Bool {
        if lhs.`title` != rhs.`title` {
            return false
        }
        if lhs.`logo` != rhs.`logo` {
            return false
        }
        if lhs.`order` != rhs.`order` {
            return false
        }
        if lhs.`currentOnScreen` != rhs.`currentOnScreen` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`title`)
        hasher.combine(`logo`)
        hasher.combine(`order`)
        hasher.combine(`currentOnScreen`)
    }
}


public struct FfiConverterTypeMmmNetwork: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MmmNetwork {
        return try MmmNetwork(
            `title`: FfiConverterString.read(from: &buf), 
            `logo`: FfiConverterString.read(from: &buf), 
            `order`: FfiConverterUInt32.read(from: &buf), 
            `currentOnScreen`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: MmmNetwork, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`title`, into: &buf)
        FfiConverterString.write(value.`logo`, into: &buf)
        FfiConverterUInt32.write(value.`order`, into: &buf)
        FfiConverterBool.write(value.`currentOnScreen`, into: &buf)
    }
}


public struct MmNetwork {
    public var `key`: String
    public var `title`: String
    public var `logo`: String
    public var `order`: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`key`: String, `title`: String, `logo`: String, `order`: UInt8) {
        self.`key` = `key`
        self.`title` = `title`
        self.`logo` = `logo`
        self.`order` = `order`
    }
}


extension MmNetwork: Equatable, Hashable {
    public static func ==(lhs: MmNetwork, rhs: MmNetwork) -> Bool {
        if lhs.`key` != rhs.`key` {
            return false
        }
        if lhs.`title` != rhs.`title` {
            return false
        }
        if lhs.`logo` != rhs.`logo` {
            return false
        }
        if lhs.`order` != rhs.`order` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`key`)
        hasher.combine(`title`)
        hasher.combine(`logo`)
        hasher.combine(`order`)
    }
}


public struct FfiConverterTypeMmNetwork: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MmNetwork {
        return try MmNetwork(
            `key`: FfiConverterString.read(from: &buf), 
            `title`: FfiConverterString.read(from: &buf), 
            `logo`: FfiConverterString.read(from: &buf), 
            `order`: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: MmNetwork, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`key`, into: &buf)
        FfiConverterString.write(value.`title`, into: &buf)
        FfiConverterString.write(value.`logo`, into: &buf)
        FfiConverterUInt8.write(value.`order`, into: &buf)
    }
}


public struct MManageMetadata {
    public var `name`: String
    public var `version`: String
    public var `metaHash`: String
    public var `metaIdPic`: SignerImage
    public var `networks`: [MmmNetwork]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: String, `version`: String, `metaHash`: String, `metaIdPic`: SignerImage, `networks`: [MmmNetwork]) {
        self.`name` = `name`
        self.`version` = `version`
        self.`metaHash` = `metaHash`
        self.`metaIdPic` = `metaIdPic`
        self.`networks` = `networks`
    }
}


extension MManageMetadata: Equatable, Hashable {
    public static func ==(lhs: MManageMetadata, rhs: MManageMetadata) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`version` != rhs.`version` {
            return false
        }
        if lhs.`metaHash` != rhs.`metaHash` {
            return false
        }
        if lhs.`metaIdPic` != rhs.`metaIdPic` {
            return false
        }
        if lhs.`networks` != rhs.`networks` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
        hasher.combine(`version`)
        hasher.combine(`metaHash`)
        hasher.combine(`metaIdPic`)
        hasher.combine(`networks`)
    }
}


public struct FfiConverterTypeMManageMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MManageMetadata {
        return try MManageMetadata(
            `name`: FfiConverterString.read(from: &buf), 
            `version`: FfiConverterString.read(from: &buf), 
            `metaHash`: FfiConverterString.read(from: &buf), 
            `metaIdPic`: FfiConverterTypeSignerImage.read(from: &buf), 
            `networks`: FfiConverterSequenceTypeMmmNetwork.read(from: &buf)
        )
    }

    public static func write(_ value: MManageMetadata, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterString.write(value.`version`, into: &buf)
        FfiConverterString.write(value.`metaHash`, into: &buf)
        FfiConverterTypeSignerImage.write(value.`metaIdPic`, into: &buf)
        FfiConverterSequenceTypeMmmNetwork.write(value.`networks`, into: &buf)
    }
}


public struct MManageNetworks {
    public var `networks`: [MmNetwork]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`networks`: [MmNetwork]) {
        self.`networks` = `networks`
    }
}


extension MManageNetworks: Equatable, Hashable {
    public static func ==(lhs: MManageNetworks, rhs: MManageNetworks) -> Bool {
        if lhs.`networks` != rhs.`networks` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`networks`)
    }
}


public struct FfiConverterTypeMManageNetworks: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MManageNetworks {
        return try MManageNetworks(
            `networks`: FfiConverterSequenceTypeMmNetwork.read(from: &buf)
        )
    }

    public static func write(_ value: MManageNetworks, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeMmNetwork.write(value.`networks`, into: &buf)
    }
}


public struct MMetadataRecord {
    public var `specname`: String
    public var `specsVersion`: String
    public var `metaHash`: String
    public var `metaIdPic`: SignerImage

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`specname`: String, `specsVersion`: String, `metaHash`: String, `metaIdPic`: SignerImage) {
        self.`specname` = `specname`
        self.`specsVersion` = `specsVersion`
        self.`metaHash` = `metaHash`
        self.`metaIdPic` = `metaIdPic`
    }
}


extension MMetadataRecord: Equatable, Hashable {
    public static func ==(lhs: MMetadataRecord, rhs: MMetadataRecord) -> Bool {
        if lhs.`specname` != rhs.`specname` {
            return false
        }
        if lhs.`specsVersion` != rhs.`specsVersion` {
            return false
        }
        if lhs.`metaHash` != rhs.`metaHash` {
            return false
        }
        if lhs.`metaIdPic` != rhs.`metaIdPic` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`specname`)
        hasher.combine(`specsVersion`)
        hasher.combine(`metaHash`)
        hasher.combine(`metaIdPic`)
    }
}


public struct FfiConverterTypeMMetadataRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MMetadataRecord {
        return try MMetadataRecord(
            `specname`: FfiConverterString.read(from: &buf), 
            `specsVersion`: FfiConverterString.read(from: &buf), 
            `metaHash`: FfiConverterString.read(from: &buf), 
            `metaIdPic`: FfiConverterTypeSignerImage.read(from: &buf)
        )
    }

    public static func write(_ value: MMetadataRecord, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`specname`, into: &buf)
        FfiConverterString.write(value.`specsVersion`, into: &buf)
        FfiConverterString.write(value.`metaHash`, into: &buf)
        FfiConverterTypeSignerImage.write(value.`metaIdPic`, into: &buf)
    }
}


public struct MNetworkCard {
    public var `title`: String
    public var `logo`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`title`: String, `logo`: String) {
        self.`title` = `title`
        self.`logo` = `logo`
    }
}


extension MNetworkCard: Equatable, Hashable {
    public static func ==(lhs: MNetworkCard, rhs: MNetworkCard) -> Bool {
        if lhs.`title` != rhs.`title` {
            return false
        }
        if lhs.`logo` != rhs.`logo` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`title`)
        hasher.combine(`logo`)
    }
}


public struct FfiConverterTypeMNetworkCard: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MNetworkCard {
        return try MNetworkCard(
            `title`: FfiConverterString.read(from: &buf), 
            `logo`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MNetworkCard, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`title`, into: &buf)
        FfiConverterString.write(value.`logo`, into: &buf)
    }
}


public struct MNetworkDetails {
    public var `base58prefix`: UInt16
    public var `color`: String
    public var `decimals`: UInt8
    public var `encryption`: Encryption
    public var `genesisHash`: H256
    public var `logo`: String
    public var `name`: String
    public var `order`: String
    public var `pathId`: String
    public var `secondaryColor`: String
    public var `title`: String
    public var `unit`: String
    public var `currentVerifier`: MVerifier
    public var `meta`: [MMetadataRecord]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`base58prefix`: UInt16, `color`: String, `decimals`: UInt8, `encryption`: Encryption, `genesisHash`: H256, `logo`: String, `name`: String, `order`: String, `pathId`: String, `secondaryColor`: String, `title`: String, `unit`: String, `currentVerifier`: MVerifier, `meta`: [MMetadataRecord]) {
        self.`base58prefix` = `base58prefix`
        self.`color` = `color`
        self.`decimals` = `decimals`
        self.`encryption` = `encryption`
        self.`genesisHash` = `genesisHash`
        self.`logo` = `logo`
        self.`name` = `name`
        self.`order` = `order`
        self.`pathId` = `pathId`
        self.`secondaryColor` = `secondaryColor`
        self.`title` = `title`
        self.`unit` = `unit`
        self.`currentVerifier` = `currentVerifier`
        self.`meta` = `meta`
    }
}


extension MNetworkDetails: Equatable, Hashable {
    public static func ==(lhs: MNetworkDetails, rhs: MNetworkDetails) -> Bool {
        if lhs.`base58prefix` != rhs.`base58prefix` {
            return false
        }
        if lhs.`color` != rhs.`color` {
            return false
        }
        if lhs.`decimals` != rhs.`decimals` {
            return false
        }
        if lhs.`encryption` != rhs.`encryption` {
            return false
        }
        if lhs.`genesisHash` != rhs.`genesisHash` {
            return false
        }
        if lhs.`logo` != rhs.`logo` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`order` != rhs.`order` {
            return false
        }
        if lhs.`pathId` != rhs.`pathId` {
            return false
        }
        if lhs.`secondaryColor` != rhs.`secondaryColor` {
            return false
        }
        if lhs.`title` != rhs.`title` {
            return false
        }
        if lhs.`unit` != rhs.`unit` {
            return false
        }
        if lhs.`currentVerifier` != rhs.`currentVerifier` {
            return false
        }
        if lhs.`meta` != rhs.`meta` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`base58prefix`)
        hasher.combine(`color`)
        hasher.combine(`decimals`)
        hasher.combine(`encryption`)
        hasher.combine(`genesisHash`)
        hasher.combine(`logo`)
        hasher.combine(`name`)
        hasher.combine(`order`)
        hasher.combine(`pathId`)
        hasher.combine(`secondaryColor`)
        hasher.combine(`title`)
        hasher.combine(`unit`)
        hasher.combine(`currentVerifier`)
        hasher.combine(`meta`)
    }
}


public struct FfiConverterTypeMNetworkDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MNetworkDetails {
        return try MNetworkDetails(
            `base58prefix`: FfiConverterUInt16.read(from: &buf), 
            `color`: FfiConverterString.read(from: &buf), 
            `decimals`: FfiConverterUInt8.read(from: &buf), 
            `encryption`: FfiConverterTypeEncryption.read(from: &buf), 
            `genesisHash`: FfiConverterTypeH256.read(from: &buf), 
            `logo`: FfiConverterString.read(from: &buf), 
            `name`: FfiConverterString.read(from: &buf), 
            `order`: FfiConverterString.read(from: &buf), 
            `pathId`: FfiConverterString.read(from: &buf), 
            `secondaryColor`: FfiConverterString.read(from: &buf), 
            `title`: FfiConverterString.read(from: &buf), 
            `unit`: FfiConverterString.read(from: &buf), 
            `currentVerifier`: FfiConverterTypeMVerifier.read(from: &buf), 
            `meta`: FfiConverterSequenceTypeMMetadataRecord.read(from: &buf)
        )
    }

    public static func write(_ value: MNetworkDetails, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.`base58prefix`, into: &buf)
        FfiConverterString.write(value.`color`, into: &buf)
        FfiConverterUInt8.write(value.`decimals`, into: &buf)
        FfiConverterTypeEncryption.write(value.`encryption`, into: &buf)
        FfiConverterTypeH256.write(value.`genesisHash`, into: &buf)
        FfiConverterString.write(value.`logo`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterString.write(value.`order`, into: &buf)
        FfiConverterString.write(value.`pathId`, into: &buf)
        FfiConverterString.write(value.`secondaryColor`, into: &buf)
        FfiConverterString.write(value.`title`, into: &buf)
        FfiConverterString.write(value.`unit`, into: &buf)
        FfiConverterTypeMVerifier.write(value.`currentVerifier`, into: &buf)
        FfiConverterSequenceTypeMMetadataRecord.write(value.`meta`, into: &buf)
    }
}


public struct MNetworkMenu {
    public var `networks`: [Network]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`networks`: [Network]) {
        self.`networks` = `networks`
    }
}


extension MNetworkMenu: Equatable, Hashable {
    public static func ==(lhs: MNetworkMenu, rhs: MNetworkMenu) -> Bool {
        if lhs.`networks` != rhs.`networks` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`networks`)
    }
}


public struct FfiConverterTypeMNetworkMenu: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MNetworkMenu {
        return try MNetworkMenu(
            `networks`: FfiConverterSequenceTypeNetwork.read(from: &buf)
        )
    }

    public static func write(_ value: MNetworkMenu, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeNetwork.write(value.`networks`, into: &buf)
    }
}


public struct MNewSeed {
    public var `keyboard`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`keyboard`: Bool) {
        self.`keyboard` = `keyboard`
    }
}


extension MNewSeed: Equatable, Hashable {
    public static func ==(lhs: MNewSeed, rhs: MNewSeed) -> Bool {
        if lhs.`keyboard` != rhs.`keyboard` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`keyboard`)
    }
}


public struct FfiConverterTypeMNewSeed: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MNewSeed {
        return try MNewSeed(
            `keyboard`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: MNewSeed, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`keyboard`, into: &buf)
    }
}


public struct MNewSeedBackup {
    public var `seed`: String
    public var `seedPhrase`: String
    public var `identicon`: SignerImage

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`seed`: String, `seedPhrase`: String, `identicon`: SignerImage) {
        self.`seed` = `seed`
        self.`seedPhrase` = `seedPhrase`
        self.`identicon` = `identicon`
    }
}


extension MNewSeedBackup: Equatable, Hashable {
    public static func ==(lhs: MNewSeedBackup, rhs: MNewSeedBackup) -> Bool {
        if lhs.`seed` != rhs.`seed` {
            return false
        }
        if lhs.`seedPhrase` != rhs.`seedPhrase` {
            return false
        }
        if lhs.`identicon` != rhs.`identicon` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`seed`)
        hasher.combine(`seedPhrase`)
        hasher.combine(`identicon`)
    }
}


public struct FfiConverterTypeMNewSeedBackup: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MNewSeedBackup {
        return try MNewSeedBackup(
            `seed`: FfiConverterString.read(from: &buf), 
            `seedPhrase`: FfiConverterString.read(from: &buf), 
            `identicon`: FfiConverterTypeSignerImage.read(from: &buf)
        )
    }

    public static func write(_ value: MNewSeedBackup, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`seed`, into: &buf)
        FfiConverterString.write(value.`seedPhrase`, into: &buf)
        FfiConverterTypeSignerImage.write(value.`identicon`, into: &buf)
    }
}


public struct MPasswordConfirm {
    public var `pwd`: String
    public var `seedName`: String
    public var `croppedPath`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`pwd`: String, `seedName`: String, `croppedPath`: String) {
        self.`pwd` = `pwd`
        self.`seedName` = `seedName`
        self.`croppedPath` = `croppedPath`
    }
}


extension MPasswordConfirm: Equatable, Hashable {
    public static func ==(lhs: MPasswordConfirm, rhs: MPasswordConfirm) -> Bool {
        if lhs.`pwd` != rhs.`pwd` {
            return false
        }
        if lhs.`seedName` != rhs.`seedName` {
            return false
        }
        if lhs.`croppedPath` != rhs.`croppedPath` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`pwd`)
        hasher.combine(`seedName`)
        hasher.combine(`croppedPath`)
    }
}


public struct FfiConverterTypeMPasswordConfirm: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MPasswordConfirm {
        return try MPasswordConfirm(
            `pwd`: FfiConverterString.read(from: &buf), 
            `seedName`: FfiConverterString.read(from: &buf), 
            `croppedPath`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MPasswordConfirm, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`pwd`, into: &buf)
        FfiConverterString.write(value.`seedName`, into: &buf)
        FfiConverterString.write(value.`croppedPath`, into: &buf)
    }
}


public struct MRawKey {
    public var `address`: Address
    public var `addressKey`: String
    public var `publicKey`: String
    public var `networkLogo`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`address`: Address, `addressKey`: String, `publicKey`: String, `networkLogo`: String) {
        self.`address` = `address`
        self.`addressKey` = `addressKey`
        self.`publicKey` = `publicKey`
        self.`networkLogo` = `networkLogo`
    }
}


extension MRawKey: Equatable, Hashable {
    public static func ==(lhs: MRawKey, rhs: MRawKey) -> Bool {
        if lhs.`address` != rhs.`address` {
            return false
        }
        if lhs.`addressKey` != rhs.`addressKey` {
            return false
        }
        if lhs.`publicKey` != rhs.`publicKey` {
            return false
        }
        if lhs.`networkLogo` != rhs.`networkLogo` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`address`)
        hasher.combine(`addressKey`)
        hasher.combine(`publicKey`)
        hasher.combine(`networkLogo`)
    }
}


public struct FfiConverterTypeMRawKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MRawKey {
        return try MRawKey(
            `address`: FfiConverterTypeAddress.read(from: &buf), 
            `addressKey`: FfiConverterString.read(from: &buf), 
            `publicKey`: FfiConverterString.read(from: &buf), 
            `networkLogo`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MRawKey, into buf: inout [UInt8]) {
        FfiConverterTypeAddress.write(value.`address`, into: &buf)
        FfiConverterString.write(value.`addressKey`, into: &buf)
        FfiConverterString.write(value.`publicKey`, into: &buf)
        FfiConverterString.write(value.`networkLogo`, into: &buf)
    }
}


public struct MRecoverSeedName {
    public var `keyboard`: Bool
    public var `seedName`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`keyboard`: Bool, `seedName`: String) {
        self.`keyboard` = `keyboard`
        self.`seedName` = `seedName`
    }
}


extension MRecoverSeedName: Equatable, Hashable {
    public static func ==(lhs: MRecoverSeedName, rhs: MRecoverSeedName) -> Bool {
        if lhs.`keyboard` != rhs.`keyboard` {
            return false
        }
        if lhs.`seedName` != rhs.`seedName` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`keyboard`)
        hasher.combine(`seedName`)
    }
}


public struct FfiConverterTypeMRecoverSeedName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MRecoverSeedName {
        return try MRecoverSeedName(
            `keyboard`: FfiConverterBool.read(from: &buf), 
            `seedName`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MRecoverSeedName, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`keyboard`, into: &buf)
        FfiConverterString.write(value.`seedName`, into: &buf)
    }
}


public struct MRecoverSeedPhrase {
    public var `keyboard`: Bool
    public var `seedName`: String
    public var `userInput`: String
    public var `guessSet`: [String]
    public var `draft`: [String]
    public var `readySeed`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`keyboard`: Bool, `seedName`: String, `userInput`: String, `guessSet`: [String], `draft`: [String], `readySeed`: String?) {
        self.`keyboard` = `keyboard`
        self.`seedName` = `seedName`
        self.`userInput` = `userInput`
        self.`guessSet` = `guessSet`
        self.`draft` = `draft`
        self.`readySeed` = `readySeed`
    }
}


extension MRecoverSeedPhrase: Equatable, Hashable {
    public static func ==(lhs: MRecoverSeedPhrase, rhs: MRecoverSeedPhrase) -> Bool {
        if lhs.`keyboard` != rhs.`keyboard` {
            return false
        }
        if lhs.`seedName` != rhs.`seedName` {
            return false
        }
        if lhs.`userInput` != rhs.`userInput` {
            return false
        }
        if lhs.`guessSet` != rhs.`guessSet` {
            return false
        }
        if lhs.`draft` != rhs.`draft` {
            return false
        }
        if lhs.`readySeed` != rhs.`readySeed` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`keyboard`)
        hasher.combine(`seedName`)
        hasher.combine(`userInput`)
        hasher.combine(`guessSet`)
        hasher.combine(`draft`)
        hasher.combine(`readySeed`)
    }
}


public struct FfiConverterTypeMRecoverSeedPhrase: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MRecoverSeedPhrase {
        return try MRecoverSeedPhrase(
            `keyboard`: FfiConverterBool.read(from: &buf), 
            `seedName`: FfiConverterString.read(from: &buf), 
            `userInput`: FfiConverterString.read(from: &buf), 
            `guessSet`: FfiConverterSequenceString.read(from: &buf), 
            `draft`: FfiConverterSequenceString.read(from: &buf), 
            `readySeed`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: MRecoverSeedPhrase, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`keyboard`, into: &buf)
        FfiConverterString.write(value.`seedName`, into: &buf)
        FfiConverterString.write(value.`userInput`, into: &buf)
        FfiConverterSequenceString.write(value.`guessSet`, into: &buf)
        FfiConverterSequenceString.write(value.`draft`, into: &buf)
        FfiConverterOptionString.write(value.`readySeed`, into: &buf)
    }
}


public struct MscCall {
    public var `methodName`: String
    public var `docs`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`methodName`: String, `docs`: String) {
        self.`methodName` = `methodName`
        self.`docs` = `docs`
    }
}


extension MscCall: Equatable, Hashable {
    public static func ==(lhs: MscCall, rhs: MscCall) -> Bool {
        if lhs.`methodName` != rhs.`methodName` {
            return false
        }
        if lhs.`docs` != rhs.`docs` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`methodName`)
        hasher.combine(`docs`)
    }
}


public struct FfiConverterTypeMscCall: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MscCall {
        return try MscCall(
            `methodName`: FfiConverterString.read(from: &buf), 
            `docs`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MscCall, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`methodName`, into: &buf)
        FfiConverterString.write(value.`docs`, into: &buf)
    }
}


public struct MscCurrency {
    public var `amount`: String
    public var `units`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`amount`: String, `units`: String) {
        self.`amount` = `amount`
        self.`units` = `units`
    }
}


extension MscCurrency: Equatable, Hashable {
    public static func ==(lhs: MscCurrency, rhs: MscCurrency) -> Bool {
        if lhs.`amount` != rhs.`amount` {
            return false
        }
        if lhs.`units` != rhs.`units` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`amount`)
        hasher.combine(`units`)
    }
}


public struct FfiConverterTypeMscCurrency: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MscCurrency {
        return try MscCurrency(
            `amount`: FfiConverterString.read(from: &buf), 
            `units`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MscCurrency, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`amount`, into: &buf)
        FfiConverterString.write(value.`units`, into: &buf)
    }
}


public struct MscEnumVariantName {
    public var `name`: String
    public var `docsEnumVariant`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: String, `docsEnumVariant`: String) {
        self.`name` = `name`
        self.`docsEnumVariant` = `docsEnumVariant`
    }
}


extension MscEnumVariantName: Equatable, Hashable {
    public static func ==(lhs: MscEnumVariantName, rhs: MscEnumVariantName) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`docsEnumVariant` != rhs.`docsEnumVariant` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
        hasher.combine(`docsEnumVariant`)
    }
}


public struct FfiConverterTypeMscEnumVariantName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MscEnumVariantName {
        return try MscEnumVariantName(
            `name`: FfiConverterString.read(from: &buf), 
            `docsEnumVariant`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MscEnumVariantName, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterString.write(value.`docsEnumVariant`, into: &buf)
    }
}


public struct MscEraMortal {
    public var `era`: String
    public var `phase`: String
    public var `period`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`era`: String, `phase`: String, `period`: String) {
        self.`era` = `era`
        self.`phase` = `phase`
        self.`period` = `period`
    }
}


extension MscEraMortal: Equatable, Hashable {
    public static func ==(lhs: MscEraMortal, rhs: MscEraMortal) -> Bool {
        if lhs.`era` != rhs.`era` {
            return false
        }
        if lhs.`phase` != rhs.`phase` {
            return false
        }
        if lhs.`period` != rhs.`period` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`era`)
        hasher.combine(`phase`)
        hasher.combine(`period`)
    }
}


public struct FfiConverterTypeMscEraMortal: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MscEraMortal {
        return try MscEraMortal(
            `era`: FfiConverterString.read(from: &buf), 
            `phase`: FfiConverterString.read(from: &buf), 
            `period`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MscEraMortal, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`era`, into: &buf)
        FfiConverterString.write(value.`phase`, into: &buf)
        FfiConverterString.write(value.`period`, into: &buf)
    }
}


public struct MscFieldName {
    public var `name`: String
    public var `docsFieldName`: String
    public var `pathType`: String
    public var `docsType`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: String, `docsFieldName`: String, `pathType`: String, `docsType`: String) {
        self.`name` = `name`
        self.`docsFieldName` = `docsFieldName`
        self.`pathType` = `pathType`
        self.`docsType` = `docsType`
    }
}


extension MscFieldName: Equatable, Hashable {
    public static func ==(lhs: MscFieldName, rhs: MscFieldName) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`docsFieldName` != rhs.`docsFieldName` {
            return false
        }
        if lhs.`pathType` != rhs.`pathType` {
            return false
        }
        if lhs.`docsType` != rhs.`docsType` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
        hasher.combine(`docsFieldName`)
        hasher.combine(`pathType`)
        hasher.combine(`docsType`)
    }
}


public struct FfiConverterTypeMscFieldName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MscFieldName {
        return try MscFieldName(
            `name`: FfiConverterString.read(from: &buf), 
            `docsFieldName`: FfiConverterString.read(from: &buf), 
            `pathType`: FfiConverterString.read(from: &buf), 
            `docsType`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MscFieldName, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterString.write(value.`docsFieldName`, into: &buf)
        FfiConverterString.write(value.`pathType`, into: &buf)
        FfiConverterString.write(value.`docsType`, into: &buf)
    }
}


public struct MscFieldNumber {
    public var `number`: String
    public var `docsFieldNumber`: String
    public var `pathType`: String
    public var `docsType`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`number`: String, `docsFieldNumber`: String, `pathType`: String, `docsType`: String) {
        self.`number` = `number`
        self.`docsFieldNumber` = `docsFieldNumber`
        self.`pathType` = `pathType`
        self.`docsType` = `docsType`
    }
}


extension MscFieldNumber: Equatable, Hashable {
    public static func ==(lhs: MscFieldNumber, rhs: MscFieldNumber) -> Bool {
        if lhs.`number` != rhs.`number` {
            return false
        }
        if lhs.`docsFieldNumber` != rhs.`docsFieldNumber` {
            return false
        }
        if lhs.`pathType` != rhs.`pathType` {
            return false
        }
        if lhs.`docsType` != rhs.`docsType` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`number`)
        hasher.combine(`docsFieldNumber`)
        hasher.combine(`pathType`)
        hasher.combine(`docsType`)
    }
}


public struct FfiConverterTypeMscFieldNumber: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MscFieldNumber {
        return try MscFieldNumber(
            `number`: FfiConverterString.read(from: &buf), 
            `docsFieldNumber`: FfiConverterString.read(from: &buf), 
            `pathType`: FfiConverterString.read(from: &buf), 
            `docsType`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MscFieldNumber, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`number`, into: &buf)
        FfiConverterString.write(value.`docsFieldNumber`, into: &buf)
        FfiConverterString.write(value.`pathType`, into: &buf)
        FfiConverterString.write(value.`docsType`, into: &buf)
    }
}


public struct MscId {
    public var `base58`: String
    public var `identicon`: SignerImage

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`base58`: String, `identicon`: SignerImage) {
        self.`base58` = `base58`
        self.`identicon` = `identicon`
    }
}


extension MscId: Equatable, Hashable {
    public static func ==(lhs: MscId, rhs: MscId) -> Bool {
        if lhs.`base58` != rhs.`base58` {
            return false
        }
        if lhs.`identicon` != rhs.`identicon` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`base58`)
        hasher.combine(`identicon`)
    }
}


public struct FfiConverterTypeMscId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MscId {
        return try MscId(
            `base58`: FfiConverterString.read(from: &buf), 
            `identicon`: FfiConverterTypeSignerImage.read(from: &buf)
        )
    }

    public static func write(_ value: MscId, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`base58`, into: &buf)
        FfiConverterTypeSignerImage.write(value.`identicon`, into: &buf)
    }
}


public struct MscNameVersion {
    public var `name`: String
    public var `version`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: String, `version`: String) {
        self.`name` = `name`
        self.`version` = `version`
    }
}


extension MscNameVersion: Equatable, Hashable {
    public static func ==(lhs: MscNameVersion, rhs: MscNameVersion) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`version` != rhs.`version` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
        hasher.combine(`version`)
    }
}


public struct FfiConverterTypeMscNameVersion: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MscNameVersion {
        return try MscNameVersion(
            `name`: FfiConverterString.read(from: &buf), 
            `version`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MscNameVersion, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterString.write(value.`version`, into: &buf)
    }
}


public struct MscNetworkInfo {
    public var `networkTitle`: String
    public var `networkLogo`: String
    public var `networkSpecsKey`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`networkTitle`: String, `networkLogo`: String, `networkSpecsKey`: String) {
        self.`networkTitle` = `networkTitle`
        self.`networkLogo` = `networkLogo`
        self.`networkSpecsKey` = `networkSpecsKey`
    }
}


extension MscNetworkInfo: Equatable, Hashable {
    public static func ==(lhs: MscNetworkInfo, rhs: MscNetworkInfo) -> Bool {
        if lhs.`networkTitle` != rhs.`networkTitle` {
            return false
        }
        if lhs.`networkLogo` != rhs.`networkLogo` {
            return false
        }
        if lhs.`networkSpecsKey` != rhs.`networkSpecsKey` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`networkTitle`)
        hasher.combine(`networkLogo`)
        hasher.combine(`networkSpecsKey`)
    }
}


public struct FfiConverterTypeMscNetworkInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MscNetworkInfo {
        return try MscNetworkInfo(
            `networkTitle`: FfiConverterString.read(from: &buf), 
            `networkLogo`: FfiConverterString.read(from: &buf), 
            `networkSpecsKey`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MscNetworkInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`networkTitle`, into: &buf)
        FfiConverterString.write(value.`networkLogo`, into: &buf)
        FfiConverterString.write(value.`networkSpecsKey`, into: &buf)
    }
}


public struct MscTip {
    public var `amount`: String
    public var `units`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`amount`: String, `units`: String) {
        self.`amount` = `amount`
        self.`units` = `units`
    }
}


extension MscTip: Equatable, Hashable {
    public static func ==(lhs: MscTip, rhs: MscTip) -> Bool {
        if lhs.`amount` != rhs.`amount` {
            return false
        }
        if lhs.`units` != rhs.`units` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`amount`)
        hasher.combine(`units`)
    }
}


public struct FfiConverterTypeMscTip: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MscTip {
        return try MscTip(
            `amount`: FfiConverterString.read(from: &buf), 
            `units`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MscTip, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`amount`, into: &buf)
        FfiConverterString.write(value.`units`, into: &buf)
    }
}


public struct MscTxSpecPlain {
    public var `networkGenesisHash`: H256
    public var `version`: String
    public var `txVersion`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`networkGenesisHash`: H256, `version`: String, `txVersion`: String) {
        self.`networkGenesisHash` = `networkGenesisHash`
        self.`version` = `version`
        self.`txVersion` = `txVersion`
    }
}


extension MscTxSpecPlain: Equatable, Hashable {
    public static func ==(lhs: MscTxSpecPlain, rhs: MscTxSpecPlain) -> Bool {
        if lhs.`networkGenesisHash` != rhs.`networkGenesisHash` {
            return false
        }
        if lhs.`version` != rhs.`version` {
            return false
        }
        if lhs.`txVersion` != rhs.`txVersion` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`networkGenesisHash`)
        hasher.combine(`version`)
        hasher.combine(`txVersion`)
    }
}


public struct FfiConverterTypeMscTxSpecPlain: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MscTxSpecPlain {
        return try MscTxSpecPlain(
            `networkGenesisHash`: FfiConverterTypeH256.read(from: &buf), 
            `version`: FfiConverterString.read(from: &buf), 
            `txVersion`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MscTxSpecPlain, into buf: inout [UInt8]) {
        FfiConverterTypeH256.write(value.`networkGenesisHash`, into: &buf)
        FfiConverterString.write(value.`version`, into: &buf)
        FfiConverterString.write(value.`txVersion`, into: &buf)
    }
}


public struct MSeedMenu {
    public var `seed`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`seed`: String) {
        self.`seed` = `seed`
    }
}


extension MSeedMenu: Equatable, Hashable {
    public static func ==(lhs: MSeedMenu, rhs: MSeedMenu) -> Bool {
        if lhs.`seed` != rhs.`seed` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`seed`)
    }
}


public struct FfiConverterTypeMSeedMenu: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MSeedMenu {
        return try MSeedMenu(
            `seed`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MSeedMenu, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`seed`, into: &buf)
    }
}


public struct MSeeds {
    public var `seedNameCards`: [SeedNameCard]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`seedNameCards`: [SeedNameCard]) {
        self.`seedNameCards` = `seedNameCards`
    }
}


extension MSeeds: Equatable, Hashable {
    public static func ==(lhs: MSeeds, rhs: MSeeds) -> Bool {
        if lhs.`seedNameCards` != rhs.`seedNameCards` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`seedNameCards`)
    }
}


public struct FfiConverterTypeMSeeds: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MSeeds {
        return try MSeeds(
            `seedNameCards`: FfiConverterSequenceTypeSeedNameCard.read(from: &buf)
        )
    }

    public static func write(_ value: MSeeds, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeSeedNameCard.write(value.`seedNameCards`, into: &buf)
    }
}


public struct MSettings {
    public var `publicKey`: String?
    public var `identicon`: SignerImage?
    public var `encryption`: String?
    public var `error`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`publicKey`: String?, `identicon`: SignerImage?, `encryption`: String?, `error`: String?) {
        self.`publicKey` = `publicKey`
        self.`identicon` = `identicon`
        self.`encryption` = `encryption`
        self.`error` = `error`
    }
}


extension MSettings: Equatable, Hashable {
    public static func ==(lhs: MSettings, rhs: MSettings) -> Bool {
        if lhs.`publicKey` != rhs.`publicKey` {
            return false
        }
        if lhs.`identicon` != rhs.`identicon` {
            return false
        }
        if lhs.`encryption` != rhs.`encryption` {
            return false
        }
        if lhs.`error` != rhs.`error` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`publicKey`)
        hasher.combine(`identicon`)
        hasher.combine(`encryption`)
        hasher.combine(`error`)
    }
}


public struct FfiConverterTypeMSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MSettings {
        return try MSettings(
            `publicKey`: FfiConverterOptionString.read(from: &buf), 
            `identicon`: FfiConverterOptionTypeSignerImage.read(from: &buf), 
            `encryption`: FfiConverterOptionString.read(from: &buf), 
            `error`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: MSettings, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.`publicKey`, into: &buf)
        FfiConverterOptionTypeSignerImage.write(value.`identicon`, into: &buf)
        FfiConverterOptionString.write(value.`encryption`, into: &buf)
        FfiConverterOptionString.write(value.`error`, into: &buf)
    }
}


public struct MSignSufficientCrypto {
    public var `identities`: [MRawKey]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`identities`: [MRawKey]) {
        self.`identities` = `identities`
    }
}


extension MSignSufficientCrypto: Equatable, Hashable {
    public static func ==(lhs: MSignSufficientCrypto, rhs: MSignSufficientCrypto) -> Bool {
        if lhs.`identities` != rhs.`identities` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`identities`)
    }
}


public struct FfiConverterTypeMSignSufficientCrypto: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MSignSufficientCrypto {
        return try MSignSufficientCrypto(
            `identities`: FfiConverterSequenceTypeMRawKey.read(from: &buf)
        )
    }

    public static func write(_ value: MSignSufficientCrypto, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeMRawKey.write(value.`identities`, into: &buf)
    }
}


public struct MSignatureReady {
    public var `signatures`: [QrData]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`signatures`: [QrData]) {
        self.`signatures` = `signatures`
    }
}


extension MSignatureReady: Equatable, Hashable {
    public static func ==(lhs: MSignatureReady, rhs: MSignatureReady) -> Bool {
        if lhs.`signatures` != rhs.`signatures` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`signatures`)
    }
}


public struct FfiConverterTypeMSignatureReady: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MSignatureReady {
        return try MSignatureReady(
            `signatures`: FfiConverterSequenceTypeQrData.read(from: &buf)
        )
    }

    public static func write(_ value: MSignatureReady, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeQrData.write(value.`signatures`, into: &buf)
    }
}


public struct MSufficientCryptoReady {
    public var `authorInfo`: MAddressCard
    public var `sufficient`: [UInt8]
    public var `content`: MscContent
    public var `networkLogo`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`authorInfo`: MAddressCard, `sufficient`: [UInt8], `content`: MscContent, `networkLogo`: String?) {
        self.`authorInfo` = `authorInfo`
        self.`sufficient` = `sufficient`
        self.`content` = `content`
        self.`networkLogo` = `networkLogo`
    }
}


extension MSufficientCryptoReady: Equatable, Hashable {
    public static func ==(lhs: MSufficientCryptoReady, rhs: MSufficientCryptoReady) -> Bool {
        if lhs.`authorInfo` != rhs.`authorInfo` {
            return false
        }
        if lhs.`sufficient` != rhs.`sufficient` {
            return false
        }
        if lhs.`content` != rhs.`content` {
            return false
        }
        if lhs.`networkLogo` != rhs.`networkLogo` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`authorInfo`)
        hasher.combine(`sufficient`)
        hasher.combine(`content`)
        hasher.combine(`networkLogo`)
    }
}


public struct FfiConverterTypeMSufficientCryptoReady: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MSufficientCryptoReady {
        return try MSufficientCryptoReady(
            `authorInfo`: FfiConverterTypeMAddressCard.read(from: &buf), 
            `sufficient`: FfiConverterSequenceUInt8.read(from: &buf), 
            `content`: FfiConverterTypeMscContent.read(from: &buf), 
            `networkLogo`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: MSufficientCryptoReady, into buf: inout [UInt8]) {
        FfiConverterTypeMAddressCard.write(value.`authorInfo`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`sufficient`, into: &buf)
        FfiConverterTypeMscContent.write(value.`content`, into: &buf)
        FfiConverterOptionString.write(value.`networkLogo`, into: &buf)
    }
}


public struct MTransaction {
    public var `content`: TransactionCardSet
    public var `ttype`: TransactionType
    public var `authorInfo`: MAddressCard?
    public var `networkInfo`: MscNetworkInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`content`: TransactionCardSet, `ttype`: TransactionType, `authorInfo`: MAddressCard?, `networkInfo`: MscNetworkInfo?) {
        self.`content` = `content`
        self.`ttype` = `ttype`
        self.`authorInfo` = `authorInfo`
        self.`networkInfo` = `networkInfo`
    }
}


extension MTransaction: Equatable, Hashable {
    public static func ==(lhs: MTransaction, rhs: MTransaction) -> Bool {
        if lhs.`content` != rhs.`content` {
            return false
        }
        if lhs.`ttype` != rhs.`ttype` {
            return false
        }
        if lhs.`authorInfo` != rhs.`authorInfo` {
            return false
        }
        if lhs.`networkInfo` != rhs.`networkInfo` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`content`)
        hasher.combine(`ttype`)
        hasher.combine(`authorInfo`)
        hasher.combine(`networkInfo`)
    }
}


public struct FfiConverterTypeMTransaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MTransaction {
        return try MTransaction(
            `content`: FfiConverterTypeTransactionCardSet.read(from: &buf), 
            `ttype`: FfiConverterTypeTransactionType.read(from: &buf), 
            `authorInfo`: FfiConverterOptionTypeMAddressCard.read(from: &buf), 
            `networkInfo`: FfiConverterOptionTypeMscNetworkInfo.read(from: &buf)
        )
    }

    public static func write(_ value: MTransaction, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionCardSet.write(value.`content`, into: &buf)
        FfiConverterTypeTransactionType.write(value.`ttype`, into: &buf)
        FfiConverterOptionTypeMAddressCard.write(value.`authorInfo`, into: &buf)
        FfiConverterOptionTypeMscNetworkInfo.write(value.`networkInfo`, into: &buf)
    }
}


public struct MTypesInfo {
    public var `typesOnFile`: Bool
    public var `typesHash`: String?
    public var `typesIdPic`: SignerImage?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`typesOnFile`: Bool, `typesHash`: String?, `typesIdPic`: SignerImage?) {
        self.`typesOnFile` = `typesOnFile`
        self.`typesHash` = `typesHash`
        self.`typesIdPic` = `typesIdPic`
    }
}


extension MTypesInfo: Equatable, Hashable {
    public static func ==(lhs: MTypesInfo, rhs: MTypesInfo) -> Bool {
        if lhs.`typesOnFile` != rhs.`typesOnFile` {
            return false
        }
        if lhs.`typesHash` != rhs.`typesHash` {
            return false
        }
        if lhs.`typesIdPic` != rhs.`typesIdPic` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`typesOnFile`)
        hasher.combine(`typesHash`)
        hasher.combine(`typesIdPic`)
    }
}


public struct FfiConverterTypeMTypesInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MTypesInfo {
        return try MTypesInfo(
            `typesOnFile`: FfiConverterBool.read(from: &buf), 
            `typesHash`: FfiConverterOptionString.read(from: &buf), 
            `typesIdPic`: FfiConverterOptionTypeSignerImage.read(from: &buf)
        )
    }

    public static func write(_ value: MTypesInfo, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`typesOnFile`, into: &buf)
        FfiConverterOptionString.write(value.`typesHash`, into: &buf)
        FfiConverterOptionTypeSignerImage.write(value.`typesIdPic`, into: &buf)
    }
}


public struct MVerifier {
    public var `ttype`: String
    public var `details`: MVerifierDetails

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`ttype`: String, `details`: MVerifierDetails) {
        self.`ttype` = `ttype`
        self.`details` = `details`
    }
}


extension MVerifier: Equatable, Hashable {
    public static func ==(lhs: MVerifier, rhs: MVerifier) -> Bool {
        if lhs.`ttype` != rhs.`ttype` {
            return false
        }
        if lhs.`details` != rhs.`details` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`ttype`)
        hasher.combine(`details`)
    }
}


public struct FfiConverterTypeMVerifier: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MVerifier {
        return try MVerifier(
            `ttype`: FfiConverterString.read(from: &buf), 
            `details`: FfiConverterTypeMVerifierDetails.read(from: &buf)
        )
    }

    public static func write(_ value: MVerifier, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`ttype`, into: &buf)
        FfiConverterTypeMVerifierDetails.write(value.`details`, into: &buf)
    }
}


public struct MVerifierDetails {
    public var `publicKey`: String
    public var `identicon`: SignerImage
    public var `encryption`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`publicKey`: String, `identicon`: SignerImage, `encryption`: String) {
        self.`publicKey` = `publicKey`
        self.`identicon` = `identicon`
        self.`encryption` = `encryption`
    }
}


extension MVerifierDetails: Equatable, Hashable {
    public static func ==(lhs: MVerifierDetails, rhs: MVerifierDetails) -> Bool {
        if lhs.`publicKey` != rhs.`publicKey` {
            return false
        }
        if lhs.`identicon` != rhs.`identicon` {
            return false
        }
        if lhs.`encryption` != rhs.`encryption` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`publicKey`)
        hasher.combine(`identicon`)
        hasher.combine(`encryption`)
    }
}


public struct FfiConverterTypeMVerifierDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MVerifierDetails {
        return try MVerifierDetails(
            `publicKey`: FfiConverterString.read(from: &buf), 
            `identicon`: FfiConverterTypeSignerImage.read(from: &buf), 
            `encryption`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MVerifierDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`publicKey`, into: &buf)
        FfiConverterTypeSignerImage.write(value.`identicon`, into: &buf)
        FfiConverterString.write(value.`encryption`, into: &buf)
    }
}


public struct MetaValues {
    public var `name`: String
    public var `version`: UInt32
    public var `optionalBase58prefix`: UInt16?
    public var `warnIncompleteExtensions`: Bool
    public var `meta`: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: String, `version`: UInt32, `optionalBase58prefix`: UInt16?, `warnIncompleteExtensions`: Bool, `meta`: [UInt8]) {
        self.`name` = `name`
        self.`version` = `version`
        self.`optionalBase58prefix` = `optionalBase58prefix`
        self.`warnIncompleteExtensions` = `warnIncompleteExtensions`
        self.`meta` = `meta`
    }
}


extension MetaValues: Equatable, Hashable {
    public static func ==(lhs: MetaValues, rhs: MetaValues) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`version` != rhs.`version` {
            return false
        }
        if lhs.`optionalBase58prefix` != rhs.`optionalBase58prefix` {
            return false
        }
        if lhs.`warnIncompleteExtensions` != rhs.`warnIncompleteExtensions` {
            return false
        }
        if lhs.`meta` != rhs.`meta` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
        hasher.combine(`version`)
        hasher.combine(`optionalBase58prefix`)
        hasher.combine(`warnIncompleteExtensions`)
        hasher.combine(`meta`)
    }
}


public struct FfiConverterTypeMetaValues: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetaValues {
        return try MetaValues(
            `name`: FfiConverterString.read(from: &buf), 
            `version`: FfiConverterUInt32.read(from: &buf), 
            `optionalBase58prefix`: FfiConverterOptionUInt16.read(from: &buf), 
            `warnIncompleteExtensions`: FfiConverterBool.read(from: &buf), 
            `meta`: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: MetaValues, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterUInt32.write(value.`version`, into: &buf)
        FfiConverterOptionUInt16.write(value.`optionalBase58prefix`, into: &buf)
        FfiConverterBool.write(value.`warnIncompleteExtensions`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`meta`, into: &buf)
    }
}


public struct MetaValuesDisplay {
    public var `name`: String
    public var `version`: UInt32
    public var `metaHash`: H256

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: String, `version`: UInt32, `metaHash`: H256) {
        self.`name` = `name`
        self.`version` = `version`
        self.`metaHash` = `metaHash`
    }
}


extension MetaValuesDisplay: Equatable, Hashable {
    public static func ==(lhs: MetaValuesDisplay, rhs: MetaValuesDisplay) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`version` != rhs.`version` {
            return false
        }
        if lhs.`metaHash` != rhs.`metaHash` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
        hasher.combine(`version`)
        hasher.combine(`metaHash`)
    }
}


public struct FfiConverterTypeMetaValuesDisplay: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetaValuesDisplay {
        return try MetaValuesDisplay(
            `name`: FfiConverterString.read(from: &buf), 
            `version`: FfiConverterUInt32.read(from: &buf), 
            `metaHash`: FfiConverterTypeH256.read(from: &buf)
        )
    }

    public static func write(_ value: MetaValuesDisplay, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterUInt32.write(value.`version`, into: &buf)
        FfiConverterTypeH256.write(value.`metaHash`, into: &buf)
    }
}


public struct MetaValuesExport {
    public var `name`: String
    public var `version`: UInt32
    public var `metaHash`: H256
    public var `signedBy`: VerifierValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: String, `version`: UInt32, `metaHash`: H256, `signedBy`: VerifierValue) {
        self.`name` = `name`
        self.`version` = `version`
        self.`metaHash` = `metaHash`
        self.`signedBy` = `signedBy`
    }
}


extension MetaValuesExport: Equatable, Hashable {
    public static func ==(lhs: MetaValuesExport, rhs: MetaValuesExport) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`version` != rhs.`version` {
            return false
        }
        if lhs.`metaHash` != rhs.`metaHash` {
            return false
        }
        if lhs.`signedBy` != rhs.`signedBy` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
        hasher.combine(`version`)
        hasher.combine(`metaHash`)
        hasher.combine(`signedBy`)
    }
}


public struct FfiConverterTypeMetaValuesExport: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetaValuesExport {
        return try MetaValuesExport(
            `name`: FfiConverterString.read(from: &buf), 
            `version`: FfiConverterUInt32.read(from: &buf), 
            `metaHash`: FfiConverterTypeH256.read(from: &buf), 
            `signedBy`: FfiConverterTypeVerifierValue.read(from: &buf)
        )
    }

    public static func write(_ value: MetaValuesExport, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterUInt32.write(value.`version`, into: &buf)
        FfiConverterTypeH256.write(value.`metaHash`, into: &buf)
        FfiConverterTypeVerifierValue.write(value.`signedBy`, into: &buf)
    }
}


public struct Network {
    public var `key`: String
    public var `logo`: String
    public var `order`: UInt32
    public var `selected`: Bool
    public var `title`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`key`: String, `logo`: String, `order`: UInt32, `selected`: Bool, `title`: String) {
        self.`key` = `key`
        self.`logo` = `logo`
        self.`order` = `order`
        self.`selected` = `selected`
        self.`title` = `title`
    }
}


extension Network: Equatable, Hashable {
    public static func ==(lhs: Network, rhs: Network) -> Bool {
        if lhs.`key` != rhs.`key` {
            return false
        }
        if lhs.`logo` != rhs.`logo` {
            return false
        }
        if lhs.`order` != rhs.`order` {
            return false
        }
        if lhs.`selected` != rhs.`selected` {
            return false
        }
        if lhs.`title` != rhs.`title` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`key`)
        hasher.combine(`logo`)
        hasher.combine(`order`)
        hasher.combine(`selected`)
        hasher.combine(`title`)
    }
}


public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        return try Network(
            `key`: FfiConverterString.read(from: &buf), 
            `logo`: FfiConverterString.read(from: &buf), 
            `order`: FfiConverterUInt32.read(from: &buf), 
            `selected`: FfiConverterBool.read(from: &buf), 
            `title`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`key`, into: &buf)
        FfiConverterString.write(value.`logo`, into: &buf)
        FfiConverterUInt32.write(value.`order`, into: &buf)
        FfiConverterBool.write(value.`selected`, into: &buf)
        FfiConverterString.write(value.`title`, into: &buf)
    }
}


public struct NetworkSpecs {
    public var `base58prefix`: UInt16
    public var `color`: String
    public var `decimals`: UInt8
    public var `encryption`: Encryption
    public var `genesisHash`: H256
    public var `logo`: String
    public var `name`: String
    public var `pathId`: String
    public var `secondaryColor`: String
    public var `title`: String
    public var `unit`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`base58prefix`: UInt16, `color`: String, `decimals`: UInt8, `encryption`: Encryption, `genesisHash`: H256, `logo`: String, `name`: String, `pathId`: String, `secondaryColor`: String, `title`: String, `unit`: String) {
        self.`base58prefix` = `base58prefix`
        self.`color` = `color`
        self.`decimals` = `decimals`
        self.`encryption` = `encryption`
        self.`genesisHash` = `genesisHash`
        self.`logo` = `logo`
        self.`name` = `name`
        self.`pathId` = `pathId`
        self.`secondaryColor` = `secondaryColor`
        self.`title` = `title`
        self.`unit` = `unit`
    }
}


extension NetworkSpecs: Equatable, Hashable {
    public static func ==(lhs: NetworkSpecs, rhs: NetworkSpecs) -> Bool {
        if lhs.`base58prefix` != rhs.`base58prefix` {
            return false
        }
        if lhs.`color` != rhs.`color` {
            return false
        }
        if lhs.`decimals` != rhs.`decimals` {
            return false
        }
        if lhs.`encryption` != rhs.`encryption` {
            return false
        }
        if lhs.`genesisHash` != rhs.`genesisHash` {
            return false
        }
        if lhs.`logo` != rhs.`logo` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`pathId` != rhs.`pathId` {
            return false
        }
        if lhs.`secondaryColor` != rhs.`secondaryColor` {
            return false
        }
        if lhs.`title` != rhs.`title` {
            return false
        }
        if lhs.`unit` != rhs.`unit` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`base58prefix`)
        hasher.combine(`color`)
        hasher.combine(`decimals`)
        hasher.combine(`encryption`)
        hasher.combine(`genesisHash`)
        hasher.combine(`logo`)
        hasher.combine(`name`)
        hasher.combine(`pathId`)
        hasher.combine(`secondaryColor`)
        hasher.combine(`title`)
        hasher.combine(`unit`)
    }
}


public struct FfiConverterTypeNetworkSpecs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkSpecs {
        return try NetworkSpecs(
            `base58prefix`: FfiConverterUInt16.read(from: &buf), 
            `color`: FfiConverterString.read(from: &buf), 
            `decimals`: FfiConverterUInt8.read(from: &buf), 
            `encryption`: FfiConverterTypeEncryption.read(from: &buf), 
            `genesisHash`: FfiConverterTypeH256.read(from: &buf), 
            `logo`: FfiConverterString.read(from: &buf), 
            `name`: FfiConverterString.read(from: &buf), 
            `pathId`: FfiConverterString.read(from: &buf), 
            `secondaryColor`: FfiConverterString.read(from: &buf), 
            `title`: FfiConverterString.read(from: &buf), 
            `unit`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: NetworkSpecs, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.`base58prefix`, into: &buf)
        FfiConverterString.write(value.`color`, into: &buf)
        FfiConverterUInt8.write(value.`decimals`, into: &buf)
        FfiConverterTypeEncryption.write(value.`encryption`, into: &buf)
        FfiConverterTypeH256.write(value.`genesisHash`, into: &buf)
        FfiConverterString.write(value.`logo`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterString.write(value.`pathId`, into: &buf)
        FfiConverterString.write(value.`secondaryColor`, into: &buf)
        FfiConverterString.write(value.`title`, into: &buf)
        FfiConverterString.write(value.`unit`, into: &buf)
    }
}


public struct NetworkSpecsDisplay {
    public var `network`: OrderedNetworkSpecs
    public var `validCurrentVerifier`: ValidCurrentVerifier
    public var `generalVerifier`: Verifier

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`network`: OrderedNetworkSpecs, `validCurrentVerifier`: ValidCurrentVerifier, `generalVerifier`: Verifier) {
        self.`network` = `network`
        self.`validCurrentVerifier` = `validCurrentVerifier`
        self.`generalVerifier` = `generalVerifier`
    }
}


extension NetworkSpecsDisplay: Equatable, Hashable {
    public static func ==(lhs: NetworkSpecsDisplay, rhs: NetworkSpecsDisplay) -> Bool {
        if lhs.`network` != rhs.`network` {
            return false
        }
        if lhs.`validCurrentVerifier` != rhs.`validCurrentVerifier` {
            return false
        }
        if lhs.`generalVerifier` != rhs.`generalVerifier` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`network`)
        hasher.combine(`validCurrentVerifier`)
        hasher.combine(`generalVerifier`)
    }
}


public struct FfiConverterTypeNetworkSpecsDisplay: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkSpecsDisplay {
        return try NetworkSpecsDisplay(
            `network`: FfiConverterTypeOrderedNetworkSpecs.read(from: &buf), 
            `validCurrentVerifier`: FfiConverterTypeValidCurrentVerifier.read(from: &buf), 
            `generalVerifier`: FfiConverterTypeVerifier.read(from: &buf)
        )
    }

    public static func write(_ value: NetworkSpecsDisplay, into buf: inout [UInt8]) {
        FfiConverterTypeOrderedNetworkSpecs.write(value.`network`, into: &buf)
        FfiConverterTypeValidCurrentVerifier.write(value.`validCurrentVerifier`, into: &buf)
        FfiConverterTypeVerifier.write(value.`generalVerifier`, into: &buf)
    }
}


public struct NetworkSpecsExport {
    public var `specsToSend`: NetworkSpecs
    public var `signedBy`: VerifierValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`specsToSend`: NetworkSpecs, `signedBy`: VerifierValue) {
        self.`specsToSend` = `specsToSend`
        self.`signedBy` = `signedBy`
    }
}


extension NetworkSpecsExport: Equatable, Hashable {
    public static func ==(lhs: NetworkSpecsExport, rhs: NetworkSpecsExport) -> Bool {
        if lhs.`specsToSend` != rhs.`specsToSend` {
            return false
        }
        if lhs.`signedBy` != rhs.`signedBy` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`specsToSend`)
        hasher.combine(`signedBy`)
    }
}


public struct FfiConverterTypeNetworkSpecsExport: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkSpecsExport {
        return try NetworkSpecsExport(
            `specsToSend`: FfiConverterTypeNetworkSpecs.read(from: &buf), 
            `signedBy`: FfiConverterTypeVerifierValue.read(from: &buf)
        )
    }

    public static func write(_ value: NetworkSpecsExport, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkSpecs.write(value.`specsToSend`, into: &buf)
        FfiConverterTypeVerifierValue.write(value.`signedBy`, into: &buf)
    }
}


public struct NetworkVerifierDisplay {
    public var `genesisHash`: H256
    public var `validCurrentVerifier`: ValidCurrentVerifier
    public var `generalVerifier`: Verifier

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`genesisHash`: H256, `validCurrentVerifier`: ValidCurrentVerifier, `generalVerifier`: Verifier) {
        self.`genesisHash` = `genesisHash`
        self.`validCurrentVerifier` = `validCurrentVerifier`
        self.`generalVerifier` = `generalVerifier`
    }
}


extension NetworkVerifierDisplay: Equatable, Hashable {
    public static func ==(lhs: NetworkVerifierDisplay, rhs: NetworkVerifierDisplay) -> Bool {
        if lhs.`genesisHash` != rhs.`genesisHash` {
            return false
        }
        if lhs.`validCurrentVerifier` != rhs.`validCurrentVerifier` {
            return false
        }
        if lhs.`generalVerifier` != rhs.`generalVerifier` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`genesisHash`)
        hasher.combine(`validCurrentVerifier`)
        hasher.combine(`generalVerifier`)
    }
}


public struct FfiConverterTypeNetworkVerifierDisplay: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkVerifierDisplay {
        return try NetworkVerifierDisplay(
            `genesisHash`: FfiConverterTypeH256.read(from: &buf), 
            `validCurrentVerifier`: FfiConverterTypeValidCurrentVerifier.read(from: &buf), 
            `generalVerifier`: FfiConverterTypeVerifier.read(from: &buf)
        )
    }

    public static func write(_ value: NetworkVerifierDisplay, into buf: inout [UInt8]) {
        FfiConverterTypeH256.write(value.`genesisHash`, into: &buf)
        FfiConverterTypeValidCurrentVerifier.write(value.`validCurrentVerifier`, into: &buf)
        FfiConverterTypeVerifier.write(value.`generalVerifier`, into: &buf)
    }
}


public struct OrderedNetworkSpecs {
    public var `specs`: NetworkSpecs
    public var `order`: UInt8

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`specs`: NetworkSpecs, `order`: UInt8) {
        self.`specs` = `specs`
        self.`order` = `order`
    }
}


extension OrderedNetworkSpecs: Equatable, Hashable {
    public static func ==(lhs: OrderedNetworkSpecs, rhs: OrderedNetworkSpecs) -> Bool {
        if lhs.`specs` != rhs.`specs` {
            return false
        }
        if lhs.`order` != rhs.`order` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`specs`)
        hasher.combine(`order`)
    }
}


public struct FfiConverterTypeOrderedNetworkSpecs: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OrderedNetworkSpecs {
        return try OrderedNetworkSpecs(
            `specs`: FfiConverterTypeNetworkSpecs.read(from: &buf), 
            `order`: FfiConverterUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: OrderedNetworkSpecs, into buf: inout [UInt8]) {
        FfiConverterTypeNetworkSpecs.write(value.`specs`, into: &buf)
        FfiConverterUInt8.write(value.`order`, into: &buf)
    }
}


public struct PathAndNetwork {
    public var `derivation`: String
    public var `networkSpecsKey`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`derivation`: String, `networkSpecsKey`: String) {
        self.`derivation` = `derivation`
        self.`networkSpecsKey` = `networkSpecsKey`
    }
}


extension PathAndNetwork: Equatable, Hashable {
    public static func ==(lhs: PathAndNetwork, rhs: PathAndNetwork) -> Bool {
        if lhs.`derivation` != rhs.`derivation` {
            return false
        }
        if lhs.`networkSpecsKey` != rhs.`networkSpecsKey` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`derivation`)
        hasher.combine(`networkSpecsKey`)
    }
}


public struct FfiConverterTypePathAndNetwork: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PathAndNetwork {
        return try PathAndNetwork(
            `derivation`: FfiConverterString.read(from: &buf), 
            `networkSpecsKey`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PathAndNetwork, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`derivation`, into: &buf)
        FfiConverterString.write(value.`networkSpecsKey`, into: &buf)
    }
}


public struct SeedKeysPreview {
    public var `name`: String
    public var `multisigner`: MultiSigner
    public var `derivedKeys`: [DerivedKeyPreview]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: String, `multisigner`: MultiSigner, `derivedKeys`: [DerivedKeyPreview]) {
        self.`name` = `name`
        self.`multisigner` = `multisigner`
        self.`derivedKeys` = `derivedKeys`
    }
}


extension SeedKeysPreview: Equatable, Hashable {
    public static func ==(lhs: SeedKeysPreview, rhs: SeedKeysPreview) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`multisigner` != rhs.`multisigner` {
            return false
        }
        if lhs.`derivedKeys` != rhs.`derivedKeys` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
        hasher.combine(`multisigner`)
        hasher.combine(`derivedKeys`)
    }
}


public struct FfiConverterTypeSeedKeysPreview: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SeedKeysPreview {
        return try SeedKeysPreview(
            `name`: FfiConverterString.read(from: &buf), 
            `multisigner`: FfiConverterTypeMultiSigner.read(from: &buf), 
            `derivedKeys`: FfiConverterSequenceTypeDerivedKeyPreview.read(from: &buf)
        )
    }

    public static func write(_ value: SeedKeysPreview, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterTypeMultiSigner.write(value.`multisigner`, into: &buf)
        FfiConverterSequenceTypeDerivedKeyPreview.write(value.`derivedKeys`, into: &buf)
    }
}


public struct SeedNameCard {
    public var `seedName`: String
    public var `identicon`: SignerImage
    public var `usedInNetworks`: [String]
    public var `derivedKeysCount`: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`seedName`: String, `identicon`: SignerImage, `usedInNetworks`: [String], `derivedKeysCount`: UInt32) {
        self.`seedName` = `seedName`
        self.`identicon` = `identicon`
        self.`usedInNetworks` = `usedInNetworks`
        self.`derivedKeysCount` = `derivedKeysCount`
    }
}


extension SeedNameCard: Equatable, Hashable {
    public static func ==(lhs: SeedNameCard, rhs: SeedNameCard) -> Bool {
        if lhs.`seedName` != rhs.`seedName` {
            return false
        }
        if lhs.`identicon` != rhs.`identicon` {
            return false
        }
        if lhs.`usedInNetworks` != rhs.`usedInNetworks` {
            return false
        }
        if lhs.`derivedKeysCount` != rhs.`derivedKeysCount` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`seedName`)
        hasher.combine(`identicon`)
        hasher.combine(`usedInNetworks`)
        hasher.combine(`derivedKeysCount`)
    }
}


public struct FfiConverterTypeSeedNameCard: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SeedNameCard {
        return try SeedNameCard(
            `seedName`: FfiConverterString.read(from: &buf), 
            `identicon`: FfiConverterTypeSignerImage.read(from: &buf), 
            `usedInNetworks`: FfiConverterSequenceString.read(from: &buf), 
            `derivedKeysCount`: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: SeedNameCard, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`seedName`, into: &buf)
        FfiConverterTypeSignerImage.write(value.`identicon`, into: &buf)
        FfiConverterSequenceString.write(value.`usedInNetworks`, into: &buf)
        FfiConverterUInt32.write(value.`derivedKeysCount`, into: &buf)
    }
}


public struct SignDisplay {
    public var `transaction`: [UInt8]
    public var `networkName`: String
    public var `signedBy`: VerifierValue
    public var `userComment`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`transaction`: [UInt8], `networkName`: String, `signedBy`: VerifierValue, `userComment`: String) {
        self.`transaction` = `transaction`
        self.`networkName` = `networkName`
        self.`signedBy` = `signedBy`
        self.`userComment` = `userComment`
    }
}


extension SignDisplay: Equatable, Hashable {
    public static func ==(lhs: SignDisplay, rhs: SignDisplay) -> Bool {
        if lhs.`transaction` != rhs.`transaction` {
            return false
        }
        if lhs.`networkName` != rhs.`networkName` {
            return false
        }
        if lhs.`signedBy` != rhs.`signedBy` {
            return false
        }
        if lhs.`userComment` != rhs.`userComment` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`transaction`)
        hasher.combine(`networkName`)
        hasher.combine(`signedBy`)
        hasher.combine(`userComment`)
    }
}


public struct FfiConverterTypeSignDisplay: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignDisplay {
        return try SignDisplay(
            `transaction`: FfiConverterSequenceUInt8.read(from: &buf), 
            `networkName`: FfiConverterString.read(from: &buf), 
            `signedBy`: FfiConverterTypeVerifierValue.read(from: &buf), 
            `userComment`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SignDisplay, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt8.write(value.`transaction`, into: &buf)
        FfiConverterString.write(value.`networkName`, into: &buf)
        FfiConverterTypeVerifierValue.write(value.`signedBy`, into: &buf)
        FfiConverterString.write(value.`userComment`, into: &buf)
    }
}


public struct SignMessageDisplay {
    public var `message`: String
    public var `networkName`: String
    public var `signedBy`: VerifierValue
    public var `userComment`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`message`: String, `networkName`: String, `signedBy`: VerifierValue, `userComment`: String) {
        self.`message` = `message`
        self.`networkName` = `networkName`
        self.`signedBy` = `signedBy`
        self.`userComment` = `userComment`
    }
}


extension SignMessageDisplay: Equatable, Hashable {
    public static func ==(lhs: SignMessageDisplay, rhs: SignMessageDisplay) -> Bool {
        if lhs.`message` != rhs.`message` {
            return false
        }
        if lhs.`networkName` != rhs.`networkName` {
            return false
        }
        if lhs.`signedBy` != rhs.`signedBy` {
            return false
        }
        if lhs.`userComment` != rhs.`userComment` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`message`)
        hasher.combine(`networkName`)
        hasher.combine(`signedBy`)
        hasher.combine(`userComment`)
    }
}


public struct FfiConverterTypeSignMessageDisplay: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignMessageDisplay {
        return try SignMessageDisplay(
            `message`: FfiConverterString.read(from: &buf), 
            `networkName`: FfiConverterString.read(from: &buf), 
            `signedBy`: FfiConverterTypeVerifierValue.read(from: &buf), 
            `userComment`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SignMessageDisplay, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`message`, into: &buf)
        FfiConverterString.write(value.`networkName`, into: &buf)
        FfiConverterTypeVerifierValue.write(value.`signedBy`, into: &buf)
        FfiConverterString.write(value.`userComment`, into: &buf)
    }
}


public struct TransactionCard {
    public var `index`: UInt32
    public var `indent`: UInt32
    public var `card`: Card

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`index`: UInt32, `indent`: UInt32, `card`: Card) {
        self.`index` = `index`
        self.`indent` = `indent`
        self.`card` = `card`
    }
}


extension TransactionCard: Equatable, Hashable {
    public static func ==(lhs: TransactionCard, rhs: TransactionCard) -> Bool {
        if lhs.`index` != rhs.`index` {
            return false
        }
        if lhs.`indent` != rhs.`indent` {
            return false
        }
        if lhs.`card` != rhs.`card` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`index`)
        hasher.combine(`indent`)
        hasher.combine(`card`)
    }
}


public struct FfiConverterTypeTransactionCard: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionCard {
        return try TransactionCard(
            `index`: FfiConverterUInt32.read(from: &buf), 
            `indent`: FfiConverterUInt32.read(from: &buf), 
            `card`: FfiConverterTypeCard.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionCard, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.`index`, into: &buf)
        FfiConverterUInt32.write(value.`indent`, into: &buf)
        FfiConverterTypeCard.write(value.`card`, into: &buf)
    }
}


public struct TransactionCardSet {
    public var `author`: [TransactionCard]?
    public var `error`: [TransactionCard]?
    public var `extensions`: [TransactionCard]?
    public var `importingDerivations`: [TransactionCard]?
    public var `message`: [TransactionCard]?
    public var `meta`: [TransactionCard]?
    public var `method`: [TransactionCard]?
    public var `newSpecs`: [TransactionCard]?
    public var `verifier`: [TransactionCard]?
    public var `warning`: [TransactionCard]?
    public var `typesInfo`: [TransactionCard]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`author`: [TransactionCard]?, `error`: [TransactionCard]?, `extensions`: [TransactionCard]?, `importingDerivations`: [TransactionCard]?, `message`: [TransactionCard]?, `meta`: [TransactionCard]?, `method`: [TransactionCard]?, `newSpecs`: [TransactionCard]?, `verifier`: [TransactionCard]?, `warning`: [TransactionCard]?, `typesInfo`: [TransactionCard]?) {
        self.`author` = `author`
        self.`error` = `error`
        self.`extensions` = `extensions`
        self.`importingDerivations` = `importingDerivations`
        self.`message` = `message`
        self.`meta` = `meta`
        self.`method` = `method`
        self.`newSpecs` = `newSpecs`
        self.`verifier` = `verifier`
        self.`warning` = `warning`
        self.`typesInfo` = `typesInfo`
    }
}


extension TransactionCardSet: Equatable, Hashable {
    public static func ==(lhs: TransactionCardSet, rhs: TransactionCardSet) -> Bool {
        if lhs.`author` != rhs.`author` {
            return false
        }
        if lhs.`error` != rhs.`error` {
            return false
        }
        if lhs.`extensions` != rhs.`extensions` {
            return false
        }
        if lhs.`importingDerivations` != rhs.`importingDerivations` {
            return false
        }
        if lhs.`message` != rhs.`message` {
            return false
        }
        if lhs.`meta` != rhs.`meta` {
            return false
        }
        if lhs.`method` != rhs.`method` {
            return false
        }
        if lhs.`newSpecs` != rhs.`newSpecs` {
            return false
        }
        if lhs.`verifier` != rhs.`verifier` {
            return false
        }
        if lhs.`warning` != rhs.`warning` {
            return false
        }
        if lhs.`typesInfo` != rhs.`typesInfo` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`author`)
        hasher.combine(`error`)
        hasher.combine(`extensions`)
        hasher.combine(`importingDerivations`)
        hasher.combine(`message`)
        hasher.combine(`meta`)
        hasher.combine(`method`)
        hasher.combine(`newSpecs`)
        hasher.combine(`verifier`)
        hasher.combine(`warning`)
        hasher.combine(`typesInfo`)
    }
}


public struct FfiConverterTypeTransactionCardSet: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionCardSet {
        return try TransactionCardSet(
            `author`: FfiConverterOptionSequenceTypeTransactionCard.read(from: &buf), 
            `error`: FfiConverterOptionSequenceTypeTransactionCard.read(from: &buf), 
            `extensions`: FfiConverterOptionSequenceTypeTransactionCard.read(from: &buf), 
            `importingDerivations`: FfiConverterOptionSequenceTypeTransactionCard.read(from: &buf), 
            `message`: FfiConverterOptionSequenceTypeTransactionCard.read(from: &buf), 
            `meta`: FfiConverterOptionSequenceTypeTransactionCard.read(from: &buf), 
            `method`: FfiConverterOptionSequenceTypeTransactionCard.read(from: &buf), 
            `newSpecs`: FfiConverterOptionSequenceTypeTransactionCard.read(from: &buf), 
            `verifier`: FfiConverterOptionSequenceTypeTransactionCard.read(from: &buf), 
            `warning`: FfiConverterOptionSequenceTypeTransactionCard.read(from: &buf), 
            `typesInfo`: FfiConverterOptionSequenceTypeTransactionCard.read(from: &buf)
        )
    }

    public static func write(_ value: TransactionCardSet, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceTypeTransactionCard.write(value.`author`, into: &buf)
        FfiConverterOptionSequenceTypeTransactionCard.write(value.`error`, into: &buf)
        FfiConverterOptionSequenceTypeTransactionCard.write(value.`extensions`, into: &buf)
        FfiConverterOptionSequenceTypeTransactionCard.write(value.`importingDerivations`, into: &buf)
        FfiConverterOptionSequenceTypeTransactionCard.write(value.`message`, into: &buf)
        FfiConverterOptionSequenceTypeTransactionCard.write(value.`meta`, into: &buf)
        FfiConverterOptionSequenceTypeTransactionCard.write(value.`method`, into: &buf)
        FfiConverterOptionSequenceTypeTransactionCard.write(value.`newSpecs`, into: &buf)
        FfiConverterOptionSequenceTypeTransactionCard.write(value.`verifier`, into: &buf)
        FfiConverterOptionSequenceTypeTransactionCard.write(value.`warning`, into: &buf)
        FfiConverterOptionSequenceTypeTransactionCard.write(value.`typesInfo`, into: &buf)
    }
}


public struct TypesDisplay {
    public var `typesHash`: H256
    public var `verifier`: Verifier

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`typesHash`: H256, `verifier`: Verifier) {
        self.`typesHash` = `typesHash`
        self.`verifier` = `verifier`
    }
}


extension TypesDisplay: Equatable, Hashable {
    public static func ==(lhs: TypesDisplay, rhs: TypesDisplay) -> Bool {
        if lhs.`typesHash` != rhs.`typesHash` {
            return false
        }
        if lhs.`verifier` != rhs.`verifier` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`typesHash`)
        hasher.combine(`verifier`)
    }
}


public struct FfiConverterTypeTypesDisplay: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypesDisplay {
        return try TypesDisplay(
            `typesHash`: FfiConverterTypeH256.read(from: &buf), 
            `verifier`: FfiConverterTypeVerifier.read(from: &buf)
        )
    }

    public static func write(_ value: TypesDisplay, into buf: inout [UInt8]) {
        FfiConverterTypeH256.write(value.`typesHash`, into: &buf)
        FfiConverterTypeVerifier.write(value.`verifier`, into: &buf)
    }
}


public struct TypesExport {
    public var `typesHash`: H256
    public var `signedBy`: VerifierValue

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`typesHash`: H256, `signedBy`: VerifierValue) {
        self.`typesHash` = `typesHash`
        self.`signedBy` = `signedBy`
    }
}


extension TypesExport: Equatable, Hashable {
    public static func ==(lhs: TypesExport, rhs: TypesExport) -> Bool {
        if lhs.`typesHash` != rhs.`typesHash` {
            return false
        }
        if lhs.`signedBy` != rhs.`signedBy` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`typesHash`)
        hasher.combine(`signedBy`)
    }
}


public struct FfiConverterTypeTypesExport: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TypesExport {
        return try TypesExport(
            `typesHash`: FfiConverterTypeH256.read(from: &buf), 
            `signedBy`: FfiConverterTypeVerifierValue.read(from: &buf)
        )
    }

    public static func write(_ value: TypesExport, into buf: inout [UInt8]) {
        FfiConverterTypeH256.write(value.`typesHash`, into: &buf)
        FfiConverterTypeVerifierValue.write(value.`signedBy`, into: &buf)
    }
}


public struct Verifier {
    public var `v`: VerifierValue?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`v`: VerifierValue?) {
        self.`v` = `v`
    }
}


extension Verifier: Equatable, Hashable {
    public static func ==(lhs: Verifier, rhs: Verifier) -> Bool {
        if lhs.`v` != rhs.`v` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`v`)
    }
}


public struct FfiConverterTypeVerifier: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Verifier {
        return try Verifier(
            `v`: FfiConverterOptionTypeVerifierValue.read(from: &buf)
        )
    }

    public static func write(_ value: Verifier, into buf: inout [UInt8]) {
        FfiConverterOptionTypeVerifierValue.write(value.`v`, into: &buf)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Action {
    
    case `start`
    case `navbarLog`
    case `navbarScan`
    case `navbarKeys`
    case `navbarSettings`
    case `goBack`
    case `goForward`
    case `selectSeed`
    case `selectKey`
    case `newKey`
    case `rightButtonAction`
    case `shield`
    case `newSeed`
    case `recoverSeed`
    case `backupSeed`
    case `networkSelector`
    case `checkPassword`
    case `transactionFetched`
    case `removeNetwork`
    case `removeMetadata`
    case `removeTypes`
    case `signNetworkSpecs`
    case `signMetadata`
    case `signTypes`
    case `manageNetworks`
    case `viewGeneralVerifier`
    case `manageMetadata`
    case `removeKey`
    case `removeSeed`
    case `clearLog`
    case `createLogComment`
    case `showLogDetails`
    case `increment`
    case `showDocuments`
    case `textEntry`
    case `pushWord`
    case `nothing`
}

public struct FfiConverterTypeAction: FfiConverterRustBuffer {
    typealias SwiftType = Action

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Action {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`start`
        
        case 2: return .`navbarLog`
        
        case 3: return .`navbarScan`
        
        case 4: return .`navbarKeys`
        
        case 5: return .`navbarSettings`
        
        case 6: return .`goBack`
        
        case 7: return .`goForward`
        
        case 8: return .`selectSeed`
        
        case 9: return .`selectKey`
        
        case 10: return .`newKey`
        
        case 11: return .`rightButtonAction`
        
        case 12: return .`shield`
        
        case 13: return .`newSeed`
        
        case 14: return .`recoverSeed`
        
        case 15: return .`backupSeed`
        
        case 16: return .`networkSelector`
        
        case 17: return .`checkPassword`
        
        case 18: return .`transactionFetched`
        
        case 19: return .`removeNetwork`
        
        case 20: return .`removeMetadata`
        
        case 21: return .`removeTypes`
        
        case 22: return .`signNetworkSpecs`
        
        case 23: return .`signMetadata`
        
        case 24: return .`signTypes`
        
        case 25: return .`manageNetworks`
        
        case 26: return .`viewGeneralVerifier`
        
        case 27: return .`manageMetadata`
        
        case 28: return .`removeKey`
        
        case 29: return .`removeSeed`
        
        case 30: return .`clearLog`
        
        case 31: return .`createLogComment`
        
        case 32: return .`showLogDetails`
        
        case 33: return .`increment`
        
        case 34: return .`showDocuments`
        
        case 35: return .`textEntry`
        
        case 36: return .`pushWord`
        
        case 37: return .`nothing`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Action, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`start`:
            writeInt(&buf, Int32(1))
        
        
        case .`navbarLog`:
            writeInt(&buf, Int32(2))
        
        
        case .`navbarScan`:
            writeInt(&buf, Int32(3))
        
        
        case .`navbarKeys`:
            writeInt(&buf, Int32(4))
        
        
        case .`navbarSettings`:
            writeInt(&buf, Int32(5))
        
        
        case .`goBack`:
            writeInt(&buf, Int32(6))
        
        
        case .`goForward`:
            writeInt(&buf, Int32(7))
        
        
        case .`selectSeed`:
            writeInt(&buf, Int32(8))
        
        
        case .`selectKey`:
            writeInt(&buf, Int32(9))
        
        
        case .`newKey`:
            writeInt(&buf, Int32(10))
        
        
        case .`rightButtonAction`:
            writeInt(&buf, Int32(11))
        
        
        case .`shield`:
            writeInt(&buf, Int32(12))
        
        
        case .`newSeed`:
            writeInt(&buf, Int32(13))
        
        
        case .`recoverSeed`:
            writeInt(&buf, Int32(14))
        
        
        case .`backupSeed`:
            writeInt(&buf, Int32(15))
        
        
        case .`networkSelector`:
            writeInt(&buf, Int32(16))
        
        
        case .`checkPassword`:
            writeInt(&buf, Int32(17))
        
        
        case .`transactionFetched`:
            writeInt(&buf, Int32(18))
        
        
        case .`removeNetwork`:
            writeInt(&buf, Int32(19))
        
        
        case .`removeMetadata`:
            writeInt(&buf, Int32(20))
        
        
        case .`removeTypes`:
            writeInt(&buf, Int32(21))
        
        
        case .`signNetworkSpecs`:
            writeInt(&buf, Int32(22))
        
        
        case .`signMetadata`:
            writeInt(&buf, Int32(23))
        
        
        case .`signTypes`:
            writeInt(&buf, Int32(24))
        
        
        case .`manageNetworks`:
            writeInt(&buf, Int32(25))
        
        
        case .`viewGeneralVerifier`:
            writeInt(&buf, Int32(26))
        
        
        case .`manageMetadata`:
            writeInt(&buf, Int32(27))
        
        
        case .`removeKey`:
            writeInt(&buf, Int32(28))
        
        
        case .`removeSeed`:
            writeInt(&buf, Int32(29))
        
        
        case .`clearLog`:
            writeInt(&buf, Int32(30))
        
        
        case .`createLogComment`:
            writeInt(&buf, Int32(31))
        
        
        case .`showLogDetails`:
            writeInt(&buf, Int32(32))
        
        
        case .`increment`:
            writeInt(&buf, Int32(33))
        
        
        case .`showDocuments`:
            writeInt(&buf, Int32(34))
        
        
        case .`textEntry`:
            writeInt(&buf, Int32(35))
        
        
        case .`pushWord`:
            writeInt(&buf, Int32(36))
        
        
        case .`nothing`:
            writeInt(&buf, Int32(37))
        
        }
    }
}


extension Action: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AlertData {
    
    case `shield`(`f`: ShieldAlert?)
    case `errorData`(`f`: String)
    case `confirm`
}

public struct FfiConverterTypeAlertData: FfiConverterRustBuffer {
    typealias SwiftType = AlertData

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AlertData {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`shield`(
            `f`: try FfiConverterOptionTypeShieldAlert.read(from: &buf)
        )
        
        case 2: return .`errorData`(
            `f`: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .`confirm`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AlertData, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`shield`(`f`):
            writeInt(&buf, Int32(1))
            FfiConverterOptionTypeShieldAlert.write(`f`, into: &buf)
            
        
        case let .`errorData`(`f`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`f`, into: &buf)
            
        
        case .`confirm`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


extension AlertData: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum BananaSplitRecoveryResult {
    
    case `requestPassword`
    case `recoveredSeed`(`s`: String)
}

public struct FfiConverterTypeBananaSplitRecoveryResult: FfiConverterRustBuffer {
    typealias SwiftType = BananaSplitRecoveryResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BananaSplitRecoveryResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`requestPassword`
        
        case 2: return .`recoveredSeed`(
            `s`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BananaSplitRecoveryResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`requestPassword`:
            writeInt(&buf, Int32(1))
        
        
        case let .`recoveredSeed`(`s`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`s`, into: &buf)
            
        }
    }
}


extension BananaSplitRecoveryResult: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Card {
    
    case `authorCard`(`f`: MAddressCard)
    case `authorPlainCard`(`f`: MscId)
    case `authorPublicKeyCard`(`f`: MVerifierDetails)
    case `balanceCard`(`f`: MscCurrency)
    case `bitVecCard`(`f`: String)
    case `blockHashCard`(`f`: String)
    case `callCard`(`f`: MscCall)
    case `defaultCard`(`f`: String)
    case `derivationsCard`(`f`: [SeedKeysPreview])
    case `enumVariantNameCard`(`f`: MscEnumVariantName)
    case `eraImmortalCard`
    case `eraMortalCard`(`f`: MscEraMortal)
    case `errorCard`(`f`: String)
    case `fieldNameCard`(`f`: MscFieldName)
    case `fieldNumberCard`(`f`: MscFieldNumber)
    case `idCard`(`f`: MscId)
    case `identityFieldCard`(`f`: String)
    case `metaCard`(`f`: MMetadataRecord)
    case `nameVersionCard`(`f`: MscNameVersion)
    case `networkGenesisHashCard`(`f`: String)
    case `networkNameCard`(`f`: String)
    case `networkInfoCard`(`f`: MscNetworkInfo)
    case `newSpecsCard`(`f`: NetworkSpecs)
    case `nonceCard`(`f`: String)
    case `noneCard`
    case `palletCard`(`f`: String)
    case `textCard`(`f`: String)
    case `tipCard`(`f`: MscCurrency)
    case `tipPlainCard`(`f`: String)
    case `txSpecCard`(`f`: String)
    case `txSpecPlainCard`(`f`: MscTxSpecPlain)
    case `typesInfoCard`(`f`: MTypesInfo)
    case `varNameCard`(`f`: String)
    case `verifierCard`(`f`: MVerifierDetails)
    case `warningCard`(`f`: String)
}

public struct FfiConverterTypeCard: FfiConverterRustBuffer {
    typealias SwiftType = Card

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Card {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`authorCard`(
            `f`: try FfiConverterTypeMAddressCard.read(from: &buf)
        )
        
        case 2: return .`authorPlainCard`(
            `f`: try FfiConverterTypeMscId.read(from: &buf)
        )
        
        case 3: return .`authorPublicKeyCard`(
            `f`: try FfiConverterTypeMVerifierDetails.read(from: &buf)
        )
        
        case 4: return .`balanceCard`(
            `f`: try FfiConverterTypeMscCurrency.read(from: &buf)
        )
        
        case 5: return .`bitVecCard`(
            `f`: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .`blockHashCard`(
            `f`: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .`callCard`(
            `f`: try FfiConverterTypeMscCall.read(from: &buf)
        )
        
        case 8: return .`defaultCard`(
            `f`: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .`derivationsCard`(
            `f`: try FfiConverterSequenceTypeSeedKeysPreview.read(from: &buf)
        )
        
        case 10: return .`enumVariantNameCard`(
            `f`: try FfiConverterTypeMscEnumVariantName.read(from: &buf)
        )
        
        case 11: return .`eraImmortalCard`
        
        case 12: return .`eraMortalCard`(
            `f`: try FfiConverterTypeMscEraMortal.read(from: &buf)
        )
        
        case 13: return .`errorCard`(
            `f`: try FfiConverterString.read(from: &buf)
        )
        
        case 14: return .`fieldNameCard`(
            `f`: try FfiConverterTypeMscFieldName.read(from: &buf)
        )
        
        case 15: return .`fieldNumberCard`(
            `f`: try FfiConverterTypeMscFieldNumber.read(from: &buf)
        )
        
        case 16: return .`idCard`(
            `f`: try FfiConverterTypeMscId.read(from: &buf)
        )
        
        case 17: return .`identityFieldCard`(
            `f`: try FfiConverterString.read(from: &buf)
        )
        
        case 18: return .`metaCard`(
            `f`: try FfiConverterTypeMMetadataRecord.read(from: &buf)
        )
        
        case 19: return .`nameVersionCard`(
            `f`: try FfiConverterTypeMscNameVersion.read(from: &buf)
        )
        
        case 20: return .`networkGenesisHashCard`(
            `f`: try FfiConverterString.read(from: &buf)
        )
        
        case 21: return .`networkNameCard`(
            `f`: try FfiConverterString.read(from: &buf)
        )
        
        case 22: return .`networkInfoCard`(
            `f`: try FfiConverterTypeMscNetworkInfo.read(from: &buf)
        )
        
        case 23: return .`newSpecsCard`(
            `f`: try FfiConverterTypeNetworkSpecs.read(from: &buf)
        )
        
        case 24: return .`nonceCard`(
            `f`: try FfiConverterString.read(from: &buf)
        )
        
        case 25: return .`noneCard`
        
        case 26: return .`palletCard`(
            `f`: try FfiConverterString.read(from: &buf)
        )
        
        case 27: return .`textCard`(
            `f`: try FfiConverterString.read(from: &buf)
        )
        
        case 28: return .`tipCard`(
            `f`: try FfiConverterTypeMscCurrency.read(from: &buf)
        )
        
        case 29: return .`tipPlainCard`(
            `f`: try FfiConverterString.read(from: &buf)
        )
        
        case 30: return .`txSpecCard`(
            `f`: try FfiConverterString.read(from: &buf)
        )
        
        case 31: return .`txSpecPlainCard`(
            `f`: try FfiConverterTypeMscTxSpecPlain.read(from: &buf)
        )
        
        case 32: return .`typesInfoCard`(
            `f`: try FfiConverterTypeMTypesInfo.read(from: &buf)
        )
        
        case 33: return .`varNameCard`(
            `f`: try FfiConverterString.read(from: &buf)
        )
        
        case 34: return .`verifierCard`(
            `f`: try FfiConverterTypeMVerifierDetails.read(from: &buf)
        )
        
        case 35: return .`warningCard`(
            `f`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Card, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`authorCard`(`f`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMAddressCard.write(`f`, into: &buf)
            
        
        case let .`authorPlainCard`(`f`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMscId.write(`f`, into: &buf)
            
        
        case let .`authorPublicKeyCard`(`f`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeMVerifierDetails.write(`f`, into: &buf)
            
        
        case let .`balanceCard`(`f`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeMscCurrency.write(`f`, into: &buf)
            
        
        case let .`bitVecCard`(`f`):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(`f`, into: &buf)
            
        
        case let .`blockHashCard`(`f`):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(`f`, into: &buf)
            
        
        case let .`callCard`(`f`):
            writeInt(&buf, Int32(7))
            FfiConverterTypeMscCall.write(`f`, into: &buf)
            
        
        case let .`defaultCard`(`f`):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(`f`, into: &buf)
            
        
        case let .`derivationsCard`(`f`):
            writeInt(&buf, Int32(9))
            FfiConverterSequenceTypeSeedKeysPreview.write(`f`, into: &buf)
            
        
        case let .`enumVariantNameCard`(`f`):
            writeInt(&buf, Int32(10))
            FfiConverterTypeMscEnumVariantName.write(`f`, into: &buf)
            
        
        case .`eraImmortalCard`:
            writeInt(&buf, Int32(11))
        
        
        case let .`eraMortalCard`(`f`):
            writeInt(&buf, Int32(12))
            FfiConverterTypeMscEraMortal.write(`f`, into: &buf)
            
        
        case let .`errorCard`(`f`):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(`f`, into: &buf)
            
        
        case let .`fieldNameCard`(`f`):
            writeInt(&buf, Int32(14))
            FfiConverterTypeMscFieldName.write(`f`, into: &buf)
            
        
        case let .`fieldNumberCard`(`f`):
            writeInt(&buf, Int32(15))
            FfiConverterTypeMscFieldNumber.write(`f`, into: &buf)
            
        
        case let .`idCard`(`f`):
            writeInt(&buf, Int32(16))
            FfiConverterTypeMscId.write(`f`, into: &buf)
            
        
        case let .`identityFieldCard`(`f`):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(`f`, into: &buf)
            
        
        case let .`metaCard`(`f`):
            writeInt(&buf, Int32(18))
            FfiConverterTypeMMetadataRecord.write(`f`, into: &buf)
            
        
        case let .`nameVersionCard`(`f`):
            writeInt(&buf, Int32(19))
            FfiConverterTypeMscNameVersion.write(`f`, into: &buf)
            
        
        case let .`networkGenesisHashCard`(`f`):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(`f`, into: &buf)
            
        
        case let .`networkNameCard`(`f`):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(`f`, into: &buf)
            
        
        case let .`networkInfoCard`(`f`):
            writeInt(&buf, Int32(22))
            FfiConverterTypeMscNetworkInfo.write(`f`, into: &buf)
            
        
        case let .`newSpecsCard`(`f`):
            writeInt(&buf, Int32(23))
            FfiConverterTypeNetworkSpecs.write(`f`, into: &buf)
            
        
        case let .`nonceCard`(`f`):
            writeInt(&buf, Int32(24))
            FfiConverterString.write(`f`, into: &buf)
            
        
        case .`noneCard`:
            writeInt(&buf, Int32(25))
        
        
        case let .`palletCard`(`f`):
            writeInt(&buf, Int32(26))
            FfiConverterString.write(`f`, into: &buf)
            
        
        case let .`textCard`(`f`):
            writeInt(&buf, Int32(27))
            FfiConverterString.write(`f`, into: &buf)
            
        
        case let .`tipCard`(`f`):
            writeInt(&buf, Int32(28))
            FfiConverterTypeMscCurrency.write(`f`, into: &buf)
            
        
        case let .`tipPlainCard`(`f`):
            writeInt(&buf, Int32(29))
            FfiConverterString.write(`f`, into: &buf)
            
        
        case let .`txSpecCard`(`f`):
            writeInt(&buf, Int32(30))
            FfiConverterString.write(`f`, into: &buf)
            
        
        case let .`txSpecPlainCard`(`f`):
            writeInt(&buf, Int32(31))
            FfiConverterTypeMscTxSpecPlain.write(`f`, into: &buf)
            
        
        case let .`typesInfoCard`(`f`):
            writeInt(&buf, Int32(32))
            FfiConverterTypeMTypesInfo.write(`f`, into: &buf)
            
        
        case let .`varNameCard`(`f`):
            writeInt(&buf, Int32(33))
            FfiConverterString.write(`f`, into: &buf)
            
        
        case let .`verifierCard`(`f`):
            writeInt(&buf, Int32(34))
            FfiConverterTypeMVerifierDetails.write(`f`, into: &buf)
            
        
        case let .`warningCard`(`f`):
            writeInt(&buf, Int32(35))
            FfiConverterString.write(`f`, into: &buf)
            
        }
    }
}


extension Card: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DecodeSequenceResult {
    
    case `bBananaSplitRecoveryResult`(`b`: BananaSplitRecoveryResult)
    case `other`(`s`: String)
}

public struct FfiConverterTypeDecodeSequenceResult: FfiConverterRustBuffer {
    typealias SwiftType = DecodeSequenceResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecodeSequenceResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`bBananaSplitRecoveryResult`(
            `b`: try FfiConverterTypeBananaSplitRecoveryResult.read(from: &buf)
        )
        
        case 2: return .`other`(
            `s`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DecodeSequenceResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`bBananaSplitRecoveryResult`(`b`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeBananaSplitRecoveryResult.write(`b`, into: &buf)
            
        
        case let .`other`(`s`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`s`, into: &buf)
            
        }
    }
}


extension DecodeSequenceResult: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DerivationDestination {
    
    case `pwd`
    case `pin`
}

public struct FfiConverterTypeDerivationDestination: FfiConverterRustBuffer {
    typealias SwiftType = DerivationDestination

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivationDestination {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`pwd`
        
        case 2: return .`pin`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DerivationDestination, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`pwd`:
            writeInt(&buf, Int32(1))
        
        
        case .`pin`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


extension DerivationDestination: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DerivedKeyError {
    
    case `networkMissing`
    case `keySetMissing`
    case `badFormat`
}

public struct FfiConverterTypeDerivedKeyError: FfiConverterRustBuffer {
    typealias SwiftType = DerivedKeyError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivedKeyError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`networkMissing`
        
        case 2: return .`keySetMissing`
        
        case 3: return .`badFormat`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DerivedKeyError, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`networkMissing`:
            writeInt(&buf, Int32(1))
        
        
        case .`keySetMissing`:
            writeInt(&buf, Int32(2))
        
        
        case .`badFormat`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


extension DerivedKeyError: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DerivedKeyStatus {
    
    case `importable`
    case `alreadyExists`
    case `invalid`(`errors`: [DerivedKeyError])
}

public struct FfiConverterTypeDerivedKeyStatus: FfiConverterRustBuffer {
    typealias SwiftType = DerivedKeyStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivedKeyStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`importable`
        
        case 2: return .`alreadyExists`
        
        case 3: return .`invalid`(
            `errors`: try FfiConverterSequenceTypeDerivedKeyError.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DerivedKeyStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`importable`:
            writeInt(&buf, Int32(1))
        
        
        case .`alreadyExists`:
            writeInt(&buf, Int32(2))
        
        
        case let .`invalid`(`errors`):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeDerivedKeyError.write(`errors`, into: &buf)
            
        }
    }
}


extension DerivedKeyStatus: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Encryption {
    
    case `ed25519`
    case `sr25519`
    case `ecdsa`
    case `ethereum`
}

public struct FfiConverterTypeEncryption: FfiConverterRustBuffer {
    typealias SwiftType = Encryption

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Encryption {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`ed25519`
        
        case 2: return .`sr25519`
        
        case 3: return .`ecdsa`
        
        case 4: return .`ethereum`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Encryption, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`ed25519`:
            writeInt(&buf, Int32(1))
        
        
        case .`sr25519`:
            writeInt(&buf, Int32(2))
        
        
        case .`ecdsa`:
            writeInt(&buf, Int32(3))
        
        
        case .`ethereum`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


extension Encryption: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Event {
    
    case `metadataAdded`(`metaValuesDisplay`: MetaValuesDisplay)
    case `metadataRemoved`(`metaValuesDisplay`: MetaValuesDisplay)
    case `metadataSigned`(`metaValuesExport`: MetaValuesExport)
    case `networkSpecsAdded`(`networkSpecsDisplay`: NetworkSpecsDisplay)
    case `networkSpecsRemoved`(`networkSpecsDisplay`: NetworkSpecsDisplay)
    case `networkSpecsSigned`(`networkSpecsExport`: NetworkSpecsExport)
    case `networkVerifierSet`(`networkVerifierDisplay`: NetworkVerifierDisplay)
    case `generalVerifierSet`(`verifier`: Verifier)
    case `typesAdded`(`typesDisplay`: TypesDisplay)
    case `typesRemoved`(`typesDisplay`: TypesDisplay)
    case `typesSigned`(`typesExport`: TypesExport)
    case `transactionSigned`(`signDisplay`: SignDisplay)
    case `transactionSignError`(`signDisplay`: SignDisplay)
    case `messageSigned`(`signMessageDisplay`: SignMessageDisplay)
    case `messageSignError`(`signMessageDisplay`: SignMessageDisplay)
    case `identityAdded`(`identityHistory`: IdentityHistory)
    case `identityRemoved`(`identityHistory`: IdentityHistory)
    case `identitiesWiped`
    case `deviceWasOnline`
    case `resetDangerRecord`
    case `seedCreated`(`seedCreated`: String)
    case `seedNameWasShown`(`seedNameWasShown`: String)
    case `warning`(`warning`: String)
    case `wrongPassword`
    case `userEntry`(`userEntry`: String)
    case `systemEntry`(`systemEntry`: String)
    case `historyCleared`
    case `databaseInitiated`
    case `seedRemoved`(`seedName`: String)
    case `secretWasExported`(`identityHistory`: IdentityHistory)
}

public struct FfiConverterTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = Event

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Event {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`metadataAdded`(
            `metaValuesDisplay`: try FfiConverterTypeMetaValuesDisplay.read(from: &buf)
        )
        
        case 2: return .`metadataRemoved`(
            `metaValuesDisplay`: try FfiConverterTypeMetaValuesDisplay.read(from: &buf)
        )
        
        case 3: return .`metadataSigned`(
            `metaValuesExport`: try FfiConverterTypeMetaValuesExport.read(from: &buf)
        )
        
        case 4: return .`networkSpecsAdded`(
            `networkSpecsDisplay`: try FfiConverterTypeNetworkSpecsDisplay.read(from: &buf)
        )
        
        case 5: return .`networkSpecsRemoved`(
            `networkSpecsDisplay`: try FfiConverterTypeNetworkSpecsDisplay.read(from: &buf)
        )
        
        case 6: return .`networkSpecsSigned`(
            `networkSpecsExport`: try FfiConverterTypeNetworkSpecsExport.read(from: &buf)
        )
        
        case 7: return .`networkVerifierSet`(
            `networkVerifierDisplay`: try FfiConverterTypeNetworkVerifierDisplay.read(from: &buf)
        )
        
        case 8: return .`generalVerifierSet`(
            `verifier`: try FfiConverterTypeVerifier.read(from: &buf)
        )
        
        case 9: return .`typesAdded`(
            `typesDisplay`: try FfiConverterTypeTypesDisplay.read(from: &buf)
        )
        
        case 10: return .`typesRemoved`(
            `typesDisplay`: try FfiConverterTypeTypesDisplay.read(from: &buf)
        )
        
        case 11: return .`typesSigned`(
            `typesExport`: try FfiConverterTypeTypesExport.read(from: &buf)
        )
        
        case 12: return .`transactionSigned`(
            `signDisplay`: try FfiConverterTypeSignDisplay.read(from: &buf)
        )
        
        case 13: return .`transactionSignError`(
            `signDisplay`: try FfiConverterTypeSignDisplay.read(from: &buf)
        )
        
        case 14: return .`messageSigned`(
            `signMessageDisplay`: try FfiConverterTypeSignMessageDisplay.read(from: &buf)
        )
        
        case 15: return .`messageSignError`(
            `signMessageDisplay`: try FfiConverterTypeSignMessageDisplay.read(from: &buf)
        )
        
        case 16: return .`identityAdded`(
            `identityHistory`: try FfiConverterTypeIdentityHistory.read(from: &buf)
        )
        
        case 17: return .`identityRemoved`(
            `identityHistory`: try FfiConverterTypeIdentityHistory.read(from: &buf)
        )
        
        case 18: return .`identitiesWiped`
        
        case 19: return .`deviceWasOnline`
        
        case 20: return .`resetDangerRecord`
        
        case 21: return .`seedCreated`(
            `seedCreated`: try FfiConverterString.read(from: &buf)
        )
        
        case 22: return .`seedNameWasShown`(
            `seedNameWasShown`: try FfiConverterString.read(from: &buf)
        )
        
        case 23: return .`warning`(
            `warning`: try FfiConverterString.read(from: &buf)
        )
        
        case 24: return .`wrongPassword`
        
        case 25: return .`userEntry`(
            `userEntry`: try FfiConverterString.read(from: &buf)
        )
        
        case 26: return .`systemEntry`(
            `systemEntry`: try FfiConverterString.read(from: &buf)
        )
        
        case 27: return .`historyCleared`
        
        case 28: return .`databaseInitiated`
        
        case 29: return .`seedRemoved`(
            `seedName`: try FfiConverterString.read(from: &buf)
        )
        
        case 30: return .`secretWasExported`(
            `identityHistory`: try FfiConverterTypeIdentityHistory.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Event, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`metadataAdded`(`metaValuesDisplay`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMetaValuesDisplay.write(`metaValuesDisplay`, into: &buf)
            
        
        case let .`metadataRemoved`(`metaValuesDisplay`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMetaValuesDisplay.write(`metaValuesDisplay`, into: &buf)
            
        
        case let .`metadataSigned`(`metaValuesExport`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeMetaValuesExport.write(`metaValuesExport`, into: &buf)
            
        
        case let .`networkSpecsAdded`(`networkSpecsDisplay`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeNetworkSpecsDisplay.write(`networkSpecsDisplay`, into: &buf)
            
        
        case let .`networkSpecsRemoved`(`networkSpecsDisplay`):
            writeInt(&buf, Int32(5))
            FfiConverterTypeNetworkSpecsDisplay.write(`networkSpecsDisplay`, into: &buf)
            
        
        case let .`networkSpecsSigned`(`networkSpecsExport`):
            writeInt(&buf, Int32(6))
            FfiConverterTypeNetworkSpecsExport.write(`networkSpecsExport`, into: &buf)
            
        
        case let .`networkVerifierSet`(`networkVerifierDisplay`):
            writeInt(&buf, Int32(7))
            FfiConverterTypeNetworkVerifierDisplay.write(`networkVerifierDisplay`, into: &buf)
            
        
        case let .`generalVerifierSet`(`verifier`):
            writeInt(&buf, Int32(8))
            FfiConverterTypeVerifier.write(`verifier`, into: &buf)
            
        
        case let .`typesAdded`(`typesDisplay`):
            writeInt(&buf, Int32(9))
            FfiConverterTypeTypesDisplay.write(`typesDisplay`, into: &buf)
            
        
        case let .`typesRemoved`(`typesDisplay`):
            writeInt(&buf, Int32(10))
            FfiConverterTypeTypesDisplay.write(`typesDisplay`, into: &buf)
            
        
        case let .`typesSigned`(`typesExport`):
            writeInt(&buf, Int32(11))
            FfiConverterTypeTypesExport.write(`typesExport`, into: &buf)
            
        
        case let .`transactionSigned`(`signDisplay`):
            writeInt(&buf, Int32(12))
            FfiConverterTypeSignDisplay.write(`signDisplay`, into: &buf)
            
        
        case let .`transactionSignError`(`signDisplay`):
            writeInt(&buf, Int32(13))
            FfiConverterTypeSignDisplay.write(`signDisplay`, into: &buf)
            
        
        case let .`messageSigned`(`signMessageDisplay`):
            writeInt(&buf, Int32(14))
            FfiConverterTypeSignMessageDisplay.write(`signMessageDisplay`, into: &buf)
            
        
        case let .`messageSignError`(`signMessageDisplay`):
            writeInt(&buf, Int32(15))
            FfiConverterTypeSignMessageDisplay.write(`signMessageDisplay`, into: &buf)
            
        
        case let .`identityAdded`(`identityHistory`):
            writeInt(&buf, Int32(16))
            FfiConverterTypeIdentityHistory.write(`identityHistory`, into: &buf)
            
        
        case let .`identityRemoved`(`identityHistory`):
            writeInt(&buf, Int32(17))
            FfiConverterTypeIdentityHistory.write(`identityHistory`, into: &buf)
            
        
        case .`identitiesWiped`:
            writeInt(&buf, Int32(18))
        
        
        case .`deviceWasOnline`:
            writeInt(&buf, Int32(19))
        
        
        case .`resetDangerRecord`:
            writeInt(&buf, Int32(20))
        
        
        case let .`seedCreated`(`seedCreated`):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(`seedCreated`, into: &buf)
            
        
        case let .`seedNameWasShown`(`seedNameWasShown`):
            writeInt(&buf, Int32(22))
            FfiConverterString.write(`seedNameWasShown`, into: &buf)
            
        
        case let .`warning`(`warning`):
            writeInt(&buf, Int32(23))
            FfiConverterString.write(`warning`, into: &buf)
            
        
        case .`wrongPassword`:
            writeInt(&buf, Int32(24))
        
        
        case let .`userEntry`(`userEntry`):
            writeInt(&buf, Int32(25))
            FfiConverterString.write(`userEntry`, into: &buf)
            
        
        case let .`systemEntry`(`systemEntry`):
            writeInt(&buf, Int32(26))
            FfiConverterString.write(`systemEntry`, into: &buf)
            
        
        case .`historyCleared`:
            writeInt(&buf, Int32(27))
        
        
        case .`databaseInitiated`:
            writeInt(&buf, Int32(28))
        
        
        case let .`seedRemoved`(`seedName`):
            writeInt(&buf, Int32(29))
            FfiConverterString.write(`seedName`, into: &buf)
            
        
        case let .`secretWasExported`(`identityHistory`):
            writeInt(&buf, Int32(30))
            FfiConverterTypeIdentityHistory.write(`identityHistory`, into: &buf)
            
        }
    }
}


extension Event: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ExportedSet {
    
    case `all`
    case `selected`(`s`: [PathAndNetwork])
}

public struct FfiConverterTypeExportedSet: FfiConverterRustBuffer {
    typealias SwiftType = ExportedSet

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExportedSet {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`all`
        
        case 2: return .`selected`(
            `s`: try FfiConverterSequenceTypePathAndNetwork.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ExportedSet, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`all`:
            writeInt(&buf, Int32(1))
        
        
        case let .`selected`(`s`):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypePathAndNetwork.write(`s`, into: &buf)
            
        }
    }
}


extension ExportedSet: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FooterButton {
    
    case `log`
    case `scan`
    case `keys`
    case `settings`
    case `back`
}

public struct FfiConverterTypeFooterButton: FfiConverterRustBuffer {
    typealias SwiftType = FooterButton

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FooterButton {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`log`
        
        case 2: return .`scan`
        
        case 3: return .`keys`
        
        case 4: return .`settings`
        
        case 5: return .`back`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FooterButton, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`log`:
            writeInt(&buf, Int32(1))
        
        
        case .`scan`:
            writeInt(&buf, Int32(2))
        
        
        case .`keys`:
            writeInt(&buf, Int32(3))
        
        
        case .`settings`:
            writeInt(&buf, Int32(4))
        
        
        case .`back`:
            writeInt(&buf, Int32(5))
        
        }
    }
}


extension FooterButton: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MscContent {
    
    case `loadTypes`(`types`: String, `pic`: SignerImage)
    case `loadMetadata`(`name`: String, `version`: UInt32)
    case `addSpecs`(`f`: MscNetworkInfo)
}

public struct FfiConverterTypeMscContent: FfiConverterRustBuffer {
    typealias SwiftType = MscContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MscContent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`loadTypes`(
            `types`: try FfiConverterString.read(from: &buf), 
            `pic`: try FfiConverterTypeSignerImage.read(from: &buf)
        )
        
        case 2: return .`loadMetadata`(
            `name`: try FfiConverterString.read(from: &buf), 
            `version`: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 3: return .`addSpecs`(
            `f`: try FfiConverterTypeMscNetworkInfo.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MscContent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`loadTypes`(`types`,`pic`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`types`, into: &buf)
            FfiConverterTypeSignerImage.write(`pic`, into: &buf)
            
        
        case let .`loadMetadata`(`name`,`version`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`name`, into: &buf)
            FfiConverterUInt32.write(`version`, into: &buf)
            
        
        case let .`addSpecs`(`f`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeMscNetworkInfo.write(`f`, into: &buf)
            
        }
    }
}


extension MscContent: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ModalData {
    
    case `sufficientCryptoReady`(`f`: MSufficientCryptoReady)
    case `backup`(`f`: MBackup)
    case `seedMenu`(`f`: MSeedMenu)
    case `newSeedBackup`(`f`: MNewSeedBackup)
    case `networkSelector`(`f`: MNetworkMenu)
    case `passwordConfirm`(`f`: MPasswordConfirm)
    case `signatureReady`(`f`: MSignatureReady)
    case `enterPassword`(`f`: MEnterPassword)
    case `logRight`(`f`: MLogRight)
    case `typesInfo`(`f`: MTypesInfo)
    case `newSeedMenu`
    case `networkDetailsMenu`
    case `manageMetadata`(`f`: MManageMetadata)
    case `keyDetailsAction`
    case `logComment`
    case `selectSeed`(`f`: MSeeds)
}

public struct FfiConverterTypeModalData: FfiConverterRustBuffer {
    typealias SwiftType = ModalData

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ModalData {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`sufficientCryptoReady`(
            `f`: try FfiConverterTypeMSufficientCryptoReady.read(from: &buf)
        )
        
        case 2: return .`backup`(
            `f`: try FfiConverterTypeMBackup.read(from: &buf)
        )
        
        case 3: return .`seedMenu`(
            `f`: try FfiConverterTypeMSeedMenu.read(from: &buf)
        )
        
        case 4: return .`newSeedBackup`(
            `f`: try FfiConverterTypeMNewSeedBackup.read(from: &buf)
        )
        
        case 5: return .`networkSelector`(
            `f`: try FfiConverterTypeMNetworkMenu.read(from: &buf)
        )
        
        case 6: return .`passwordConfirm`(
            `f`: try FfiConverterTypeMPasswordConfirm.read(from: &buf)
        )
        
        case 7: return .`signatureReady`(
            `f`: try FfiConverterTypeMSignatureReady.read(from: &buf)
        )
        
        case 8: return .`enterPassword`(
            `f`: try FfiConverterTypeMEnterPassword.read(from: &buf)
        )
        
        case 9: return .`logRight`(
            `f`: try FfiConverterTypeMLogRight.read(from: &buf)
        )
        
        case 10: return .`typesInfo`(
            `f`: try FfiConverterTypeMTypesInfo.read(from: &buf)
        )
        
        case 11: return .`newSeedMenu`
        
        case 12: return .`networkDetailsMenu`
        
        case 13: return .`manageMetadata`(
            `f`: try FfiConverterTypeMManageMetadata.read(from: &buf)
        )
        
        case 14: return .`keyDetailsAction`
        
        case 15: return .`logComment`
        
        case 16: return .`selectSeed`(
            `f`: try FfiConverterTypeMSeeds.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ModalData, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`sufficientCryptoReady`(`f`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMSufficientCryptoReady.write(`f`, into: &buf)
            
        
        case let .`backup`(`f`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMBackup.write(`f`, into: &buf)
            
        
        case let .`seedMenu`(`f`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeMSeedMenu.write(`f`, into: &buf)
            
        
        case let .`newSeedBackup`(`f`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeMNewSeedBackup.write(`f`, into: &buf)
            
        
        case let .`networkSelector`(`f`):
            writeInt(&buf, Int32(5))
            FfiConverterTypeMNetworkMenu.write(`f`, into: &buf)
            
        
        case let .`passwordConfirm`(`f`):
            writeInt(&buf, Int32(6))
            FfiConverterTypeMPasswordConfirm.write(`f`, into: &buf)
            
        
        case let .`signatureReady`(`f`):
            writeInt(&buf, Int32(7))
            FfiConverterTypeMSignatureReady.write(`f`, into: &buf)
            
        
        case let .`enterPassword`(`f`):
            writeInt(&buf, Int32(8))
            FfiConverterTypeMEnterPassword.write(`f`, into: &buf)
            
        
        case let .`logRight`(`f`):
            writeInt(&buf, Int32(9))
            FfiConverterTypeMLogRight.write(`f`, into: &buf)
            
        
        case let .`typesInfo`(`f`):
            writeInt(&buf, Int32(10))
            FfiConverterTypeMTypesInfo.write(`f`, into: &buf)
            
        
        case .`newSeedMenu`:
            writeInt(&buf, Int32(11))
        
        
        case .`networkDetailsMenu`:
            writeInt(&buf, Int32(12))
        
        
        case let .`manageMetadata`(`f`):
            writeInt(&buf, Int32(13))
            FfiConverterTypeMManageMetadata.write(`f`, into: &buf)
            
        
        case .`keyDetailsAction`:
            writeInt(&buf, Int32(14))
        
        
        case .`logComment`:
            writeInt(&buf, Int32(15))
        
        
        case let .`selectSeed`(`f`):
            writeInt(&buf, Int32(16))
            FfiConverterTypeMSeeds.write(`f`, into: &buf)
            
        }
    }
}


extension ModalData: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum QrData {
    
    case `regular`(`data`: [UInt8])
    case `sensitive`(`data`: [UInt8])
}

public struct FfiConverterTypeQrData: FfiConverterRustBuffer {
    typealias SwiftType = QrData

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QrData {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`regular`(
            `data`: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        case 2: return .`sensitive`(
            `data`: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: QrData, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`regular`(`data`):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceUInt8.write(`data`, into: &buf)
            
        
        case let .`sensitive`(`data`):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceUInt8.write(`data`, into: &buf)
            
        }
    }
}


extension QrData: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RightButton {
    
    case `logRight`
    case `newSeed`
    case `backup`
    case `multiSelect`
    case `ndMenu`
    case `typesInfo`
    case `keyMenu`
}

public struct FfiConverterTypeRightButton: FfiConverterRustBuffer {
    typealias SwiftType = RightButton

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RightButton {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`logRight`
        
        case 2: return .`newSeed`
        
        case 3: return .`backup`
        
        case 4: return .`multiSelect`
        
        case 5: return .`ndMenu`
        
        case 6: return .`typesInfo`
        
        case 7: return .`keyMenu`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RightButton, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`logRight`:
            writeInt(&buf, Int32(1))
        
        
        case .`newSeed`:
            writeInt(&buf, Int32(2))
        
        
        case .`backup`:
            writeInt(&buf, Int32(3))
        
        
        case .`multiSelect`:
            writeInt(&buf, Int32(4))
        
        
        case .`ndMenu`:
            writeInt(&buf, Int32(5))
        
        
        case .`typesInfo`:
            writeInt(&buf, Int32(6))
        
        
        case .`keyMenu`:
            writeInt(&buf, Int32(7))
        
        }
    }
}


extension RightButton: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ScreenData {
    
    case `scan`
    case `keys`(`f`: String)
    case `settings`(`f`: MSettings)
    case `log`(`f`: MLog)
    case `logDetails`(`f`: MLogDetails)
    case `transaction`(`f`: [MTransaction])
    case `seedSelector`(`f`: MSeeds)
    case `keyDetails`(`f`: MKeyDetails?)
    case `newSeed`(`f`: MNewSeed)
    case `recoverSeedName`(`f`: MRecoverSeedName)
    case `recoverSeedPhrase`(`f`: MRecoverSeedPhrase)
    case `deriveKey`(`f`: MDeriveKey)
    case `vVerifier`(`f`: MVerifierDetails)
    case `manageNetworks`(`f`: MManageNetworks)
    case `nNetworkDetails`(`f`: MNetworkDetails)
    case `signSufficientCrypto`(`f`: MSignSufficientCrypto)
    case `selectSeedForBackup`(`f`: MSeeds)
    case `documents`
    case `keyDetailsMulti`(`f`: MKeyDetailsMulti)
}

public struct FfiConverterTypeScreenData: FfiConverterRustBuffer {
    typealias SwiftType = ScreenData

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScreenData {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`scan`
        
        case 2: return .`keys`(
            `f`: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .`settings`(
            `f`: try FfiConverterTypeMSettings.read(from: &buf)
        )
        
        case 4: return .`log`(
            `f`: try FfiConverterTypeMLog.read(from: &buf)
        )
        
        case 5: return .`logDetails`(
            `f`: try FfiConverterTypeMLogDetails.read(from: &buf)
        )
        
        case 6: return .`transaction`(
            `f`: try FfiConverterSequenceTypeMTransaction.read(from: &buf)
        )
        
        case 7: return .`seedSelector`(
            `f`: try FfiConverterTypeMSeeds.read(from: &buf)
        )
        
        case 8: return .`keyDetails`(
            `f`: try FfiConverterOptionTypeMKeyDetails.read(from: &buf)
        )
        
        case 9: return .`newSeed`(
            `f`: try FfiConverterTypeMNewSeed.read(from: &buf)
        )
        
        case 10: return .`recoverSeedName`(
            `f`: try FfiConverterTypeMRecoverSeedName.read(from: &buf)
        )
        
        case 11: return .`recoverSeedPhrase`(
            `f`: try FfiConverterTypeMRecoverSeedPhrase.read(from: &buf)
        )
        
        case 12: return .`deriveKey`(
            `f`: try FfiConverterTypeMDeriveKey.read(from: &buf)
        )
        
        case 13: return .`vVerifier`(
            `f`: try FfiConverterTypeMVerifierDetails.read(from: &buf)
        )
        
        case 14: return .`manageNetworks`(
            `f`: try FfiConverterTypeMManageNetworks.read(from: &buf)
        )
        
        case 15: return .`nNetworkDetails`(
            `f`: try FfiConverterTypeMNetworkDetails.read(from: &buf)
        )
        
        case 16: return .`signSufficientCrypto`(
            `f`: try FfiConverterTypeMSignSufficientCrypto.read(from: &buf)
        )
        
        case 17: return .`selectSeedForBackup`(
            `f`: try FfiConverterTypeMSeeds.read(from: &buf)
        )
        
        case 18: return .`documents`
        
        case 19: return .`keyDetailsMulti`(
            `f`: try FfiConverterTypeMKeyDetailsMulti.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ScreenData, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`scan`:
            writeInt(&buf, Int32(1))
        
        
        case let .`keys`(`f`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`f`, into: &buf)
            
        
        case let .`settings`(`f`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeMSettings.write(`f`, into: &buf)
            
        
        case let .`log`(`f`):
            writeInt(&buf, Int32(4))
            FfiConverterTypeMLog.write(`f`, into: &buf)
            
        
        case let .`logDetails`(`f`):
            writeInt(&buf, Int32(5))
            FfiConverterTypeMLogDetails.write(`f`, into: &buf)
            
        
        case let .`transaction`(`f`):
            writeInt(&buf, Int32(6))
            FfiConverterSequenceTypeMTransaction.write(`f`, into: &buf)
            
        
        case let .`seedSelector`(`f`):
            writeInt(&buf, Int32(7))
            FfiConverterTypeMSeeds.write(`f`, into: &buf)
            
        
        case let .`keyDetails`(`f`):
            writeInt(&buf, Int32(8))
            FfiConverterOptionTypeMKeyDetails.write(`f`, into: &buf)
            
        
        case let .`newSeed`(`f`):
            writeInt(&buf, Int32(9))
            FfiConverterTypeMNewSeed.write(`f`, into: &buf)
            
        
        case let .`recoverSeedName`(`f`):
            writeInt(&buf, Int32(10))
            FfiConverterTypeMRecoverSeedName.write(`f`, into: &buf)
            
        
        case let .`recoverSeedPhrase`(`f`):
            writeInt(&buf, Int32(11))
            FfiConverterTypeMRecoverSeedPhrase.write(`f`, into: &buf)
            
        
        case let .`deriveKey`(`f`):
            writeInt(&buf, Int32(12))
            FfiConverterTypeMDeriveKey.write(`f`, into: &buf)
            
        
        case let .`vVerifier`(`f`):
            writeInt(&buf, Int32(13))
            FfiConverterTypeMVerifierDetails.write(`f`, into: &buf)
            
        
        case let .`manageNetworks`(`f`):
            writeInt(&buf, Int32(14))
            FfiConverterTypeMManageNetworks.write(`f`, into: &buf)
            
        
        case let .`nNetworkDetails`(`f`):
            writeInt(&buf, Int32(15))
            FfiConverterTypeMNetworkDetails.write(`f`, into: &buf)
            
        
        case let .`signSufficientCrypto`(`f`):
            writeInt(&buf, Int32(16))
            FfiConverterTypeMSignSufficientCrypto.write(`f`, into: &buf)
            
        
        case let .`selectSeedForBackup`(`f`):
            writeInt(&buf, Int32(17))
            FfiConverterTypeMSeeds.write(`f`, into: &buf)
            
        
        case .`documents`:
            writeInt(&buf, Int32(18))
        
        
        case let .`keyDetailsMulti`(`f`):
            writeInt(&buf, Int32(19))
            FfiConverterTypeMKeyDetailsMulti.write(`f`, into: &buf)
            
        }
    }
}


extension ScreenData: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ScreenNameType {
    
    case `h1`
    case `h4`
}

public struct FfiConverterTypeScreenNameType: FfiConverterRustBuffer {
    typealias SwiftType = ScreenNameType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScreenNameType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`h1`
        
        case 2: return .`h4`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ScreenNameType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`h1`:
            writeInt(&buf, Int32(1))
        
        
        case .`h4`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


extension ScreenNameType: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ShieldAlert {
    
    case `past`
}

public struct FfiConverterTypeShieldAlert: FfiConverterRustBuffer {
    typealias SwiftType = ShieldAlert

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShieldAlert {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`past`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ShieldAlert, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`past`:
            writeInt(&buf, Int32(1))
        
        }
    }
}


extension ShieldAlert: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SignerImage {
    
    case `svg`(`image`: [UInt8])
    case `png`(`image`: [UInt8])
}

public struct FfiConverterTypeSignerImage: FfiConverterRustBuffer {
    typealias SwiftType = SignerImage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignerImage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`svg`(
            `image`: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        case 2: return .`png`(
            `image`: try FfiConverterSequenceUInt8.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignerImage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`svg`(`image`):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceUInt8.write(`image`, into: &buf)
            
        
        case let .`png`(`image`):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceUInt8.write(`image`, into: &buf)
            
        }
    }
}


extension SignerImage: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TransactionType {
    
    case `sign`
    case `stub`
    case `read`
    case `importDerivations`
    case `done`
}

public struct FfiConverterTypeTransactionType: FfiConverterRustBuffer {
    typealias SwiftType = TransactionType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`sign`
        
        case 2: return .`stub`
        
        case 3: return .`read`
        
        case 4: return .`importDerivations`
        
        case 5: return .`done`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`sign`:
            writeInt(&buf, Int32(1))
        
        
        case .`stub`:
            writeInt(&buf, Int32(2))
        
        
        case .`read`:
            writeInt(&buf, Int32(3))
        
        
        case .`importDerivations`:
            writeInt(&buf, Int32(4))
        
        
        case .`done`:
            writeInt(&buf, Int32(5))
        
        }
    }
}


extension TransactionType: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ValidCurrentVerifier {
    
    case `general`
    case `custom`(`v`: Verifier)
}

public struct FfiConverterTypeValidCurrentVerifier: FfiConverterRustBuffer {
    typealias SwiftType = ValidCurrentVerifier

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ValidCurrentVerifier {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`general`
        
        case 2: return .`custom`(
            `v`: try FfiConverterTypeVerifier.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ValidCurrentVerifier, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`general`:
            writeInt(&buf, Int32(1))
        
        
        case let .`custom`(`v`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeVerifier.write(`v`, into: &buf)
            
        }
    }
}


extension ValidCurrentVerifier: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum VerifierValue {
    
    case `standard`(`m`: MultiSigner)
}

public struct FfiConverterTypeVerifierValue: FfiConverterRustBuffer {
    typealias SwiftType = VerifierValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifierValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`standard`(
            `m`: try FfiConverterTypeMultiSigner.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VerifierValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`standard`(`m`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMultiSigner.write(`m`, into: &buf)
            
        }
    }
}


extension VerifierValue: Equatable, Hashable {}



public enum ErrorDisplayed {

    
    
    case Str(`s`: String)
    case MutexPoisoned
    case DbNotInitialized
    case LoadMetaUnknownNetwork(`name`: String)
    case SpecsKnown(`name`: String, `encryption`: Encryption)
    case MetadataKnown(`name`: String, `version`: UInt32)
    case MetadataOutdated(`name`: String, `have`: UInt32, `want`: UInt32)
    case UnknownNetwork(`genesisHash`: H256, `encryption`: Encryption)
    case NoMetadata(`name`: String)
}

public struct FfiConverterTypeErrorDisplayed: FfiConverterRustBuffer {
    typealias SwiftType = ErrorDisplayed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ErrorDisplayed {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Str(
            `s`: try FfiConverterString.read(from: &buf)
            )
        case 2: return .MutexPoisoned
        case 3: return .DbNotInitialized
        case 4: return .LoadMetaUnknownNetwork(
            `name`: try FfiConverterString.read(from: &buf)
            )
        case 5: return .SpecsKnown(
            `name`: try FfiConverterString.read(from: &buf), 
            `encryption`: try FfiConverterTypeEncryption.read(from: &buf)
            )
        case 6: return .MetadataKnown(
            `name`: try FfiConverterString.read(from: &buf), 
            `version`: try FfiConverterUInt32.read(from: &buf)
            )
        case 7: return .MetadataOutdated(
            `name`: try FfiConverterString.read(from: &buf), 
            `have`: try FfiConverterUInt32.read(from: &buf), 
            `want`: try FfiConverterUInt32.read(from: &buf)
            )
        case 8: return .UnknownNetwork(
            `genesisHash`: try FfiConverterTypeH256.read(from: &buf), 
            `encryption`: try FfiConverterTypeEncryption.read(from: &buf)
            )
        case 9: return .NoMetadata(
            `name`: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ErrorDisplayed, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Str(`s`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`s`, into: &buf)
            
        
        case .MutexPoisoned:
            writeInt(&buf, Int32(2))
        
        
        case .DbNotInitialized:
            writeInt(&buf, Int32(3))
        
        
        case let .LoadMetaUnknownNetwork(`name`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`name`, into: &buf)
            
        
        case let .SpecsKnown(`name`,`encryption`):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(`name`, into: &buf)
            FfiConverterTypeEncryption.write(`encryption`, into: &buf)
            
        
        case let .MetadataKnown(`name`,`version`):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(`name`, into: &buf)
            FfiConverterUInt32.write(`version`, into: &buf)
            
        
        case let .MetadataOutdated(`name`,`have`,`want`):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(`name`, into: &buf)
            FfiConverterUInt32.write(`have`, into: &buf)
            FfiConverterUInt32.write(`want`, into: &buf)
            
        
        case let .UnknownNetwork(`genesisHash`,`encryption`):
            writeInt(&buf, Int32(8))
            FfiConverterTypeH256.write(`genesisHash`, into: &buf)
            FfiConverterTypeEncryption.write(`encryption`, into: &buf)
            
        
        case let .NoMetadata(`name`):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(`name`, into: &buf)
            
        }
    }
}


extension ErrorDisplayed: Equatable, Hashable {}

extension ErrorDisplayed: Error { }


public enum QrSequenceDecodeError {

    
    
    case BananaSplitWrongPassword
    case BananaSplit(`s`: String)
    case GenericError(`s`: String)
}

public struct FfiConverterTypeQrSequenceDecodeError: FfiConverterRustBuffer {
    typealias SwiftType = QrSequenceDecodeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QrSequenceDecodeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BananaSplitWrongPassword
        case 2: return .BananaSplit(
            `s`: try FfiConverterString.read(from: &buf)
            )
        case 3: return .GenericError(
            `s`: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: QrSequenceDecodeError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .BananaSplitWrongPassword:
            writeInt(&buf, Int32(1))
        
        
        case let .BananaSplit(`s`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`s`, into: &buf)
            
        
        case let .GenericError(`s`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`s`, into: &buf)
            
        }
    }
}


extension QrSequenceDecodeError: Equatable, Hashable {}

extension QrSequenceDecodeError: Error { }

fileprivate struct FfiConverterOptionUInt16: FfiConverterRustBuffer {
    typealias SwiftType = UInt16?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMAddressCard: FfiConverterRustBuffer {
    typealias SwiftType = MAddressCard?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMAddressCard.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMAddressCard.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMKeyDetails: FfiConverterRustBuffer {
    typealias SwiftType = MKeyDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMKeyDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMKeyDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMscNetworkInfo: FfiConverterRustBuffer {
    typealias SwiftType = MscNetworkInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMscNetworkInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMscNetworkInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMVerifierDetails: FfiConverterRustBuffer {
    typealias SwiftType = MVerifierDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMVerifierDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMVerifierDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTransactionCardSet: FfiConverterRustBuffer {
    typealias SwiftType = TransactionCardSet?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTransactionCardSet.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTransactionCardSet.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAlertData: FfiConverterRustBuffer {
    typealias SwiftType = AlertData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAlertData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAlertData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeDerivationDestination: FfiConverterRustBuffer {
    typealias SwiftType = DerivationDestination?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDerivationDestination.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDerivationDestination.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFooterButton: FfiConverterRustBuffer {
    typealias SwiftType = FooterButton?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFooterButton.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFooterButton.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeModalData: FfiConverterRustBuffer {
    typealias SwiftType = ModalData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeModalData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeModalData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRightButton: FfiConverterRustBuffer {
    typealias SwiftType = RightButton?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRightButton.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRightButton.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeShieldAlert: FfiConverterRustBuffer {
    typealias SwiftType = ShieldAlert?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeShieldAlert.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeShieldAlert.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSignerImage: FfiConverterRustBuffer {
    typealias SwiftType = SignerImage?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSignerImage.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSignerImage.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeVerifierValue: FfiConverterRustBuffer {
    typealias SwiftType = VerifierValue?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVerifierValue.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVerifierValue.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeTransactionCard: FfiConverterRustBuffer {
    typealias SwiftType = [TransactionCard]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeTransactionCard.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeTransactionCard.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeDerivationEntry: FfiConverterRustBuffer {
    typealias SwiftType = [DerivationEntry]

    public static func write(_ value: [DerivationEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDerivationEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DerivationEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [DerivationEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDerivationEntry.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeDerivationPack: FfiConverterRustBuffer {
    typealias SwiftType = [DerivationPack]

    public static func write(_ value: [DerivationPack], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDerivationPack.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DerivationPack] {
        let len: Int32 = try readInt(&buf)
        var seq = [DerivationPack]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDerivationPack.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeDerivedKeyPreview: FfiConverterRustBuffer {
    typealias SwiftType = [DerivedKeyPreview]

    public static func write(_ value: [DerivedKeyPreview], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDerivedKeyPreview.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DerivedKeyPreview] {
        let len: Int32 = try readInt(&buf)
        var seq = [DerivedKeyPreview]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDerivedKeyPreview.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeHistory: FfiConverterRustBuffer {
    typealias SwiftType = [History]

    public static func write(_ value: [History], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHistory.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [History] {
        let len: Int32 = try readInt(&buf)
        var seq = [History]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHistory.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeMEventMaybeDecoded: FfiConverterRustBuffer {
    typealias SwiftType = [MEventMaybeDecoded]

    public static func write(_ value: [MEventMaybeDecoded], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMEventMaybeDecoded.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MEventMaybeDecoded] {
        let len: Int32 = try readInt(&buf)
        var seq = [MEventMaybeDecoded]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMEventMaybeDecoded.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeMKeyAndNetworkCard: FfiConverterRustBuffer {
    typealias SwiftType = [MKeyAndNetworkCard]

    public static func write(_ value: [MKeyAndNetworkCard], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMKeyAndNetworkCard.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MKeyAndNetworkCard] {
        let len: Int32 = try readInt(&buf)
        var seq = [MKeyAndNetworkCard]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMKeyAndNetworkCard.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeMmmNetwork: FfiConverterRustBuffer {
    typealias SwiftType = [MmmNetwork]

    public static func write(_ value: [MmmNetwork], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMmmNetwork.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MmmNetwork] {
        let len: Int32 = try readInt(&buf)
        var seq = [MmmNetwork]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMmmNetwork.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeMmNetwork: FfiConverterRustBuffer {
    typealias SwiftType = [MmNetwork]

    public static func write(_ value: [MmNetwork], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMmNetwork.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MmNetwork] {
        let len: Int32 = try readInt(&buf)
        var seq = [MmNetwork]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMmNetwork.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeMMetadataRecord: FfiConverterRustBuffer {
    typealias SwiftType = [MMetadataRecord]

    public static func write(_ value: [MMetadataRecord], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMMetadataRecord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MMetadataRecord] {
        let len: Int32 = try readInt(&buf)
        var seq = [MMetadataRecord]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMMetadataRecord.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeMRawKey: FfiConverterRustBuffer {
    typealias SwiftType = [MRawKey]

    public static func write(_ value: [MRawKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMRawKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MRawKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [MRawKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMRawKey.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeMTransaction: FfiConverterRustBuffer {
    typealias SwiftType = [MTransaction]

    public static func write(_ value: [MTransaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMTransaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MTransaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [MTransaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMTransaction.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = [Network]

    public static func write(_ value: [Network], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNetwork.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Network] {
        let len: Int32 = try readInt(&buf)
        var seq = [Network]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNetwork.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePathAndNetwork: FfiConverterRustBuffer {
    typealias SwiftType = [PathAndNetwork]

    public static func write(_ value: [PathAndNetwork], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePathAndNetwork.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PathAndNetwork] {
        let len: Int32 = try readInt(&buf)
        var seq = [PathAndNetwork]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePathAndNetwork.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSeedKeysPreview: FfiConverterRustBuffer {
    typealias SwiftType = [SeedKeysPreview]

    public static func write(_ value: [SeedKeysPreview], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSeedKeysPreview.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SeedKeysPreview] {
        let len: Int32 = try readInt(&buf)
        var seq = [SeedKeysPreview]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSeedKeysPreview.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSeedNameCard: FfiConverterRustBuffer {
    typealias SwiftType = [SeedNameCard]

    public static func write(_ value: [SeedNameCard], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSeedNameCard.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SeedNameCard] {
        let len: Int32 = try readInt(&buf)
        var seq = [SeedNameCard]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSeedNameCard.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTransactionCard: FfiConverterRustBuffer {
    typealias SwiftType = [TransactionCard]

    public static func write(_ value: [TransactionCard], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransactionCard.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TransactionCard] {
        let len: Int32 = try readInt(&buf)
        var seq = [TransactionCard]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransactionCard.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeDerivedKeyError: FfiConverterRustBuffer {
    typealias SwiftType = [DerivedKeyError]

    public static func write(_ value: [DerivedKeyError], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDerivedKeyError.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DerivedKeyError] {
        let len: Int32 = try readInt(&buf)
        var seq = [DerivedKeyError]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDerivedKeyError.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = [Event]

    public static func write(_ value: [Event], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEvent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Event] {
        let len: Int32 = try readInt(&buf)
        var seq = [Event]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEvent.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeQrData: FfiConverterRustBuffer {
    typealias SwiftType = [QrData]

    public static func write(_ value: [QrData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeQrData.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [QrData] {
        let len: Int32 = try readInt(&buf)
        var seq = [QrData]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeQrData.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringTypeExportedSet: FfiConverterRustBuffer {
    public static func write(_ value: [String: ExportedSet], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeExportedSet.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: ExportedSet] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: ExportedSet]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeExportedSet.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias EcdsaPublic = [UInt8]
public struct FfiConverterTypeEcdsaPublic: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EcdsaPublic {
        return try FfiConverterSequenceUInt8.read(from: &buf)
    }

    public static func write(_ value: EcdsaPublic, into buf: inout [UInt8]) {
        return FfiConverterSequenceUInt8.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> EcdsaPublic {
        return try FfiConverterSequenceUInt8.lift(value)
    }

    public static func lower(_ value: EcdsaPublic) -> RustBuffer {
        return FfiConverterSequenceUInt8.lower(value)
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Ed25519Public = [UInt8]
public struct FfiConverterTypeEd25519Public: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ed25519Public {
        return try FfiConverterSequenceUInt8.read(from: &buf)
    }

    public static func write(_ value: Ed25519Public, into buf: inout [UInt8]) {
        return FfiConverterSequenceUInt8.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Ed25519Public {
        return try FfiConverterSequenceUInt8.lift(value)
    }

    public static func lower(_ value: Ed25519Public) -> RustBuffer {
        return FfiConverterSequenceUInt8.lower(value)
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias H256 = [UInt8]
public struct FfiConverterTypeH256: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> H256 {
        return try FfiConverterSequenceUInt8.read(from: &buf)
    }

    public static func write(_ value: H256, into buf: inout [UInt8]) {
        return FfiConverterSequenceUInt8.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> H256 {
        return try FfiConverterSequenceUInt8.lift(value)
    }

    public static func lower(_ value: H256) -> RustBuffer {
        return FfiConverterSequenceUInt8.lower(value)
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias MultiSigner = [String]
public struct FfiConverterTypeMultiSigner: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MultiSigner {
        return try FfiConverterSequenceString.read(from: &buf)
    }

    public static func write(_ value: MultiSigner, into buf: inout [UInt8]) {
        return FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> MultiSigner {
        return try FfiConverterSequenceString.lift(value)
    }

    public static func lower(_ value: MultiSigner) -> RustBuffer {
        return FfiConverterSequenceString.lower(value)
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Sr25519Public = [UInt8]
public struct FfiConverterTypeSr25519Public: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Sr25519Public {
        return try FfiConverterSequenceUInt8.read(from: &buf)
    }

    public static func write(_ value: Sr25519Public, into buf: inout [UInt8]) {
        return FfiConverterSequenceUInt8.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Sr25519Public {
        return try FfiConverterSequenceUInt8.lift(value)
    }

    public static func lower(_ value: Sr25519Public) -> RustBuffer {
        return FfiConverterSequenceUInt8.lower(value)
    }
}

public func `actionGetName`(`action`: Action)  -> FooterButton? {
    return try! FfiConverterOptionTypeFooterButton.lift(
        try!
    
    rustCall() {
    
    signer_23f1_action_get_name(
        FfiConverterTypeAction.lower(`action`), $0)
}
    )
}



public func `initNavigation`(`dbname`: String, `seedNames`: [String]) throws {
    try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_init_navigation(
        FfiConverterString.lower(`dbname`), 
        FfiConverterSequenceString.lower(`seedNames`), $0)
}
}


public func `backendAction`(`action`: Action, `details`: String, `seedPhrase`: String) throws -> ActionResult {
    return try FfiConverterTypeActionResult.lift(
        try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_backend_action(
        FfiConverterTypeAction.lower(`action`), 
        FfiConverterString.lower(`details`), 
        FfiConverterString.lower(`seedPhrase`), $0)
}
    )
}



public func `updateSeedNames`(`seedNames`: [String]) throws {
    try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_update_seed_names(
        FfiConverterSequenceString.lower(`seedNames`), $0)
}
}


public func `qrparserGetPacketsTotal`(`data`: String, `cleaned`: Bool) throws -> UInt32 {
    return try FfiConverterUInt32.lift(
        try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_qrparser_get_packets_total(
        FfiConverterString.lower(`data`), 
        FfiConverterBool.lower(`cleaned`), $0)
}
    )
}



public func `qrparserTryDecodeQrSequence`(`data`: [String], `password`: String?, `cleaned`: Bool) throws -> DecodeSequenceResult {
    return try FfiConverterTypeDecodeSequenceResult.lift(
        try
    
    rustCallWithError(FfiConverterTypeQrSequenceDecodeError.self) {
    
    signer_23f1_qrparser_try_decode_qr_sequence(
        FfiConverterSequenceString.lower(`data`), 
        FfiConverterOptionString.lower(`password`), 
        FfiConverterBool.lower(`cleaned`), $0)
}
    )
}



public func `generateSecretKeyQr`(`publicKey`: String, `expectedSeedName`: String, `networkSpecsKey`: String, `seedPhrase`: String, `keyPassword`: String?) throws -> MKeyDetails {
    return try FfiConverterTypeMKeyDetails.lift(
        try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_generate_secret_key_qr(
        FfiConverterString.lower(`publicKey`), 
        FfiConverterString.lower(`expectedSeedName`), 
        FfiConverterString.lower(`networkSpecsKey`), 
        FfiConverterString.lower(`seedPhrase`), 
        FfiConverterOptionString.lower(`keyPassword`), $0)
}
    )
}



public func `importDerivations`(`seedDerivedKeys`: [SeedKeysPreview]) throws {
    try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_import_derivations(
        FfiConverterSequenceTypeSeedKeysPreview.lower(`seedDerivedKeys`), $0)
}
}


public func `populateDerivationsHasPwd`(`seeds`: [String: String], `seedDerivedKeys`: [SeedKeysPreview]) throws -> [SeedKeysPreview] {
    return try FfiConverterSequenceTypeSeedKeysPreview.lift(
        try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_populate_derivations_has_pwd(
        FfiConverterDictionaryStringString.lower(`seeds`), 
        FfiConverterSequenceTypeSeedKeysPreview.lower(`seedDerivedKeys`), $0)
}
    )
}



public func `substratePathCheck`(`seedName`: String, `path`: String, `network`: String) throws -> DerivationCheck {
    return try FfiConverterTypeDerivationCheck.lift(
        try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_substrate_path_check(
        FfiConverterString.lower(`seedName`), 
        FfiConverterString.lower(`path`), 
        FfiConverterString.lower(`network`), $0)
}
    )
}



public func `tryCreateAddress`(`seedName`: String, `seedPhrase`: String, `path`: String, `network`: String) throws {
    try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_try_create_address(
        FfiConverterString.lower(`seedName`), 
        FfiConverterString.lower(`seedPhrase`), 
        FfiConverterString.lower(`path`), 
        FfiConverterString.lower(`network`), $0)
}
}


public func `historyInitHistoryWithCert`() throws {
    try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_history_init_history_with_cert($0)
}
}


public func `historyInitHistoryNoCert`() throws {
    try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_history_init_history_no_cert($0)
}
}


public func `historyDeviceWasOnline`() throws {
    try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_history_device_was_online($0)
}
}


public func `historyGetWarnings`() throws -> Bool {
    return try FfiConverterBool.lift(
        try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_history_get_warnings($0)
}
    )
}



public func `historyAcknowledgeWarnings`() throws {
    try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_history_acknowledge_warnings($0)
}
}


public func `historyEntrySystem`(`event`: Event) throws {
    try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_history_entry_system(
        FfiConverterTypeEvent.lower(`event`), $0)
}
}


public func `historySeedNameWasShown`(`seedName`: String) throws {
    try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_history_seed_name_was_shown(
        FfiConverterString.lower(`seedName`), $0)
}
}


public func `exportKeyInfo`(`selectedNames`: [String: ExportedSet]) throws -> MKeysInfoExport {
    return try FfiConverterTypeMKeysInfoExport.lift(
        try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_export_key_info(
        FfiConverterDictionaryStringTypeExportedSet.lower(`selectedNames`), $0)
}
    )
}



public func `keysBySeedName`(`seedName`: String) throws -> MKeysNew {
    return try FfiConverterTypeMKeysNew.lift(
        try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_keys_by_seed_name(
        FfiConverterString.lower(`seedName`), $0)
}
    )
}



public func `encodeToQr`(`payload`: [UInt8], `isDanger`: Bool) throws -> [UInt8] {
    return try FfiConverterSequenceUInt8.lift(
        try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_encode_to_qr(
        FfiConverterSequenceUInt8.lower(`payload`), 
        FfiConverterBool.lower(`isDanger`), $0)
}
    )
}



public func `getAllNetworks`() throws -> [MmNetwork] {
    return try FfiConverterSequenceTypeMmNetwork.lift(
        try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_get_all_networks($0)
}
    )
}



public func `initLogging`(`tag`: String)  {
    try!
    
    rustCall() {
    
    signer_23f1_init_logging(
        FfiConverterString.lower(`tag`), $0)
}
}


public func `getLogs`() throws -> MLog {
    return try FfiConverterTypeMLog.lift(
        try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_get_logs($0)
}
    )
}



public func `getLogDetails`(`order`: UInt32) throws -> MLogDetails {
    return try FfiConverterTypeMLogDetails.lift(
        try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_get_log_details(
        FfiConverterUInt32.lower(`order`), $0)
}
    )
}



public func `clearLogHistory`() throws {
    try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_clear_log_history($0)
}
}


public func `handleLogComment`(`userInput`: String) throws {
    try
    
    rustCallWithError(FfiConverterTypeErrorDisplayed.self) {
    
    signer_23f1_handle_log_comment(
        FfiConverterString.lower(`userInput`), $0)
}
}


/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum SignerLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {
    }
}